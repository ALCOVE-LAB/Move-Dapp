{"version":3,"sources":["../../src/client/core.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { AptosApiError, AptosResponse } from \"./types\";\nimport { VERSION } from \"../version\";\nimport { AptosRequest, MimeType, ClientRequest, ClientResponse, Client, AnyNumber } from \"../types\";\n\n/**\n * Meaningful errors map\n */\nconst errors: Record<number, string> = {\n  400: \"Bad Request\",\n  401: \"Unauthorized\",\n  403: \"Forbidden\",\n  404: \"Not Found\",\n  429: \"Too Many Requests\",\n  500: \"Internal Server Error\",\n  502: \"Bad Gateway\",\n  503: \"Service Unavailable\",\n};\n\n/**\n * Given a url and method, sends the request with axios and\n * returns the response.\n */\nexport async function request<Req, Res>(options: ClientRequest<Req>, client: Client): Promise<ClientResponse<Res>> {\n  const { url, method, body, contentType, params, overrides } = options;\n  const headers: Record<string, string | AnyNumber | boolean | undefined> = {\n    ...overrides?.HEADERS,\n    \"x-aptos-client\": `aptos-typescript-sdk/${VERSION}`,\n    \"content-type\": contentType ?? MimeType.JSON,\n  };\n\n  // TODO - auth token is being used only for faucet, it breaks full node requests.\n  // Find a more sophisticated way than that but without the need to add the\n  // auth_token on every `aptos.fundAccount()` call\n  if (overrides?.AUTH_TOKEN && url.includes(\"faucet\")) {\n    headers.Authorization = `Bearer ${overrides?.AUTH_TOKEN}`;\n  }\n  if (overrides?.API_KEY && !url.includes(\"faucet\")) {\n    headers.Authorization = `Bearer ${overrides?.API_KEY}`;\n  }\n\n  /*\n   * make a call using the @aptos-labs/aptos-client package\n   * {@link https://www.npmjs.com/package/@aptos-labs/aptos-client}\n   */\n  return client.provider<Req, Res>({\n    url,\n    method,\n    body,\n    params,\n    headers,\n    overrides,\n  });\n}\n\n/**\n * The main function to use when doing an API request.\n *\n * @param options AptosRequest\n * @param aptosConfig The config information for the SDK client instance\n * @returns the response or AptosApiError\n */\nexport async function aptosRequest<Req extends {}, Res extends {}>(\n  options: AptosRequest,\n  aptosConfig: AptosConfig,\n): Promise<AptosResponse<Req, Res>> {\n  const { url, path } = options;\n  const fullUrl = path ? `${url}/${path}` : url;\n  const response = await request<Req, Res>({ ...options, url: fullUrl }, aptosConfig.client);\n\n  const result: AptosResponse<Req, Res> = {\n    status: response.status,\n    statusText: response.statusText!,\n    data: response.data,\n    headers: response.headers,\n    config: response.config,\n    request: response.request,\n    url: fullUrl,\n  };\n\n  // to support both fullnode and indexer responses,\n  // check if it is an indexer query, and adjust response.data\n  if (aptosConfig.isIndexerRequest(url)) {\n    const indexerResponse = result.data as any;\n    // errors from indexer\n    if (indexerResponse.errors) {\n      throw new AptosApiError(\n        options,\n        result,\n        `Indexer error: ${indexerResponse.errors[0].message}` ??\n          `Indexer unhandled Error ${response.status} : ${response.statusText}`,\n      );\n    }\n    result.data = indexerResponse.data as Res;\n  }\n\n  if (result.status >= 200 && result.status < 300) {\n    return result;\n  }\n\n  let errorMessage: string;\n\n  if (result && result.data && \"message\" in result.data && \"error_code\" in result.data) {\n    errorMessage = JSON.stringify(result.data);\n  } else if (result.status in errors) {\n    // If it's not an API type, it must come form infra, these are prehandled\n    errorMessage = errors[result.status];\n  } else {\n    // Everything else is unhandled\n    errorMessage = `Unhandled Error ${result.status} : ${result.statusText}`;\n  }\n\n  // Since we already checked if it is an Indexer request, here we can be sure\n  // it either Fullnode or Faucet request\n  throw new AptosApiError(\n    options,\n    result,\n    `${aptosConfig.isFullnodeRequest(url) ? \"Fullnode\" : \"Faucet\"} error: ${errorMessage}`,\n  );\n}\n"],"mappings":"kFAWA,IAAMA,EAAiC,CACrC,IAAK,cACL,IAAK,eACL,IAAK,YACL,IAAK,YACL,IAAK,oBACL,IAAK,wBACL,IAAK,cACL,IAAK,qBACP,EAMA,eAAsBC,EAAkBC,EAA6BC,EAA8C,CACjH,GAAM,CAAE,IAAAC,EAAK,OAAAC,EAAQ,KAAAC,EAAM,YAAAC,EAAa,OAAAC,EAAQ,UAAAC,CAAU,EAAIP,EACxDQ,EAAoE,CACxE,GAAGD,GAAW,QACd,iBAAkB,wBAAwBE,CAAO,GACjD,eAAgBJ,qBAClB,EAKA,OAAIE,GAAW,YAAcL,EAAI,SAAS,QAAQ,IAChDM,EAAQ,cAAgB,UAAUD,GAAW,UAAU,IAErDA,GAAW,SAAW,CAACL,EAAI,SAAS,QAAQ,IAC9CM,EAAQ,cAAgB,UAAUD,GAAW,OAAO,IAO/CN,EAAO,SAAmB,CAC/B,IAAAC,EACA,OAAAC,EACA,KAAAC,EACA,OAAAE,EACA,QAAAE,EACA,UAAAD,CACF,CAAC,CACH,CASA,eAAsBG,EACpBV,EACAW,EACkC,CAClC,GAAM,CAAE,IAAAT,EAAK,KAAAU,CAAK,EAAIZ,EAChBa,EAAUD,EAAO,GAAGV,CAAG,IAAIU,CAAI,GAAKV,EACpCY,EAAW,MAAMf,EAAkB,CAAE,GAAGC,EAAS,IAAKa,CAAQ,EAAGF,EAAY,MAAM,EAEnFI,EAAkC,CACtC,OAAQD,EAAS,OACjB,WAAYA,EAAS,WACrB,KAAMA,EAAS,KACf,QAASA,EAAS,QAClB,OAAQA,EAAS,OACjB,QAASA,EAAS,QAClB,IAAKD,CACP,EAIA,GAAIF,EAAY,iBAAiBT,CAAG,EAAG,CACrC,IAAMc,EAAkBD,EAAO,KAE/B,GAAIC,EAAgB,OAClB,MAAM,IAAIC,EACRjB,EACAe,EACA,kBAAkBC,EAAgB,OAAO,CAAC,EAAE,OAAO,IACjD,2BAA2BF,EAAS,MAAM,MAAMA,EAAS,UAAU,EACvE,EAEFC,EAAO,KAAOC,EAAgB,IAChC,CAEA,GAAID,EAAO,QAAU,KAAOA,EAAO,OAAS,IAC1C,OAAOA,EAGT,IAAIG,EAEJ,MAAIH,GAAUA,EAAO,MAAQ,YAAaA,EAAO,MAAQ,eAAgBA,EAAO,KAC9EG,EAAe,KAAK,UAAUH,EAAO,IAAI,EAChCA,EAAO,UAAUjB,EAE1BoB,EAAepB,EAAOiB,EAAO,MAAM,EAGnCG,EAAe,mBAAmBH,EAAO,MAAM,MAAMA,EAAO,UAAU,GAKlE,IAAIE,EACRjB,EACAe,EACA,GAAGJ,EAAY,kBAAkBT,CAAG,EAAI,WAAa,QAAQ,WAAWgB,CAAY,EACtF,CACF","names":["errors","request","options","client","url","method","body","contentType","params","overrides","headers","VERSION","aptosRequest","aptosConfig","path","fullUrl","response","result","indexerResponse","AptosApiError","errorMessage"]}