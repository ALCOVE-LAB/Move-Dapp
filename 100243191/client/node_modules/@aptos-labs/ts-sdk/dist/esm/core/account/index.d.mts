import { AccountAuthenticatorSingleKey, AccountAuthenticator, AccountAuthenticatorEd25519 } from '../../transactions/authenticator/account.mjs';
import { SigningSchemeInput, HexInput, SigningScheme } from '../../types/index.mjs';
import { AccountAddressInput, AccountAddress } from '../accountAddress.mjs';
import { Ed25519PrivateKey, Ed25519Signature, Ed25519PublicKey } from '../crypto/ed25519.mjs';
import { a as AccountPublicKey, A as AuthenticationKey, V as VerifySignatureArgs } from '../../publicKey-B3XRNhHO.mjs';
import { Signature } from '../crypto/signature.mjs';
import { PrivateKey } from '../crypto/privateKey.mjs';
import { AnySignature, AnyPublicKey } from '../crypto/singleKey.mjs';
import '../../bcs/deserializer.mjs';
import '../../utils/apiEndpoints.mjs';
import '../../types/indexer.mjs';
import '../../types/generated/operations.mjs';
import '../../types/generated/types.mjs';
import '../../bcs/serializer.mjs';
import '../hex.mjs';
import '../common.mjs';
import '../crypto/multiEd25519.mjs';
import '../../transactions/instances/transactionArgument.mjs';
import '../crypto/multiKey.mjs';

interface SingleKeySignerConstructorArgs {
    privateKey: PrivateKey;
    address?: AccountAddressInput;
}
interface SingleKeySignerGenerateArgs {
    scheme?: SigningSchemeInput;
}
type SingleKeySignerFromDerivationPathArgs = SingleKeySignerGenerateArgs & {
    path: string;
    mnemonic: string;
};
interface VerifySingleKeySignatureArgs {
    message: HexInput;
    signature: AnySignature;
}
/**
 * Signer implementation for the SingleKey authentication scheme.
 * This extends a SingleKeyAccount by adding signing capabilities through a valid private key.
 * Currently, the only supported signature schemes are Ed25519 and Secp256k1.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class SingleKeyAccount implements Account {
    /**
     * Private key associated with the account
     */
    readonly privateKey: PrivateKey;
    readonly publicKey: AnyPublicKey;
    readonly accountAddress: AccountAddress;
    readonly signingScheme = SigningScheme.SingleKey;
    constructor(args: SingleKeySignerConstructorArgs);
    /**
     * Derives an account from a randomly generated private key.
     * Default generation is using an Ed25519 key
     * @returns Account with the given signature scheme
     */
    static generate(args?: SingleKeySignerGenerateArgs): SingleKeyAccount;
    /**
     * Derives an account with bip44 path and mnemonics,
     * Default to using an Ed25519 signature scheme.
     *
     * @param args.scheme The signature scheme to derive the private key with
     * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,
     * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: SingleKeySignerFromDerivationPathArgs): SingleKeyAccount;
    verifySignature(args: VerifySingleKeySignatureArgs): boolean;
    signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey;
    sign(message: HexInput): AnySignature;
}

/**
 * Arguments for creating an `Ed25519Account` from an `Ed25519PrivateKey`.
 * This is the default input type when passing an `Ed25519PrivateKey`.
 * In order to use the SingleKey authentication scheme, `legacy` needs to be explicitly set to false.
 */
interface CreateEd25519AccountFromPrivateKeyArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
    legacy?: true;
}
/**
 * Arguments for creating an `SingleKeyAccount` from an `Ed25519PrivateKey`.
 * The `legacy` argument needs to be explicitly set to false in order to
 * use the `SingleKey` authentication scheme.
 */
interface CreateEd25519SingleKeyAccountFromPrivateKeyArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
    legacy: false;
}
/**
 * Arguments for creating an `SingleKeyAccount` from any supported private key
 * that is not an `Ed25519PrivateKey`.
 * The `legacy` argument defaults to false and cannot be explicitly set to true.
 */
interface CreateSingleKeyAccountFromPrivateKeyArgs {
    privateKey: Exclude<PrivateKey, Ed25519PrivateKey>;
    address?: AccountAddressInput;
    legacy?: false;
}
/**
 * Arguments for creating an opaque `Account` from any supported private key.
 * This is used when the private key type is not known at compilation time.
 */
interface CreateAccountFromPrivateKeyArgs {
    privateKey: PrivateKey;
    address?: AccountAddressInput;
    legacy?: boolean;
}
/**
 * Arguments for generating an `Ed25519Account`.
 * This is the input type used by default.
 */
interface GenerateEd25519AccountArgs {
    scheme?: SigningSchemeInput.Ed25519;
    legacy?: true;
}
/**
 * Arguments for generating an `SingleKeyAccount` with ah underlying `Ed25519PrivateKey`.
 * The `legacy` argument needs to be explicitly set to false,
 * otherwise an `Ed25519Account` will be returned instead.
 */
interface GenerateEd25519SingleKeyAccountArgs {
    scheme?: SigningSchemeInput.Ed25519;
    legacy: false;
}
/**
 * Arguments for generating an `SingleKeyAccount` with any supported private key
 * that is not an `Ed25519PrivateKey`.
 * The `legacy` argument defaults to false and cannot be explicitly set to true.
 */
interface GenerateSingleKeyAccountArgs {
    scheme: Exclude<SigningSchemeInput, SigningSchemeInput.Ed25519>;
    legacy?: false;
}
/**
 * Arguments for generating an opaque `Account`.
 * This is used when the input signature scheme is not known at compilation time.
 */
interface GenerateAccountArgs {
    scheme?: SigningSchemeInput;
    legacy?: boolean;
}
/**
 * Arguments for deriving a private key from a mnemonic phrase and a BIP44 path.
 */
interface PrivateKeyFromDerivationPathArgs {
    path: string;
    mnemonic: string;
}
/**
 * Interface for a generic Aptos account.
 *
 * The interface is defined as abstract class to provide a single entrypoint for account generation,
 * either through `Account.generate()` or `Account.fromDerivationPath`.
 * Despite this being an abstract class, it should be treated as an interface and enforced using
 * the `implements` keyword.
 *
 * Note: Generating an account instance does not create the account on-chain.
 */
declare abstract class Account {
    /**
     * Private key associated with the account.
     * Note: this will be removed in the next major release,
     *  as not all accounts have a private key.
     */
    abstract readonly privateKey: PrivateKey;
    /**
     * Public key associated with the account
     */
    abstract readonly publicKey: AccountPublicKey;
    /**
     * Account address associated with the account
     */
    abstract readonly accountAddress: AccountAddress;
    /**
     * Signing scheme used to sign transactions
     */
    abstract signingScheme: SigningScheme;
    /**
     * Derives an account from a randomly generated private key.
     * @param args.scheme The signature scheme to use, to generate the private key
     * @param args.legacy Whether to use a legacy authentication scheme, when applicable
     * @returns An account compatible with the provided signature scheme
     */
    static generate(args?: GenerateEd25519AccountArgs): Ed25519Account;
    static generate(args: GenerateEd25519SingleKeyAccountArgs): SingleKeyAccount;
    static generate(args: GenerateSingleKeyAccountArgs): SingleKeyAccount;
    static generate(args: GenerateAccountArgs): Account;
    /**
     * Creates an account from the provided private key.
     *
     * @param args.privateKey a valid private key
     * @param args.address the account's address. If not provided, it will be derived from the public key.
     * @param args.legacy Whether to use a legacy authentication scheme, when applicable
     */
    static fromPrivateKey(args: CreateEd25519AccountFromPrivateKeyArgs): Ed25519Account;
    static fromPrivateKey(args: CreateEd25519SingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;
    static fromPrivateKey(args: CreateSingleKeyAccountFromPrivateKeyArgs): SingleKeyAccount;
    static fromPrivateKey(args: CreateAccountFromPrivateKeyArgs): Account;
    /**
     * @deprecated use `fromPrivateKey` instead.
     * Instantiates an account given a private key and a specified account address.
     * This is primarily used to instantiate an `Account` that has had its authentication key rotated.
     *
     * @param args.privateKey PrivateKey - the underlying private key for the account
     * @param args.address AccountAddress - The account address the `Account` will sign for
     * @param args.legacy optional. If set to false, the keypair generated is a Unified keypair. Defaults
     * to generating a Legacy Ed25519 keypair
     *
     * @returns Account
     */
    static fromPrivateKeyAndAddress(args: CreateAccountFromPrivateKeyArgs): Account;
    /**
     * Derives an account with bip44 path and mnemonics
     *
     * @param args.scheme The signature scheme to derive the private key with
     * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,
     * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: GenerateEd25519AccountArgs & PrivateKeyFromDerivationPathArgs): Ed25519Account;
    static fromDerivationPath(args: GenerateEd25519SingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;
    static fromDerivationPath(args: GenerateSingleKeyAccountArgs & PrivateKeyFromDerivationPathArgs): SingleKeyAccount;
    static fromDerivationPath(args: GenerateAccountArgs & PrivateKeyFromDerivationPathArgs): Account;
    /**
     * @deprecated use `publicKey.authKey()` instead.
     * This key enables account owners to rotate their private key(s)
     * associated with the account without changing the address that hosts their account.
     * See here for more info: {@link https://aptos.dev/concepts/accounts#single-signer-authentication}
     *
     * @param args.publicKey PublicKey - public key of the account
     * @returns The authentication key for the associated account
     */
    static authKey(args: {
        publicKey: AccountPublicKey;
    }): AuthenticationKey;
    /**
     * Sign a message using the available signing capabilities.
     * @param message the signing message, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    abstract signWithAuthenticator(message: HexInput): AccountAuthenticator;
    /**
     * Sign the given message with the private key.
     * @param message in HexInput format
     * @returns AccountSignature
     */
    abstract sign(message: HexInput): Signature;
    /**
     * @param args.message raw message data in HexInput format
     * @param args.signature signed message signature
     */
    verifySignature(args: VerifySignatureArgs): boolean;
}

interface Ed25519SignerConstructorArgs {
    privateKey: Ed25519PrivateKey;
    address?: AccountAddressInput;
}
interface Ed25519SignerFromDerivationPathArgs {
    path: string;
    mnemonic: string;
}
interface VerifyEd25519SignatureArgs {
    message: HexInput;
    signature: Ed25519Signature;
}
/**
 * Signer implementation for the Ed25519 authentication scheme.
 * This extends an {@link Ed25519Account} by adding signing capabilities through an {@link Ed25519PrivateKey}.
 *
 * Note: Generating a signer instance does not create the account on-chain.
 */
declare class Ed25519Account implements Account {
    /**
     * Private key associated with the account
     */
    readonly privateKey: Ed25519PrivateKey;
    readonly publicKey: Ed25519PublicKey;
    readonly accountAddress: AccountAddress;
    readonly signingScheme = SigningScheme.Ed25519;
    constructor(args: Ed25519SignerConstructorArgs);
    /**
     * Derives a signer from a randomly generated private key
     */
    static generate(): Ed25519Account;
    /**
     * Derives an account with bip44 path and mnemonics
     *
     * @param args.path the BIP44 derive hardened path e.g. m/44'/637'/0'/0'/0'
     * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
     * @param args.mnemonic the mnemonic seed phrase of the account
     */
    static fromDerivationPath(args: Ed25519SignerFromDerivationPathArgs): Ed25519Account;
    verifySignature(args: VerifyEd25519SignatureArgs): boolean;
    signWithAuthenticator(message: HexInput): AccountAuthenticatorEd25519;
    sign(message: HexInput): Ed25519Signature;
}

export { Account, type CreateAccountFromPrivateKeyArgs, type CreateEd25519AccountFromPrivateKeyArgs, type CreateEd25519SingleKeyAccountFromPrivateKeyArgs, type CreateSingleKeyAccountFromPrivateKeyArgs, Ed25519Account, type Ed25519SignerConstructorArgs, type Ed25519SignerFromDerivationPathArgs, type GenerateAccountArgs, type GenerateEd25519AccountArgs, type GenerateEd25519SingleKeyAccountArgs, type GenerateSingleKeyAccountArgs, type PrivateKeyFromDerivationPathArgs, SingleKeyAccount, type SingleKeySignerConstructorArgs, type SingleKeySignerFromDerivationPathArgs, type SingleKeySignerGenerateArgs, type VerifyEd25519SignatureArgs, type VerifySingleKeySignatureArgs };
