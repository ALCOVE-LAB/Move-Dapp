{"version":3,"sources":["../../src/core/account/SingleKeyAccount.ts"],"sourcesContent":["import { AccountAuthenticatorSingleKey } from \"../../transactions/authenticator/account\";\nimport { type HexInput, SigningScheme, SigningSchemeInput } from \"../../types\";\nimport { AccountAddress, AccountAddressInput } from \"../accountAddress\";\nimport { AnyPublicKey, AnySignature, Ed25519PrivateKey, PrivateKey, Secp256k1PrivateKey } from \"../crypto\";\nimport type { Account } from \"./Account\";\n\nexport interface SingleKeySignerConstructorArgs {\n  privateKey: PrivateKey;\n  address?: AccountAddressInput;\n}\n\nexport interface SingleKeySignerGenerateArgs {\n  scheme?: SigningSchemeInput;\n}\n\nexport type SingleKeySignerFromDerivationPathArgs = SingleKeySignerGenerateArgs & {\n  path: string;\n  mnemonic: string;\n};\n\nexport interface VerifySingleKeySignatureArgs {\n  message: HexInput;\n  signature: AnySignature;\n}\n\n/**\n * Signer implementation for the SingleKey authentication scheme.\n * This extends a SingleKeyAccount by adding signing capabilities through a valid private key.\n * Currently, the only supported signature schemes are Ed25519 and Secp256k1.\n *\n * Note: Generating a signer instance does not create the account on-chain.\n */\nexport class SingleKeyAccount implements Account {\n  /**\n   * Private key associated with the account\n   */\n  readonly privateKey: PrivateKey;\n\n  readonly publicKey: AnyPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  // region Constructors\n\n  constructor(args: SingleKeySignerConstructorArgs) {\n    const { privateKey, address } = args;\n    this.privateKey = privateKey;\n    this.publicKey = new AnyPublicKey(privateKey.publicKey());\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n  }\n\n  /**\n   * Derives an account from a randomly generated private key.\n   * Default generation is using an Ed25519 key\n   * @returns Account with the given signature scheme\n   */\n  static generate(args: SingleKeySignerGenerateArgs = {}) {\n    const { scheme = SigningSchemeInput.Ed25519 } = args;\n    let privateKey: PrivateKey;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.generate();\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.generate();\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  /**\n   * Derives an account with bip44 path and mnemonics,\n   * Default to using an Ed25519 signature scheme.\n   *\n   * @param args.scheme The signature scheme to derive the private key with\n   * @param args.path the BIP44 derive hardened path (e.g. m/44'/637'/0'/0'/0') for Ed25519,\n   * or non-hardened path (e.g. m/44'/637'/0'/0/0) for secp256k1\n   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}\n   * @param args.mnemonic the mnemonic seed phrase of the account\n   */\n  static fromDerivationPath(args: SingleKeySignerFromDerivationPathArgs) {\n    const { scheme = SigningSchemeInput.Ed25519, path, mnemonic } = args;\n    let privateKey: PrivateKey;\n    switch (scheme) {\n      case SigningSchemeInput.Ed25519:\n        privateKey = Ed25519PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      case SigningSchemeInput.Secp256k1Ecdsa:\n        privateKey = Secp256k1PrivateKey.fromDerivationPath(path, mnemonic);\n        break;\n      default:\n        throw new Error(`Unsupported signature scheme ${scheme}`);\n    }\n    return new SingleKeyAccount({ privateKey });\n  }\n\n  // endregion\n\n  // region Account\n\n  verifySignature(args: VerifySingleKeySignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  signWithAuthenticator(message: HexInput) {\n    const innerSignature = this.privateKey.sign(message);\n    const signature = new AnySignature(innerSignature);\n    return new AccountAuthenticatorSingleKey(this.publicKey, signature);\n  }\n\n  sign(message: HexInput) {\n    return this.signWithAuthenticator(message).signature;\n  }\n\n  // endregion\n}\n"],"mappings":"oNAgCO,IAAMA,EAAN,MAAMC,CAAoC,CAc/C,YAAYC,EAAsC,CAJlD,KAAS,cAAgB,EAKvB,GAAM,CAAE,WAAAC,EAAY,QAAAC,CAAQ,EAAIF,EAChC,KAAK,WAAaC,EAClB,KAAK,UAAY,IAAIE,EAAaF,EAAW,UAAU,CAAC,EACxD,KAAK,eAAiBC,EAAUE,EAAe,KAAKF,CAAO,EAAI,KAAK,UAAU,QAAQ,EAAE,eAAe,CACzG,CAOA,OAAO,SAASF,EAAoC,CAAC,EAAG,CACtD,GAAM,CAAE,OAAAK,GAAoC,EAAIL,EAC5CC,EACJ,OAAQI,EAAQ,CACd,OACEJ,EAAaK,EAAkB,SAAS,EACxC,MACF,OACEL,EAAaM,EAAoB,SAAS,EAC1C,MACF,QACE,MAAM,IAAI,MAAM,gCAAgCF,CAAM,EAAE,CAC5D,CACA,OAAO,IAAIN,EAAiB,CAAE,WAAAE,CAAW,CAAC,CAC5C,CAYA,OAAO,mBAAmBD,EAA6C,CACrE,GAAM,CAAE,OAAAK,IAAqC,KAAAG,EAAM,SAAAC,CAAS,EAAIT,EAC5DC,EACJ,OAAQI,EAAQ,CACd,OACEJ,EAAaK,EAAkB,mBAAmBE,EAAMC,CAAQ,EAChE,MACF,OACER,EAAaM,EAAoB,mBAAmBC,EAAMC,CAAQ,EAClE,MACF,QACE,MAAM,IAAI,MAAM,gCAAgCJ,CAAM,EAAE,CAC5D,CACA,OAAO,IAAIN,EAAiB,CAAE,WAAAE,CAAW,CAAC,CAC5C,CAMA,gBAAgBD,EAA6C,CAC3D,OAAO,KAAK,UAAU,gBAAgBA,CAAI,CAC5C,CAEA,sBAAsBU,EAAmB,CACvC,IAAMC,EAAiB,KAAK,WAAW,KAAKD,CAAO,EAC7CE,EAAY,IAAIC,EAAaF,CAAc,EACjD,OAAO,IAAIG,EAA8B,KAAK,UAAWF,CAAS,CACpE,CAEA,KAAKF,EAAmB,CACtB,OAAO,KAAK,sBAAsBA,CAAO,EAAE,SAC7C,CAGF","names":["SingleKeyAccount","_SingleKeyAccount","args","privateKey","address","AnyPublicKey","AccountAddress","scheme","Ed25519PrivateKey","Secp256k1PrivateKey","path","mnemonic","message","innerSignature","signature","AnySignature","AccountAuthenticatorSingleKey"]}