{"version":3,"sources":["../../src/core/crypto/multiKey.ts"],"sourcesContent":["import { SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { AnyPublicKey, AnySignature } from \"./singleKey\";\n\n/* eslint-disable no-bitwise */\n\nfunction bitCount(byte: number) {\n  let n = byte;\n  n -= (n >> 1) & 0x55555555;\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n\n/* eslint-enable no-bitwise */\n\n/**\n * Represents the public key of a multi-agent account.\n *\n * The public keys of each individual agent can be any type of public key supported by Aptos.\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263) Aptos supports\n * `Legacy` and `Unified` authentication keys.\n */\nexport class MultiKey extends AccountPublicKey {\n  /**\n   * List of any public keys\n   */\n  public readonly publicKeys: AnyPublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   */\n  public readonly signaturesRequired: number;\n\n  // region Constructors\n\n  constructor(args: { publicKeys: Array<PublicKey>; signaturesRequired: number }) {\n    super();\n    const { publicKeys, signaturesRequired } = args;\n\n    // Validate number of public keys is greater than signature required\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater than 0\");\n    }\n\n    // Validate number of public keys is greater than signature required\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(\n        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`,\n      );\n    }\n\n    // Make sure that all keys are normalized to the SingleKey authentication scheme\n    this.publicKeys = publicKeys.map((publicKey) =>\n      publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey),\n    );\n\n    this.signaturesRequired = signaturesRequired;\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: VerifySignatureArgs): boolean {\n    throw new Error(\"not implemented\");\n  }\n\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKey {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n\n    return new MultiKey({ publicKeys: keys, signaturesRequired });\n  }\n\n  // endregion\n\n  /**\n   * Create a bitmap that holds the mapping from the original public keys\n   * to the signatures passed in\n   *\n   * @param args.bits array of the index mapping to the matching public keys\n   * @returns Uint8array bit map\n   */\n  createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, idx: number) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n}\n\nexport class MultiKeySignature extends Signature {\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * Maximum number of Ed25519 signatures supported\n   */\n  static MAX_SIGNATURES_SUPPORTED = MultiKeySignature.BITMAP_LEN * 8;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   */\n  public readonly signatures: AnySignature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   */\n  constructor(args: { signatures: Array<Signature | AnySignature>; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n\n    // Make sure that all signatures are normalized to the SingleKey authentication scheme\n    this.signatures = signatures.map((signature) =>\n      signature instanceof AnySignature ? signature : new AnySignature(signature),\n    );\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiKeySignature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiKeySignature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiKeySignature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n\n    const nSignatures = this.bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);\n    if (nSignatures !== this.signatures.length) {\n      throw new Error(`Expecting ${nSignatures} signatures from the bitmap, but got ${this.signatures.length}`);\n    }\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  // region Signature\n\n  toUint8Array(): Uint8Array {\n    return this.bcsToBytes();\n  }\n\n  // endregion\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    // Note: we should not need to serialize the vector length, as it can be derived from the bitmap\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.bitmap);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKeySignature {\n    const bitmap = deserializer.deserializeBytes();\n    const nSignatures = bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);\n    const signatures: AnySignature[] = [];\n    for (let i = 0; i < nSignatures; i += 1) {\n      const signature = AnySignature.deserialize(deserializer);\n      signatures.push(signature);\n    }\n    return new MultiKeySignature({ signatures, bitmap });\n  }\n\n  // endregion\n}\n"],"mappings":"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","names":["bitCount","byte","n","MultiKey","_MultiKey","AccountPublicKey","args","publicKeys","signaturesRequired","publicKey","AnyPublicKey","AuthenticationKey","serializer","deserializer","keys","bits","firstBitInByte","bitmap","dupCheckSet","bit","idx","byteOffset","_MultiKeySignature","Signature","signatures","signature","AnySignature","nSignatures","acc","i","MultiKeySignature"]}