{"version":3,"sources":["../../src/transactions/transactionBuilder/remoteAbi.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport { TypeTag, TypeTagStruct } from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { EntryFunctionArgumentTypes, SimpleEntryFunctionArgumentTypes, EntryFunctionABI } from \"../types\";\nimport { Bool, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isNull,\n  isNumber,\n  isString,\n  throwTypeMismatch,\n} from \"./helpers\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeTag | string>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: string | TypeTag): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI for an entry function from the module\n *\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  // This fetch from the API is currently cached\n  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n\n  const functionAbi = module.abi?.exposed_functions.find((func) => func.name === functionName);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const first = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = first; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary\n * @param functionName\n * @param functionAbi\n * @param arg\n * @param position\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbi: EntryFunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // Ensure not too many arguments\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n\n  const param = functionAbi.parameters[position];\n  return checkOrConvertArgument(arg, param, position, genericTypeParams);\n}\n\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively\n * @param arg\n * @param param\n * @param position\n * @param genericTypeParams\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isNumber(arg)) {\n      return new U8(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU16()) {\n    if (isNumber(arg)) {\n      return new U16(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU32()) {\n    if (isNumber(arg)) {\n      return new U32(arg);\n    }\n    throwTypeMismatch(\"number\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the sub-type\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 uint8array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams)));\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n\n    if (param.isOption()) {\n      // Empty option must be handled specially\n      if (isNull(arg)) {\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<U8>(null);\n      }\n\n      return new MoveOption(checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams));\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of an already BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n"],"mappings":"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","names":["TEXT_ENCODER","standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchEntryFunctionAbi","moduleAddress","moduleName","functionName","aptosConfig","functionAbi","getModule","func","first","findFirstNonSignerArg","params","i","convertArgument","arg","position","genericTypeParams","param","checkOrConvertArgument","isEncodedEntryFunctionArgument","checkType","parseArg","isBool","Bool","throwTypeMismatch","AccountAddress","isNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","MoveVector","item","MoveString","isNull","MoveOption","isBcsBool","isBcsAddress","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","TypeTagStruct","isBcsString"]}