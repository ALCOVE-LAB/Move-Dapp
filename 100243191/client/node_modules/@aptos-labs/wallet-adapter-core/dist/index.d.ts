import { Types } from 'aptos';
export { TxnBuilderTypes, Types } from 'aptos';
import { Network, InputGenerateTransactionData, InputGenerateTransactionOptions, PendingTransactionResponse, InputSubmitTransactionData, AccountAddressInput, InputGenerateTransactionPayloadData, AnyRawTransaction, AccountAuthenticator, EntryFunctionArgumentTypes, SimpleEntryFunctionArgumentTypes } from '@aptos-labs/ts-sdk';
export { AccountAuthenticator, AnyRawTransaction, InputGenerateTransactionData, InputGenerateTransactionOptions, InputSubmitTransactionData, PendingTransactionResponse } from '@aptos-labs/ts-sdk';
import EventEmitter from 'eventemitter3';

declare enum WalletReadyState {
    /**
     * User-installable wallets can typically be detected by scanning for an API
     * that they've injected into the global context. If such an API is present,
     * we consider the wallet to have been installed.
     */
    Installed = "Installed",
    NotDetected = "NotDetected",
    /**
     * Loadable wallets are always available to you. Since you can load them at
     * any time, it's meaningless to say that they have been detected.
     */
    Loadable = "Loadable",
    /**
     * If a wallet is not supported on a given platform (eg. server-rendering, or
     * mobile) then it will stay in the `Unsupported` state.
     */
    Unsupported = "Unsupported"
}
declare enum NetworkName {
    Mainnet = "mainnet",
    Testnet = "testnet",
    Devnet = "devnet"
}

type WalletName<T extends string = string> = T & {
    __brand__: "WalletName";
};
type NetworkInfo = {
    name: Network;
    chainId?: string;
    url?: string;
};
type WalletInfo = {
    name: WalletName;
    icon: string;
    url: string;
};
type AccountInfo = {
    address: string;
    publicKey: string | string[];
    minKeysRequired?: number;
    ansName?: string | null;
};
interface AptosWalletErrorResult {
    code: number;
    name: string;
    message: string;
}
declare interface WalletCoreEvents {
    connect(account: AccountInfo | null): void;
    disconnect(): void;
    readyStateChange(wallet: Wallet): void;
    networkChange(network: NetworkInfo | null): void;
    accountChange(account: AccountInfo | null): void;
}
interface SignMessagePayload {
    address?: boolean;
    application?: boolean;
    chainId?: boolean;
    message: string;
    nonce: string;
}
interface SignMessageResponse {
    address?: string;
    application?: string;
    chainId?: number;
    fullMessage: string;
    message: string;
    nonce: string;
    prefix: "APTOS";
    signature: string | string[];
    bitmap?: Uint8Array;
}
type OnNetworkChange = (callBack: (networkInfo: NetworkInfo) => Promise<void>) => Promise<void>;
type OnAccountChange = (callBack: (accountInfo: AccountInfo) => Promise<any>) => Promise<void>;
interface AdapterPluginEvents {
    onNetworkChange: OnNetworkChange;
    onAccountChange: OnAccountChange;
}
interface AdapterPluginProps<Name extends string = string> {
    name: WalletName<Name>;
    url: string;
    icon: `data:image/${"svg+xml" | "webp" | "png" | "gif"};base64,${string}`;
    version?: "v1" | "v2";
    providerName?: string;
    provider: any;
    deeplinkProvider?: (data: {
        url: string;
    }) => string;
    connect(): Promise<any>;
    disconnect: () => Promise<any>;
    network: () => Promise<any>;
    signAndSubmitTransaction(transaction: Types.TransactionPayload | InputGenerateTransactionData, options?: InputGenerateTransactionOptions): Promise<{
        hash: Types.HexEncodedBytes;
        output?: any;
    } | PendingTransactionResponse>;
    submitTransaction?(transaction: InputSubmitTransactionData): Promise<PendingTransactionResponse>;
    signMessage<T extends SignMessagePayload>(message: T): Promise<SignMessageResponse>;
}
type AdapterPlugin<Name extends string = string> = AdapterPluginProps<Name> & AdapterPluginEvents;
type Wallet<Name extends string = string> = AdapterPlugin<Name> & {
    readyState?: WalletReadyState;
};
interface TransactionOptions {
    max_gas_amount?: bigint;
    gas_unit_price?: bigint;
}
type InputTransactionData = {
    sender?: AccountAddressInput;
    data: InputGenerateTransactionPayloadData;
    options?: InputGenerateTransactionOptions;
};
interface PluginProvider {
    connect: () => Promise<AccountInfo>;
    account: () => Promise<AccountInfo>;
    disconnect: () => Promise<void>;
    signAndSubmitTransaction: (transaction: any, options?: any) => Promise<{
        hash: Types.HexEncodedBytes;
    } | AptosWalletErrorResult>;
    signMessage: (message: SignMessagePayload) => Promise<SignMessageResponse>;
    network: () => Promise<NetworkInfo>;
    onAccountChange: (listener: (newAddress: AccountInfo) => Promise<void>) => Promise<void>;
    onNetworkChange: OnNetworkChange;
}

declare class WalletCore extends EventEmitter<WalletCoreEvents> {
    private _wallets;
    private _wallet;
    private _account;
    private _network;
    private readonly waletCoreV1;
    private _connecting;
    private _connected;
    constructor(plugins: ReadonlyArray<Wallet>);
    private scopePollingDetectionStrategy;
    private doesWalletExist;
    private clearData;
    private setAnsName;
    setWallet(wallet: Wallet | null): void;
    setAccount(account: AccountInfo | null): void;
    setNetwork(network: NetworkInfo | null): void;
    isConnected(): boolean;
    get wallets(): ReadonlyArray<Wallet>;
    /**
     * Getter for the current connected wallet
     * @return wallet info
     * @throws WalletNotSelectedError
     */
    get wallet(): WalletInfo | null;
    /**
     * Getter for the current connected account
     * @return account info
     * @throws WalletAccountError
     */
    get account(): AccountInfo | null;
    /**
     * Getter for the current wallet network
     * @return network info
     * @throws WalletGetNetworkError
     */
    get network(): NetworkInfo | null;
    /**
     * We first make sure we can connect a dapp to a wallet.
     * If all good, we connect the wallet by calling `this.connectWallet`
     * @param walletName. The wallet name we want to connect.
     */
    connect(walletName: string): Promise<void | string>;
    /**
     * Connects a wallet to the dapp.
     * On connect success, we set the current account and the network, and keeping the selected wallet
     * name in LocalStorage to support autoConnect function.
     *
     * @param selectedWallet. The wallet we want to connect.
     * @emit emits "connect" event
     * @throws WalletConnectionError
     */
    connectWallet(selectedWallet: Wallet): Promise<void>;
    /**
    Disconnect the exisitng wallet. On success, we clear the
    current account, current network and LocalStorage data.
    @emit emits "disconnect" event
    @throws WalletDisconnectionError
    */
    disconnect(): Promise<void>;
    /**
     * Signs and submits a transaction to chain
     *
     * @param transactionInput InputTransactionData
     * @param options optional. A configuration object to generate a transaction by
     * @returns The pending transaction hash (V1 output) | PendingTransactionResponse (V2 output)
     */
    signAndSubmitTransaction(transactionInput: InputTransactionData): Promise<{
        hash: Types.HexEncodedBytes;
        output?: any;
    } | PendingTransactionResponse>;
    /**
     * Signs a transaction
     *
     * To support both existing wallet adapter V1 and V2, we support 2 input types
     *
     * @param transactionOrPayload AnyRawTransaction - V2 input | Types.TransactionPayload - V1 input
     * @param options optional. V1 input
     *
     * @returns AccountAuthenticator
     */
    signTransaction(transactionOrPayload: AnyRawTransaction | Types.TransactionPayload, asFeePayer?: boolean, options?: InputGenerateTransactionOptions): Promise<AccountAuthenticator>;
    /**
     Sign message (doesnt submit to chain).
     @param message
     @return response from the wallet's signMessage function
     @throws WalletSignMessageError
     */
    signMessage(message: SignMessagePayload): Promise<SignMessageResponse>;
    submitTransaction(transaction: InputSubmitTransactionData): Promise<PendingTransactionResponse>;
    /**
    Event for when account has changed on the wallet
    @return the new account info
    @throws WalletAccountChangeError
    */
    onAccountChange(): Promise<void>;
    /**
    Event for when network has changed on the wallet
    @return the new network info
    @throws WalletNetworkChangeError
    */
    onNetworkChange(): Promise<void>;
    /**
     * Signs a message and verifies the signer
     * @param message SignMessagePayload
     * @returns boolean
     */
    signMessageAndVerify(message: SignMessagePayload): Promise<boolean>;
}

declare function scopePollingDetectionStrategy(detect: () => boolean): void;

declare function setLocalStorage(walletName: WalletName): void;
declare function removeLocalStorage(): void;
declare function getLocalStorage(): void;

declare function isMobile(): boolean;
declare function isInAppBrowser(): boolean;
declare function isRedirectable(): boolean;
declare function generalizedErrorMessage(error: any): string;
declare const areBCSArguments: (args: Array<EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes>) => boolean;

export { AccountInfo, AdapterPlugin, AdapterPluginEvents, AdapterPluginProps, AptosWalletErrorResult, InputTransactionData, NetworkInfo, NetworkName, OnAccountChange, OnNetworkChange, PluginProvider, SignMessagePayload, SignMessageResponse, TransactionOptions, Wallet, WalletCore, WalletCoreEvents, WalletInfo, WalletName, WalletReadyState, areBCSArguments, generalizedErrorMessage, getLocalStorage, isInAppBrowser, isMobile, isRedirectable, removeLocalStorage, scopePollingDetectionStrategy, setLocalStorage };
