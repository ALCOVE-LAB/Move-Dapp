import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-OZI5HTJH.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_6, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// E:/Proj/HXProjs/lucky-pocket/node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "E:/Proj/HXProjs/lucky-pocket/node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl) {
      "use strict";
      var gf = function(init) {
        var i34, r16 = new Float64Array(16);
        if (init)
          for (i34 = 0; i34 < init.length; i34++)
            r16[i34] = init[i34];
        return r16;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D7 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X4 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y3 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I5 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x9, i34, h14, l12) {
        x9[i34] = h14 >> 24 & 255;
        x9[i34 + 1] = h14 >> 16 & 255;
        x9[i34 + 2] = h14 >> 8 & 255;
        x9[i34 + 3] = h14 & 255;
        x9[i34 + 4] = l12 >> 24 & 255;
        x9[i34 + 5] = l12 >> 16 & 255;
        x9[i34 + 6] = l12 >> 8 & 255;
        x9[i34 + 7] = l12 & 255;
      }
      function vn(x9, xi, y12, yi, n24) {
        var i34, d10 = 0;
        for (i34 = 0; i34 < n24; i34++)
          d10 |= x9[xi + i34] ^ y12[yi + i34];
        return (1 & d10 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x9, xi, y12, yi) {
        return vn(x9, xi, y12, yi, 16);
      }
      function crypto_verify_32(x9, xi, y12, yi) {
        return vn(x9, xi, y12, yi, 32);
      }
      function core_salsa20(o19, p11, k3, c10) {
        var j0 = c10[0] & 255 | (c10[1] & 255) << 8 | (c10[2] & 255) << 16 | (c10[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j32 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c10[4] & 255 | (c10[5] & 255) << 8 | (c10[6] & 255) << 16 | (c10[7] & 255) << 24, j6 = p11[0] & 255 | (p11[1] & 255) << 8 | (p11[2] & 255) << 16 | (p11[3] & 255) << 24, j7 = p11[4] & 255 | (p11[5] & 255) << 8 | (p11[6] & 255) << 16 | (p11[7] & 255) << 24, j8 = p11[8] & 255 | (p11[9] & 255) << 8 | (p11[10] & 255) << 16 | (p11[11] & 255) << 24, j9 = p11[12] & 255 | (p11[13] & 255) << 8 | (p11[14] & 255) << 16 | (p11[15] & 255) << 24, j10 = c10[8] & 255 | (c10[9] & 255) << 8 | (c10[10] & 255) << 16 | (c10[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c10[12] & 255 | (c10[13] & 255) << 8 | (c10[14] & 255) << 16 | (c10[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j32, x42 = j4, x52 = j5, x62 = j6, x72 = j7, x82 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u11;
        for (var i34 = 0; i34 < 20; i34 += 2) {
          u11 = x0 + x12 | 0;
          x42 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x42 + x0 | 0;
          x82 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x82 + x42 | 0;
          x12 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x12 + x82 | 0;
          x0 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x52 + x1 | 0;
          x9 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x9 + x52 | 0;
          x13 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x13 + x9 | 0;
          x1 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x1 + x13 | 0;
          x52 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x10 + x62 | 0;
          x14 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x14 + x10 | 0;
          x22 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x22 + x14 | 0;
          x62 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x62 + x22 | 0;
          x10 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x15 + x11 | 0;
          x32 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x32 + x15 | 0;
          x72 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x72 + x32 | 0;
          x11 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x11 + x72 | 0;
          x15 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x0 + x32 | 0;
          x1 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x1 + x0 | 0;
          x22 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x22 + x1 | 0;
          x32 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x32 + x22 | 0;
          x0 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x52 + x42 | 0;
          x62 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x62 + x52 | 0;
          x72 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x72 + x62 | 0;
          x42 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x42 + x72 | 0;
          x52 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x10 + x9 | 0;
          x11 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x11 + x10 | 0;
          x82 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x82 + x11 | 0;
          x9 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x9 + x82 | 0;
          x10 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x15 + x14 | 0;
          x12 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x12 + x15 | 0;
          x13 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x13 + x12 | 0;
          x14 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x14 + x13 | 0;
          x15 ^= u11 << 18 | u11 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x22 = x22 + j22 | 0;
        x32 = x32 + j32 | 0;
        x42 = x42 + j4 | 0;
        x52 = x52 + j5 | 0;
        x62 = x62 + j6 | 0;
        x72 = x72 + j7 | 0;
        x82 = x82 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o19[0] = x0 >>> 0 & 255;
        o19[1] = x0 >>> 8 & 255;
        o19[2] = x0 >>> 16 & 255;
        o19[3] = x0 >>> 24 & 255;
        o19[4] = x1 >>> 0 & 255;
        o19[5] = x1 >>> 8 & 255;
        o19[6] = x1 >>> 16 & 255;
        o19[7] = x1 >>> 24 & 255;
        o19[8] = x22 >>> 0 & 255;
        o19[9] = x22 >>> 8 & 255;
        o19[10] = x22 >>> 16 & 255;
        o19[11] = x22 >>> 24 & 255;
        o19[12] = x32 >>> 0 & 255;
        o19[13] = x32 >>> 8 & 255;
        o19[14] = x32 >>> 16 & 255;
        o19[15] = x32 >>> 24 & 255;
        o19[16] = x42 >>> 0 & 255;
        o19[17] = x42 >>> 8 & 255;
        o19[18] = x42 >>> 16 & 255;
        o19[19] = x42 >>> 24 & 255;
        o19[20] = x52 >>> 0 & 255;
        o19[21] = x52 >>> 8 & 255;
        o19[22] = x52 >>> 16 & 255;
        o19[23] = x52 >>> 24 & 255;
        o19[24] = x62 >>> 0 & 255;
        o19[25] = x62 >>> 8 & 255;
        o19[26] = x62 >>> 16 & 255;
        o19[27] = x62 >>> 24 & 255;
        o19[28] = x72 >>> 0 & 255;
        o19[29] = x72 >>> 8 & 255;
        o19[30] = x72 >>> 16 & 255;
        o19[31] = x72 >>> 24 & 255;
        o19[32] = x82 >>> 0 & 255;
        o19[33] = x82 >>> 8 & 255;
        o19[34] = x82 >>> 16 & 255;
        o19[35] = x82 >>> 24 & 255;
        o19[36] = x9 >>> 0 & 255;
        o19[37] = x9 >>> 8 & 255;
        o19[38] = x9 >>> 16 & 255;
        o19[39] = x9 >>> 24 & 255;
        o19[40] = x10 >>> 0 & 255;
        o19[41] = x10 >>> 8 & 255;
        o19[42] = x10 >>> 16 & 255;
        o19[43] = x10 >>> 24 & 255;
        o19[44] = x11 >>> 0 & 255;
        o19[45] = x11 >>> 8 & 255;
        o19[46] = x11 >>> 16 & 255;
        o19[47] = x11 >>> 24 & 255;
        o19[48] = x12 >>> 0 & 255;
        o19[49] = x12 >>> 8 & 255;
        o19[50] = x12 >>> 16 & 255;
        o19[51] = x12 >>> 24 & 255;
        o19[52] = x13 >>> 0 & 255;
        o19[53] = x13 >>> 8 & 255;
        o19[54] = x13 >>> 16 & 255;
        o19[55] = x13 >>> 24 & 255;
        o19[56] = x14 >>> 0 & 255;
        o19[57] = x14 >>> 8 & 255;
        o19[58] = x14 >>> 16 & 255;
        o19[59] = x14 >>> 24 & 255;
        o19[60] = x15 >>> 0 & 255;
        o19[61] = x15 >>> 8 & 255;
        o19[62] = x15 >>> 16 & 255;
        o19[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o19, p11, k3, c10) {
        var j0 = c10[0] & 255 | (c10[1] & 255) << 8 | (c10[2] & 255) << 16 | (c10[3] & 255) << 24, j1 = k3[0] & 255 | (k3[1] & 255) << 8 | (k3[2] & 255) << 16 | (k3[3] & 255) << 24, j22 = k3[4] & 255 | (k3[5] & 255) << 8 | (k3[6] & 255) << 16 | (k3[7] & 255) << 24, j32 = k3[8] & 255 | (k3[9] & 255) << 8 | (k3[10] & 255) << 16 | (k3[11] & 255) << 24, j4 = k3[12] & 255 | (k3[13] & 255) << 8 | (k3[14] & 255) << 16 | (k3[15] & 255) << 24, j5 = c10[4] & 255 | (c10[5] & 255) << 8 | (c10[6] & 255) << 16 | (c10[7] & 255) << 24, j6 = p11[0] & 255 | (p11[1] & 255) << 8 | (p11[2] & 255) << 16 | (p11[3] & 255) << 24, j7 = p11[4] & 255 | (p11[5] & 255) << 8 | (p11[6] & 255) << 16 | (p11[7] & 255) << 24, j8 = p11[8] & 255 | (p11[9] & 255) << 8 | (p11[10] & 255) << 16 | (p11[11] & 255) << 24, j9 = p11[12] & 255 | (p11[13] & 255) << 8 | (p11[14] & 255) << 16 | (p11[15] & 255) << 24, j10 = c10[8] & 255 | (c10[9] & 255) << 8 | (c10[10] & 255) << 16 | (c10[11] & 255) << 24, j11 = k3[16] & 255 | (k3[17] & 255) << 8 | (k3[18] & 255) << 16 | (k3[19] & 255) << 24, j12 = k3[20] & 255 | (k3[21] & 255) << 8 | (k3[22] & 255) << 16 | (k3[23] & 255) << 24, j13 = k3[24] & 255 | (k3[25] & 255) << 8 | (k3[26] & 255) << 16 | (k3[27] & 255) << 24, j14 = k3[28] & 255 | (k3[29] & 255) << 8 | (k3[30] & 255) << 16 | (k3[31] & 255) << 24, j15 = c10[12] & 255 | (c10[13] & 255) << 8 | (c10[14] & 255) << 16 | (c10[15] & 255) << 24;
        var x0 = j0, x1 = j1, x22 = j22, x32 = j32, x42 = j4, x52 = j5, x62 = j6, x72 = j7, x82 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u11;
        for (var i34 = 0; i34 < 20; i34 += 2) {
          u11 = x0 + x12 | 0;
          x42 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x42 + x0 | 0;
          x82 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x82 + x42 | 0;
          x12 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x12 + x82 | 0;
          x0 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x52 + x1 | 0;
          x9 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x9 + x52 | 0;
          x13 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x13 + x9 | 0;
          x1 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x1 + x13 | 0;
          x52 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x10 + x62 | 0;
          x14 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x14 + x10 | 0;
          x22 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x22 + x14 | 0;
          x62 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x62 + x22 | 0;
          x10 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x15 + x11 | 0;
          x32 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x32 + x15 | 0;
          x72 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x72 + x32 | 0;
          x11 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x11 + x72 | 0;
          x15 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x0 + x32 | 0;
          x1 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x1 + x0 | 0;
          x22 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x22 + x1 | 0;
          x32 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x32 + x22 | 0;
          x0 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x52 + x42 | 0;
          x62 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x62 + x52 | 0;
          x72 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x72 + x62 | 0;
          x42 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x42 + x72 | 0;
          x52 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x10 + x9 | 0;
          x11 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x11 + x10 | 0;
          x82 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x82 + x11 | 0;
          x9 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x9 + x82 | 0;
          x10 ^= u11 << 18 | u11 >>> 32 - 18;
          u11 = x15 + x14 | 0;
          x12 ^= u11 << 7 | u11 >>> 32 - 7;
          u11 = x12 + x15 | 0;
          x13 ^= u11 << 9 | u11 >>> 32 - 9;
          u11 = x13 + x12 | 0;
          x14 ^= u11 << 13 | u11 >>> 32 - 13;
          u11 = x14 + x13 | 0;
          x15 ^= u11 << 18 | u11 >>> 32 - 18;
        }
        o19[0] = x0 >>> 0 & 255;
        o19[1] = x0 >>> 8 & 255;
        o19[2] = x0 >>> 16 & 255;
        o19[3] = x0 >>> 24 & 255;
        o19[4] = x52 >>> 0 & 255;
        o19[5] = x52 >>> 8 & 255;
        o19[6] = x52 >>> 16 & 255;
        o19[7] = x52 >>> 24 & 255;
        o19[8] = x10 >>> 0 & 255;
        o19[9] = x10 >>> 8 & 255;
        o19[10] = x10 >>> 16 & 255;
        o19[11] = x10 >>> 24 & 255;
        o19[12] = x15 >>> 0 & 255;
        o19[13] = x15 >>> 8 & 255;
        o19[14] = x15 >>> 16 & 255;
        o19[15] = x15 >>> 24 & 255;
        o19[16] = x62 >>> 0 & 255;
        o19[17] = x62 >>> 8 & 255;
        o19[18] = x62 >>> 16 & 255;
        o19[19] = x62 >>> 24 & 255;
        o19[20] = x72 >>> 0 & 255;
        o19[21] = x72 >>> 8 & 255;
        o19[22] = x72 >>> 16 & 255;
        o19[23] = x72 >>> 24 & 255;
        o19[24] = x82 >>> 0 & 255;
        o19[25] = x82 >>> 8 & 255;
        o19[26] = x82 >>> 16 & 255;
        o19[27] = x82 >>> 24 & 255;
        o19[28] = x9 >>> 0 & 255;
        o19[29] = x9 >>> 8 & 255;
        o19[30] = x9 >>> 16 & 255;
        o19[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k3, c10) {
        core_salsa20(out, inp, k3, c10);
      }
      function crypto_core_hsalsa20(out, inp, k3, c10) {
        core_hsalsa20(out, inp, k3, c10);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c10, cpos, m13, mpos, b10, n24, k3) {
        var z5 = new Uint8Array(16), x9 = new Uint8Array(64);
        var u11, i34;
        for (i34 = 0; i34 < 16; i34++)
          z5[i34] = 0;
        for (i34 = 0; i34 < 8; i34++)
          z5[i34] = n24[i34];
        while (b10 >= 64) {
          crypto_core_salsa20(x9, z5, k3, sigma);
          for (i34 = 0; i34 < 64; i34++)
            c10[cpos + i34] = m13[mpos + i34] ^ x9[i34];
          u11 = 1;
          for (i34 = 8; i34 < 16; i34++) {
            u11 = u11 + (z5[i34] & 255) | 0;
            z5[i34] = u11 & 255;
            u11 >>>= 8;
          }
          b10 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b10 > 0) {
          crypto_core_salsa20(x9, z5, k3, sigma);
          for (i34 = 0; i34 < b10; i34++)
            c10[cpos + i34] = m13[mpos + i34] ^ x9[i34];
        }
        return 0;
      }
      function crypto_stream_salsa20(c10, cpos, b10, n24, k3) {
        var z5 = new Uint8Array(16), x9 = new Uint8Array(64);
        var u11, i34;
        for (i34 = 0; i34 < 16; i34++)
          z5[i34] = 0;
        for (i34 = 0; i34 < 8; i34++)
          z5[i34] = n24[i34];
        while (b10 >= 64) {
          crypto_core_salsa20(x9, z5, k3, sigma);
          for (i34 = 0; i34 < 64; i34++)
            c10[cpos + i34] = x9[i34];
          u11 = 1;
          for (i34 = 8; i34 < 16; i34++) {
            u11 = u11 + (z5[i34] & 255) | 0;
            z5[i34] = u11 & 255;
            u11 >>>= 8;
          }
          b10 -= 64;
          cpos += 64;
        }
        if (b10 > 0) {
          crypto_core_salsa20(x9, z5, k3, sigma);
          for (i34 = 0; i34 < b10; i34++)
            c10[cpos + i34] = x9[i34];
        }
        return 0;
      }
      function crypto_stream(c10, cpos, d10, n24, k3) {
        var s17 = new Uint8Array(32);
        crypto_core_hsalsa20(s17, n24, k3, sigma);
        var sn2 = new Uint8Array(8);
        for (var i34 = 0; i34 < 8; i34++)
          sn2[i34] = n24[i34 + 16];
        return crypto_stream_salsa20(c10, cpos, d10, sn2, s17);
      }
      function crypto_stream_xor(c10, cpos, m13, mpos, d10, n24, k3) {
        var s17 = new Uint8Array(32);
        crypto_core_hsalsa20(s17, n24, k3, sigma);
        var sn2 = new Uint8Array(8);
        for (var i34 = 0; i34 < 8; i34++)
          sn2[i34] = n24[i34 + 16];
        return crypto_stream_salsa20_xor(c10, cpos, m13, mpos, d10, sn2, s17);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t25, t32, t42, t52, t62, t72;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t25 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t25 << 6) & 7939;
        t32 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t25 >>> 7 | t32 << 9) & 8191;
        t42 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t32 >>> 4 | t42 << 12) & 255;
        this.r[5] = t42 >>> 1 & 8190;
        t52 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t42 >>> 14 | t52 << 2) & 8191;
        t62 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t52 >>> 11 | t62 << 5) & 8065;
        t72 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t62 >>> 8 | t72 << 8) & 8191;
        this.r[9] = t72 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m13, mpos, bytes3) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t25, t32, t42, t52, t62, t72, c10;
        var d0, d1, d22, d32, d42, d52, d62, d72, d82, d92;
        var h0 = this.h[0], h1 = this.h[1], h22 = this.h[2], h32 = this.h[3], h42 = this.h[4], h52 = this.h[5], h62 = this.h[6], h72 = this.h[7], h82 = this.h[8], h92 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r32 = this.r[3], r42 = this.r[4], r52 = this.r[5], r62 = this.r[6], r72 = this.r[7], r82 = this.r[8], r92 = this.r[9];
        while (bytes3 >= 16) {
          t0 = m13[mpos + 0] & 255 | (m13[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m13[mpos + 2] & 255 | (m13[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t25 = m13[mpos + 4] & 255 | (m13[mpos + 5] & 255) << 8;
          h22 += (t1 >>> 10 | t25 << 6) & 8191;
          t32 = m13[mpos + 6] & 255 | (m13[mpos + 7] & 255) << 8;
          h32 += (t25 >>> 7 | t32 << 9) & 8191;
          t42 = m13[mpos + 8] & 255 | (m13[mpos + 9] & 255) << 8;
          h42 += (t32 >>> 4 | t42 << 12) & 8191;
          h52 += t42 >>> 1 & 8191;
          t52 = m13[mpos + 10] & 255 | (m13[mpos + 11] & 255) << 8;
          h62 += (t42 >>> 14 | t52 << 2) & 8191;
          t62 = m13[mpos + 12] & 255 | (m13[mpos + 13] & 255) << 8;
          h72 += (t52 >>> 11 | t62 << 5) & 8191;
          t72 = m13[mpos + 14] & 255 | (m13[mpos + 15] & 255) << 8;
          h82 += (t62 >>> 8 | t72 << 8) & 8191;
          h92 += t72 >>> 5 | hibit;
          c10 = 0;
          d0 = c10;
          d0 += h0 * r0;
          d0 += h1 * (5 * r92);
          d0 += h22 * (5 * r82);
          d0 += h32 * (5 * r72);
          d0 += h42 * (5 * r62);
          c10 = d0 >>> 13;
          d0 &= 8191;
          d0 += h52 * (5 * r52);
          d0 += h62 * (5 * r42);
          d0 += h72 * (5 * r32);
          d0 += h82 * (5 * r22);
          d0 += h92 * (5 * r1);
          c10 += d0 >>> 13;
          d0 &= 8191;
          d1 = c10;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h22 * (5 * r92);
          d1 += h32 * (5 * r82);
          d1 += h42 * (5 * r72);
          c10 = d1 >>> 13;
          d1 &= 8191;
          d1 += h52 * (5 * r62);
          d1 += h62 * (5 * r52);
          d1 += h72 * (5 * r42);
          d1 += h82 * (5 * r32);
          d1 += h92 * (5 * r22);
          c10 += d1 >>> 13;
          d1 &= 8191;
          d22 = c10;
          d22 += h0 * r22;
          d22 += h1 * r1;
          d22 += h22 * r0;
          d22 += h32 * (5 * r92);
          d22 += h42 * (5 * r82);
          c10 = d22 >>> 13;
          d22 &= 8191;
          d22 += h52 * (5 * r72);
          d22 += h62 * (5 * r62);
          d22 += h72 * (5 * r52);
          d22 += h82 * (5 * r42);
          d22 += h92 * (5 * r32);
          c10 += d22 >>> 13;
          d22 &= 8191;
          d32 = c10;
          d32 += h0 * r32;
          d32 += h1 * r22;
          d32 += h22 * r1;
          d32 += h32 * r0;
          d32 += h42 * (5 * r92);
          c10 = d32 >>> 13;
          d32 &= 8191;
          d32 += h52 * (5 * r82);
          d32 += h62 * (5 * r72);
          d32 += h72 * (5 * r62);
          d32 += h82 * (5 * r52);
          d32 += h92 * (5 * r42);
          c10 += d32 >>> 13;
          d32 &= 8191;
          d42 = c10;
          d42 += h0 * r42;
          d42 += h1 * r32;
          d42 += h22 * r22;
          d42 += h32 * r1;
          d42 += h42 * r0;
          c10 = d42 >>> 13;
          d42 &= 8191;
          d42 += h52 * (5 * r92);
          d42 += h62 * (5 * r82);
          d42 += h72 * (5 * r72);
          d42 += h82 * (5 * r62);
          d42 += h92 * (5 * r52);
          c10 += d42 >>> 13;
          d42 &= 8191;
          d52 = c10;
          d52 += h0 * r52;
          d52 += h1 * r42;
          d52 += h22 * r32;
          d52 += h32 * r22;
          d52 += h42 * r1;
          c10 = d52 >>> 13;
          d52 &= 8191;
          d52 += h52 * r0;
          d52 += h62 * (5 * r92);
          d52 += h72 * (5 * r82);
          d52 += h82 * (5 * r72);
          d52 += h92 * (5 * r62);
          c10 += d52 >>> 13;
          d52 &= 8191;
          d62 = c10;
          d62 += h0 * r62;
          d62 += h1 * r52;
          d62 += h22 * r42;
          d62 += h32 * r32;
          d62 += h42 * r22;
          c10 = d62 >>> 13;
          d62 &= 8191;
          d62 += h52 * r1;
          d62 += h62 * r0;
          d62 += h72 * (5 * r92);
          d62 += h82 * (5 * r82);
          d62 += h92 * (5 * r72);
          c10 += d62 >>> 13;
          d62 &= 8191;
          d72 = c10;
          d72 += h0 * r72;
          d72 += h1 * r62;
          d72 += h22 * r52;
          d72 += h32 * r42;
          d72 += h42 * r32;
          c10 = d72 >>> 13;
          d72 &= 8191;
          d72 += h52 * r22;
          d72 += h62 * r1;
          d72 += h72 * r0;
          d72 += h82 * (5 * r92);
          d72 += h92 * (5 * r82);
          c10 += d72 >>> 13;
          d72 &= 8191;
          d82 = c10;
          d82 += h0 * r82;
          d82 += h1 * r72;
          d82 += h22 * r62;
          d82 += h32 * r52;
          d82 += h42 * r42;
          c10 = d82 >>> 13;
          d82 &= 8191;
          d82 += h52 * r32;
          d82 += h62 * r22;
          d82 += h72 * r1;
          d82 += h82 * r0;
          d82 += h92 * (5 * r92);
          c10 += d82 >>> 13;
          d82 &= 8191;
          d92 = c10;
          d92 += h0 * r92;
          d92 += h1 * r82;
          d92 += h22 * r72;
          d92 += h32 * r62;
          d92 += h42 * r52;
          c10 = d92 >>> 13;
          d92 &= 8191;
          d92 += h52 * r42;
          d92 += h62 * r32;
          d92 += h72 * r22;
          d92 += h82 * r1;
          d92 += h92 * r0;
          c10 += d92 >>> 13;
          d92 &= 8191;
          c10 = (c10 << 2) + c10 | 0;
          c10 = c10 + d0 | 0;
          d0 = c10 & 8191;
          c10 = c10 >>> 13;
          d1 += c10;
          h0 = d0;
          h1 = d1;
          h22 = d22;
          h32 = d32;
          h42 = d42;
          h52 = d52;
          h62 = d62;
          h72 = d72;
          h82 = d82;
          h92 = d92;
          mpos += 16;
          bytes3 -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h22;
        this.h[3] = h32;
        this.h[4] = h42;
        this.h[5] = h52;
        this.h[6] = h62;
        this.h[7] = h72;
        this.h[8] = h82;
        this.h[9] = h92;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g8 = new Uint16Array(10);
        var c10, mask, f13, i34;
        if (this.leftover) {
          i34 = this.leftover;
          this.buffer[i34++] = 1;
          for (; i34 < 16; i34++)
            this.buffer[i34] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c10 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i34 = 2; i34 < 10; i34++) {
          this.h[i34] += c10;
          c10 = this.h[i34] >>> 13;
          this.h[i34] &= 8191;
        }
        this.h[0] += c10 * 5;
        c10 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c10;
        c10 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c10;
        g8[0] = this.h[0] + 5;
        c10 = g8[0] >>> 13;
        g8[0] &= 8191;
        for (i34 = 1; i34 < 10; i34++) {
          g8[i34] = this.h[i34] + c10;
          c10 = g8[i34] >>> 13;
          g8[i34] &= 8191;
        }
        g8[9] -= 1 << 13;
        mask = (c10 ^ 1) - 1;
        for (i34 = 0; i34 < 10; i34++)
          g8[i34] &= mask;
        mask = ~mask;
        for (i34 = 0; i34 < 10; i34++)
          this.h[i34] = this.h[i34] & mask | g8[i34];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f13 = this.h[0] + this.pad[0];
        this.h[0] = f13 & 65535;
        for (i34 = 1; i34 < 8; i34++) {
          f13 = (this.h[i34] + this.pad[i34] | 0) + (f13 >>> 16) | 0;
          this.h[i34] = f13 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m13, mpos, bytes3) {
        var i34, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes3)
            want = bytes3;
          for (i34 = 0; i34 < want; i34++)
            this.buffer[this.leftover + i34] = m13[mpos + i34];
          bytes3 -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes3 >= 16) {
          want = bytes3 - bytes3 % 16;
          this.blocks(m13, mpos, want);
          mpos += want;
          bytes3 -= want;
        }
        if (bytes3) {
          for (i34 = 0; i34 < bytes3; i34++)
            this.buffer[this.leftover + i34] = m13[mpos + i34];
          this.leftover += bytes3;
        }
      };
      function crypto_onetimeauth(out, outpos, m13, mpos, n24, k3) {
        var s17 = new poly1305(k3);
        s17.update(m13, mpos, n24);
        s17.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h14, hpos, m13, mpos, n24, k3) {
        var x9 = new Uint8Array(16);
        crypto_onetimeauth(x9, 0, m13, mpos, n24, k3);
        return crypto_verify_16(h14, hpos, x9, 0);
      }
      function crypto_secretbox(c10, m13, d10, n24, k3) {
        var i34;
        if (d10 < 32)
          return -1;
        crypto_stream_xor(c10, 0, m13, 0, d10, n24, k3);
        crypto_onetimeauth(c10, 16, c10, 32, d10 - 32, c10);
        for (i34 = 0; i34 < 16; i34++)
          c10[i34] = 0;
        return 0;
      }
      function crypto_secretbox_open(m13, c10, d10, n24, k3) {
        var i34;
        var x9 = new Uint8Array(32);
        if (d10 < 32)
          return -1;
        crypto_stream(x9, 0, 32, n24, k3);
        if (crypto_onetimeauth_verify(c10, 16, c10, 32, d10 - 32, x9) !== 0)
          return -1;
        crypto_stream_xor(m13, 0, c10, 0, d10, n24, k3);
        for (i34 = 0; i34 < 32; i34++)
          m13[i34] = 0;
        return 0;
      }
      function set25519(r16, a19) {
        var i34;
        for (i34 = 0; i34 < 16; i34++)
          r16[i34] = a19[i34] | 0;
      }
      function car25519(o19) {
        var i34, v6, c10 = 1;
        for (i34 = 0; i34 < 16; i34++) {
          v6 = o19[i34] + c10 + 65535;
          c10 = Math.floor(v6 / 65536);
          o19[i34] = v6 - c10 * 65536;
        }
        o19[0] += c10 - 1 + 37 * (c10 - 1);
      }
      function sel25519(p11, q4, b10) {
        var t25, c10 = ~(b10 - 1);
        for (var i34 = 0; i34 < 16; i34++) {
          t25 = c10 & (p11[i34] ^ q4[i34]);
          p11[i34] ^= t25;
          q4[i34] ^= t25;
        }
      }
      function pack25519(o19, n24) {
        var i34, j4, b10;
        var m13 = gf(), t25 = gf();
        for (i34 = 0; i34 < 16; i34++)
          t25[i34] = n24[i34];
        car25519(t25);
        car25519(t25);
        car25519(t25);
        for (j4 = 0; j4 < 2; j4++) {
          m13[0] = t25[0] - 65517;
          for (i34 = 1; i34 < 15; i34++) {
            m13[i34] = t25[i34] - 65535 - (m13[i34 - 1] >> 16 & 1);
            m13[i34 - 1] &= 65535;
          }
          m13[15] = t25[15] - 32767 - (m13[14] >> 16 & 1);
          b10 = m13[15] >> 16 & 1;
          m13[14] &= 65535;
          sel25519(t25, m13, 1 - b10);
        }
        for (i34 = 0; i34 < 16; i34++) {
          o19[2 * i34] = t25[i34] & 255;
          o19[2 * i34 + 1] = t25[i34] >> 8;
        }
      }
      function neq25519(a19, b10) {
        var c10 = new Uint8Array(32), d10 = new Uint8Array(32);
        pack25519(c10, a19);
        pack25519(d10, b10);
        return crypto_verify_32(c10, 0, d10, 0);
      }
      function par25519(a19) {
        var d10 = new Uint8Array(32);
        pack25519(d10, a19);
        return d10[0] & 1;
      }
      function unpack25519(o19, n24) {
        var i34;
        for (i34 = 0; i34 < 16; i34++)
          o19[i34] = n24[2 * i34] + (n24[2 * i34 + 1] << 8);
        o19[15] &= 32767;
      }
      function A13(o19, a19, b10) {
        for (var i34 = 0; i34 < 16; i34++)
          o19[i34] = a19[i34] + b10[i34];
      }
      function Z5(o19, a19, b10) {
        for (var i34 = 0; i34 < 16; i34++)
          o19[i34] = a19[i34] - b10[i34];
      }
      function M6(o19, a19, b10) {
        var v6, c10, t0 = 0, t1 = 0, t25 = 0, t32 = 0, t42 = 0, t52 = 0, t62 = 0, t72 = 0, t82 = 0, t92 = 0, t102 = 0, t112 = 0, t122 = 0, t132 = 0, t142 = 0, t152 = 0, t162 = 0, t172 = 0, t182 = 0, t192 = 0, t202 = 0, t212 = 0, t222 = 0, t232 = 0, t242 = 0, t252 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b10[0], b1 = b10[1], b22 = b10[2], b32 = b10[3], b42 = b10[4], b52 = b10[5], b62 = b10[6], b72 = b10[7], b82 = b10[8], b92 = b10[9], b102 = b10[10], b11 = b10[11], b12 = b10[12], b13 = b10[13], b14 = b10[14], b15 = b10[15];
        v6 = a19[0];
        t0 += v6 * b0;
        t1 += v6 * b1;
        t25 += v6 * b22;
        t32 += v6 * b32;
        t42 += v6 * b42;
        t52 += v6 * b52;
        t62 += v6 * b62;
        t72 += v6 * b72;
        t82 += v6 * b82;
        t92 += v6 * b92;
        t102 += v6 * b102;
        t112 += v6 * b11;
        t122 += v6 * b12;
        t132 += v6 * b13;
        t142 += v6 * b14;
        t152 += v6 * b15;
        v6 = a19[1];
        t1 += v6 * b0;
        t25 += v6 * b1;
        t32 += v6 * b22;
        t42 += v6 * b32;
        t52 += v6 * b42;
        t62 += v6 * b52;
        t72 += v6 * b62;
        t82 += v6 * b72;
        t92 += v6 * b82;
        t102 += v6 * b92;
        t112 += v6 * b102;
        t122 += v6 * b11;
        t132 += v6 * b12;
        t142 += v6 * b13;
        t152 += v6 * b14;
        t162 += v6 * b15;
        v6 = a19[2];
        t25 += v6 * b0;
        t32 += v6 * b1;
        t42 += v6 * b22;
        t52 += v6 * b32;
        t62 += v6 * b42;
        t72 += v6 * b52;
        t82 += v6 * b62;
        t92 += v6 * b72;
        t102 += v6 * b82;
        t112 += v6 * b92;
        t122 += v6 * b102;
        t132 += v6 * b11;
        t142 += v6 * b12;
        t152 += v6 * b13;
        t162 += v6 * b14;
        t172 += v6 * b15;
        v6 = a19[3];
        t32 += v6 * b0;
        t42 += v6 * b1;
        t52 += v6 * b22;
        t62 += v6 * b32;
        t72 += v6 * b42;
        t82 += v6 * b52;
        t92 += v6 * b62;
        t102 += v6 * b72;
        t112 += v6 * b82;
        t122 += v6 * b92;
        t132 += v6 * b102;
        t142 += v6 * b11;
        t152 += v6 * b12;
        t162 += v6 * b13;
        t172 += v6 * b14;
        t182 += v6 * b15;
        v6 = a19[4];
        t42 += v6 * b0;
        t52 += v6 * b1;
        t62 += v6 * b22;
        t72 += v6 * b32;
        t82 += v6 * b42;
        t92 += v6 * b52;
        t102 += v6 * b62;
        t112 += v6 * b72;
        t122 += v6 * b82;
        t132 += v6 * b92;
        t142 += v6 * b102;
        t152 += v6 * b11;
        t162 += v6 * b12;
        t172 += v6 * b13;
        t182 += v6 * b14;
        t192 += v6 * b15;
        v6 = a19[5];
        t52 += v6 * b0;
        t62 += v6 * b1;
        t72 += v6 * b22;
        t82 += v6 * b32;
        t92 += v6 * b42;
        t102 += v6 * b52;
        t112 += v6 * b62;
        t122 += v6 * b72;
        t132 += v6 * b82;
        t142 += v6 * b92;
        t152 += v6 * b102;
        t162 += v6 * b11;
        t172 += v6 * b12;
        t182 += v6 * b13;
        t192 += v6 * b14;
        t202 += v6 * b15;
        v6 = a19[6];
        t62 += v6 * b0;
        t72 += v6 * b1;
        t82 += v6 * b22;
        t92 += v6 * b32;
        t102 += v6 * b42;
        t112 += v6 * b52;
        t122 += v6 * b62;
        t132 += v6 * b72;
        t142 += v6 * b82;
        t152 += v6 * b92;
        t162 += v6 * b102;
        t172 += v6 * b11;
        t182 += v6 * b12;
        t192 += v6 * b13;
        t202 += v6 * b14;
        t212 += v6 * b15;
        v6 = a19[7];
        t72 += v6 * b0;
        t82 += v6 * b1;
        t92 += v6 * b22;
        t102 += v6 * b32;
        t112 += v6 * b42;
        t122 += v6 * b52;
        t132 += v6 * b62;
        t142 += v6 * b72;
        t152 += v6 * b82;
        t162 += v6 * b92;
        t172 += v6 * b102;
        t182 += v6 * b11;
        t192 += v6 * b12;
        t202 += v6 * b13;
        t212 += v6 * b14;
        t222 += v6 * b15;
        v6 = a19[8];
        t82 += v6 * b0;
        t92 += v6 * b1;
        t102 += v6 * b22;
        t112 += v6 * b32;
        t122 += v6 * b42;
        t132 += v6 * b52;
        t142 += v6 * b62;
        t152 += v6 * b72;
        t162 += v6 * b82;
        t172 += v6 * b92;
        t182 += v6 * b102;
        t192 += v6 * b11;
        t202 += v6 * b12;
        t212 += v6 * b13;
        t222 += v6 * b14;
        t232 += v6 * b15;
        v6 = a19[9];
        t92 += v6 * b0;
        t102 += v6 * b1;
        t112 += v6 * b22;
        t122 += v6 * b32;
        t132 += v6 * b42;
        t142 += v6 * b52;
        t152 += v6 * b62;
        t162 += v6 * b72;
        t172 += v6 * b82;
        t182 += v6 * b92;
        t192 += v6 * b102;
        t202 += v6 * b11;
        t212 += v6 * b12;
        t222 += v6 * b13;
        t232 += v6 * b14;
        t242 += v6 * b15;
        v6 = a19[10];
        t102 += v6 * b0;
        t112 += v6 * b1;
        t122 += v6 * b22;
        t132 += v6 * b32;
        t142 += v6 * b42;
        t152 += v6 * b52;
        t162 += v6 * b62;
        t172 += v6 * b72;
        t182 += v6 * b82;
        t192 += v6 * b92;
        t202 += v6 * b102;
        t212 += v6 * b11;
        t222 += v6 * b12;
        t232 += v6 * b13;
        t242 += v6 * b14;
        t252 += v6 * b15;
        v6 = a19[11];
        t112 += v6 * b0;
        t122 += v6 * b1;
        t132 += v6 * b22;
        t142 += v6 * b32;
        t152 += v6 * b42;
        t162 += v6 * b52;
        t172 += v6 * b62;
        t182 += v6 * b72;
        t192 += v6 * b82;
        t202 += v6 * b92;
        t212 += v6 * b102;
        t222 += v6 * b11;
        t232 += v6 * b12;
        t242 += v6 * b13;
        t252 += v6 * b14;
        t26 += v6 * b15;
        v6 = a19[12];
        t122 += v6 * b0;
        t132 += v6 * b1;
        t142 += v6 * b22;
        t152 += v6 * b32;
        t162 += v6 * b42;
        t172 += v6 * b52;
        t182 += v6 * b62;
        t192 += v6 * b72;
        t202 += v6 * b82;
        t212 += v6 * b92;
        t222 += v6 * b102;
        t232 += v6 * b11;
        t242 += v6 * b12;
        t252 += v6 * b13;
        t26 += v6 * b14;
        t27 += v6 * b15;
        v6 = a19[13];
        t132 += v6 * b0;
        t142 += v6 * b1;
        t152 += v6 * b22;
        t162 += v6 * b32;
        t172 += v6 * b42;
        t182 += v6 * b52;
        t192 += v6 * b62;
        t202 += v6 * b72;
        t212 += v6 * b82;
        t222 += v6 * b92;
        t232 += v6 * b102;
        t242 += v6 * b11;
        t252 += v6 * b12;
        t26 += v6 * b13;
        t27 += v6 * b14;
        t28 += v6 * b15;
        v6 = a19[14];
        t142 += v6 * b0;
        t152 += v6 * b1;
        t162 += v6 * b22;
        t172 += v6 * b32;
        t182 += v6 * b42;
        t192 += v6 * b52;
        t202 += v6 * b62;
        t212 += v6 * b72;
        t222 += v6 * b82;
        t232 += v6 * b92;
        t242 += v6 * b102;
        t252 += v6 * b11;
        t26 += v6 * b12;
        t27 += v6 * b13;
        t28 += v6 * b14;
        t29 += v6 * b15;
        v6 = a19[15];
        t152 += v6 * b0;
        t162 += v6 * b1;
        t172 += v6 * b22;
        t182 += v6 * b32;
        t192 += v6 * b42;
        t202 += v6 * b52;
        t212 += v6 * b62;
        t222 += v6 * b72;
        t232 += v6 * b82;
        t242 += v6 * b92;
        t252 += v6 * b102;
        t26 += v6 * b11;
        t27 += v6 * b12;
        t28 += v6 * b13;
        t29 += v6 * b14;
        t30 += v6 * b15;
        t0 += 38 * t162;
        t1 += 38 * t172;
        t25 += 38 * t182;
        t32 += 38 * t192;
        t42 += 38 * t202;
        t52 += 38 * t212;
        t62 += 38 * t222;
        t72 += 38 * t232;
        t82 += 38 * t242;
        t92 += 38 * t252;
        t102 += 38 * t26;
        t112 += 38 * t27;
        t122 += 38 * t28;
        t132 += 38 * t29;
        t142 += 38 * t30;
        c10 = 1;
        v6 = t0 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t0 = v6 - c10 * 65536;
        v6 = t1 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t1 = v6 - c10 * 65536;
        v6 = t25 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t25 = v6 - c10 * 65536;
        v6 = t32 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t32 = v6 - c10 * 65536;
        v6 = t42 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t42 = v6 - c10 * 65536;
        v6 = t52 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t52 = v6 - c10 * 65536;
        v6 = t62 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t62 = v6 - c10 * 65536;
        v6 = t72 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t72 = v6 - c10 * 65536;
        v6 = t82 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t82 = v6 - c10 * 65536;
        v6 = t92 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t92 = v6 - c10 * 65536;
        v6 = t102 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t102 = v6 - c10 * 65536;
        v6 = t112 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t112 = v6 - c10 * 65536;
        v6 = t122 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t122 = v6 - c10 * 65536;
        v6 = t132 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t132 = v6 - c10 * 65536;
        v6 = t142 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t142 = v6 - c10 * 65536;
        v6 = t152 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t152 = v6 - c10 * 65536;
        t0 += c10 - 1 + 37 * (c10 - 1);
        c10 = 1;
        v6 = t0 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t0 = v6 - c10 * 65536;
        v6 = t1 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t1 = v6 - c10 * 65536;
        v6 = t25 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t25 = v6 - c10 * 65536;
        v6 = t32 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t32 = v6 - c10 * 65536;
        v6 = t42 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t42 = v6 - c10 * 65536;
        v6 = t52 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t52 = v6 - c10 * 65536;
        v6 = t62 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t62 = v6 - c10 * 65536;
        v6 = t72 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t72 = v6 - c10 * 65536;
        v6 = t82 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t82 = v6 - c10 * 65536;
        v6 = t92 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t92 = v6 - c10 * 65536;
        v6 = t102 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t102 = v6 - c10 * 65536;
        v6 = t112 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t112 = v6 - c10 * 65536;
        v6 = t122 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t122 = v6 - c10 * 65536;
        v6 = t132 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t132 = v6 - c10 * 65536;
        v6 = t142 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t142 = v6 - c10 * 65536;
        v6 = t152 + c10 + 65535;
        c10 = Math.floor(v6 / 65536);
        t152 = v6 - c10 * 65536;
        t0 += c10 - 1 + 37 * (c10 - 1);
        o19[0] = t0;
        o19[1] = t1;
        o19[2] = t25;
        o19[3] = t32;
        o19[4] = t42;
        o19[5] = t52;
        o19[6] = t62;
        o19[7] = t72;
        o19[8] = t82;
        o19[9] = t92;
        o19[10] = t102;
        o19[11] = t112;
        o19[12] = t122;
        o19[13] = t132;
        o19[14] = t142;
        o19[15] = t152;
      }
      function S7(o19, a19) {
        M6(o19, a19, a19);
      }
      function inv25519(o19, i34) {
        var c10 = gf();
        var a19;
        for (a19 = 0; a19 < 16; a19++)
          c10[a19] = i34[a19];
        for (a19 = 253; a19 >= 0; a19--) {
          S7(c10, c10);
          if (a19 !== 2 && a19 !== 4)
            M6(c10, c10, i34);
        }
        for (a19 = 0; a19 < 16; a19++)
          o19[a19] = c10[a19];
      }
      function pow2523(o19, i34) {
        var c10 = gf();
        var a19;
        for (a19 = 0; a19 < 16; a19++)
          c10[a19] = i34[a19];
        for (a19 = 250; a19 >= 0; a19--) {
          S7(c10, c10);
          if (a19 !== 1)
            M6(c10, c10, i34);
        }
        for (a19 = 0; a19 < 16; a19++)
          o19[a19] = c10[a19];
      }
      function crypto_scalarmult(q4, n24, p11) {
        var z5 = new Uint8Array(32);
        var x9 = new Float64Array(80), r16, i34;
        var a19 = gf(), b10 = gf(), c10 = gf(), d10 = gf(), e2 = gf(), f13 = gf();
        for (i34 = 0; i34 < 31; i34++)
          z5[i34] = n24[i34];
        z5[31] = n24[31] & 127 | 64;
        z5[0] &= 248;
        unpack25519(x9, p11);
        for (i34 = 0; i34 < 16; i34++) {
          b10[i34] = x9[i34];
          d10[i34] = a19[i34] = c10[i34] = 0;
        }
        a19[0] = d10[0] = 1;
        for (i34 = 254; i34 >= 0; --i34) {
          r16 = z5[i34 >>> 3] >>> (i34 & 7) & 1;
          sel25519(a19, b10, r16);
          sel25519(c10, d10, r16);
          A13(e2, a19, c10);
          Z5(a19, a19, c10);
          A13(c10, b10, d10);
          Z5(b10, b10, d10);
          S7(d10, e2);
          S7(f13, a19);
          M6(a19, c10, a19);
          M6(c10, b10, e2);
          A13(e2, a19, c10);
          Z5(a19, a19, c10);
          S7(b10, a19);
          Z5(c10, d10, f13);
          M6(a19, c10, _121665);
          A13(a19, a19, d10);
          M6(c10, c10, a19);
          M6(a19, d10, f13);
          M6(d10, b10, x9);
          S7(b10, e2);
          sel25519(a19, b10, r16);
          sel25519(c10, d10, r16);
        }
        for (i34 = 0; i34 < 16; i34++) {
          x9[i34 + 16] = a19[i34];
          x9[i34 + 32] = c10[i34];
          x9[i34 + 48] = b10[i34];
          x9[i34 + 64] = d10[i34];
        }
        var x32 = x9.subarray(32);
        var x16 = x9.subarray(16);
        inv25519(x32, x32);
        M6(x16, x16, x32);
        pack25519(q4, x16);
        return 0;
      }
      function crypto_scalarmult_base(q4, n24) {
        return crypto_scalarmult(q4, n24, _9);
      }
      function crypto_box_keypair(y12, x9) {
        randombytes(x9, 32);
        return crypto_scalarmult_base(y12, x9);
      }
      function crypto_box_beforenm(k3, y12, x9) {
        var s17 = new Uint8Array(32);
        crypto_scalarmult(s17, x9, y12);
        return crypto_core_hsalsa20(k3, _0, s17, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c10, m13, d10, n24, y12, x9) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y12, x9);
        return crypto_box_afternm(c10, m13, d10, n24, k3);
      }
      function crypto_box_open(m13, c10, d10, n24, y12, x9) {
        var k3 = new Uint8Array(32);
        crypto_box_beforenm(k3, y12, x9);
        return crypto_box_open_afternm(m13, c10, d10, n24, k3);
      }
      var K4 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m13, n24) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i34, j4, h14, l12, a19, b10, c10, d10;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n24 >= 128) {
          for (i34 = 0; i34 < 16; i34++) {
            j4 = 8 * i34 + pos;
            wh[i34] = m13[j4 + 0] << 24 | m13[j4 + 1] << 16 | m13[j4 + 2] << 8 | m13[j4 + 3];
            wl[i34] = m13[j4 + 4] << 24 | m13[j4 + 5] << 16 | m13[j4 + 6] << 8 | m13[j4 + 7];
          }
          for (i34 = 0; i34 < 80; i34++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h14 = ah7;
            l12 = al7;
            a19 = l12 & 65535;
            b10 = l12 >>> 16;
            c10 = h14 & 65535;
            d10 = h14 >>> 16;
            h14 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l12 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            h14 = ah4 & ah5 ^ ~ah4 & ah6;
            l12 = al4 & al5 ^ ~al4 & al6;
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            h14 = K4[i34 * 2];
            l12 = K4[i34 * 2 + 1];
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            h14 = wh[i34 % 16];
            l12 = wl[i34 % 16];
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            b10 += a19 >>> 16;
            c10 += b10 >>> 16;
            d10 += c10 >>> 16;
            th = c10 & 65535 | d10 << 16;
            tl = a19 & 65535 | b10 << 16;
            h14 = th;
            l12 = tl;
            a19 = l12 & 65535;
            b10 = l12 >>> 16;
            c10 = h14 & 65535;
            d10 = h14 >>> 16;
            h14 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l12 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            h14 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l12 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            b10 += a19 >>> 16;
            c10 += b10 >>> 16;
            d10 += c10 >>> 16;
            bh7 = c10 & 65535 | d10 << 16;
            bl7 = a19 & 65535 | b10 << 16;
            h14 = bh3;
            l12 = bl3;
            a19 = l12 & 65535;
            b10 = l12 >>> 16;
            c10 = h14 & 65535;
            d10 = h14 >>> 16;
            h14 = th;
            l12 = tl;
            a19 += l12 & 65535;
            b10 += l12 >>> 16;
            c10 += h14 & 65535;
            d10 += h14 >>> 16;
            b10 += a19 >>> 16;
            c10 += b10 >>> 16;
            d10 += c10 >>> 16;
            bh3 = c10 & 65535 | d10 << 16;
            bl3 = a19 & 65535 | b10 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i34 % 16 === 15) {
              for (j4 = 0; j4 < 16; j4++) {
                h14 = wh[j4];
                l12 = wl[j4];
                a19 = l12 & 65535;
                b10 = l12 >>> 16;
                c10 = h14 & 65535;
                d10 = h14 >>> 16;
                h14 = wh[(j4 + 9) % 16];
                l12 = wl[(j4 + 9) % 16];
                a19 += l12 & 65535;
                b10 += l12 >>> 16;
                c10 += h14 & 65535;
                d10 += h14 >>> 16;
                th = wh[(j4 + 1) % 16];
                tl = wl[(j4 + 1) % 16];
                h14 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l12 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a19 += l12 & 65535;
                b10 += l12 >>> 16;
                c10 += h14 & 65535;
                d10 += h14 >>> 16;
                th = wh[(j4 + 14) % 16];
                tl = wl[(j4 + 14) % 16];
                h14 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l12 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a19 += l12 & 65535;
                b10 += l12 >>> 16;
                c10 += h14 & 65535;
                d10 += h14 >>> 16;
                b10 += a19 >>> 16;
                c10 += b10 >>> 16;
                d10 += c10 >>> 16;
                wh[j4] = c10 & 65535 | d10 << 16;
                wl[j4] = a19 & 65535 | b10 << 16;
              }
            }
          }
          h14 = ah0;
          l12 = al0;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[0];
          l12 = hl[0];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[0] = ah0 = c10 & 65535 | d10 << 16;
          hl[0] = al0 = a19 & 65535 | b10 << 16;
          h14 = ah1;
          l12 = al1;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[1];
          l12 = hl[1];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[1] = ah1 = c10 & 65535 | d10 << 16;
          hl[1] = al1 = a19 & 65535 | b10 << 16;
          h14 = ah2;
          l12 = al2;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[2];
          l12 = hl[2];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[2] = ah2 = c10 & 65535 | d10 << 16;
          hl[2] = al2 = a19 & 65535 | b10 << 16;
          h14 = ah3;
          l12 = al3;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[3];
          l12 = hl[3];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[3] = ah3 = c10 & 65535 | d10 << 16;
          hl[3] = al3 = a19 & 65535 | b10 << 16;
          h14 = ah4;
          l12 = al4;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[4];
          l12 = hl[4];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[4] = ah4 = c10 & 65535 | d10 << 16;
          hl[4] = al4 = a19 & 65535 | b10 << 16;
          h14 = ah5;
          l12 = al5;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[5];
          l12 = hl[5];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[5] = ah5 = c10 & 65535 | d10 << 16;
          hl[5] = al5 = a19 & 65535 | b10 << 16;
          h14 = ah6;
          l12 = al6;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[6];
          l12 = hl[6];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[6] = ah6 = c10 & 65535 | d10 << 16;
          hl[6] = al6 = a19 & 65535 | b10 << 16;
          h14 = ah7;
          l12 = al7;
          a19 = l12 & 65535;
          b10 = l12 >>> 16;
          c10 = h14 & 65535;
          d10 = h14 >>> 16;
          h14 = hh[7];
          l12 = hl[7];
          a19 += l12 & 65535;
          b10 += l12 >>> 16;
          c10 += h14 & 65535;
          d10 += h14 >>> 16;
          b10 += a19 >>> 16;
          c10 += b10 >>> 16;
          d10 += c10 >>> 16;
          hh[7] = ah7 = c10 & 65535 | d10 << 16;
          hl[7] = al7 = a19 & 65535 | b10 << 16;
          pos += 128;
          n24 -= 128;
        }
        return n24;
      }
      function crypto_hash(out, m13, n24) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x9 = new Uint8Array(256), i34, b10 = n24;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m13, n24);
        n24 %= 128;
        for (i34 = 0; i34 < n24; i34++)
          x9[i34] = m13[b10 - n24 + i34];
        x9[n24] = 128;
        n24 = 256 - 128 * (n24 < 112 ? 1 : 0);
        x9[n24 - 9] = 0;
        ts64(x9, n24 - 8, b10 / 536870912 | 0, b10 << 3);
        crypto_hashblocks_hl(hh, hl, x9, n24);
        for (i34 = 0; i34 < 8; i34++)
          ts64(out, 8 * i34, hh[i34], hl[i34]);
        return 0;
      }
      function add3(p11, q4) {
        var a19 = gf(), b10 = gf(), c10 = gf(), d10 = gf(), e2 = gf(), f13 = gf(), g8 = gf(), h14 = gf(), t25 = gf();
        Z5(a19, p11[1], p11[0]);
        Z5(t25, q4[1], q4[0]);
        M6(a19, a19, t25);
        A13(b10, p11[0], p11[1]);
        A13(t25, q4[0], q4[1]);
        M6(b10, b10, t25);
        M6(c10, p11[3], q4[3]);
        M6(c10, c10, D22);
        M6(d10, p11[2], q4[2]);
        A13(d10, d10, d10);
        Z5(e2, b10, a19);
        Z5(f13, d10, c10);
        A13(g8, d10, c10);
        A13(h14, b10, a19);
        M6(p11[0], e2, f13);
        M6(p11[1], h14, g8);
        M6(p11[2], g8, f13);
        M6(p11[3], e2, h14);
      }
      function cswap(p11, q4, b10) {
        var i34;
        for (i34 = 0; i34 < 4; i34++) {
          sel25519(p11[i34], q4[i34], b10);
        }
      }
      function pack(r16, p11) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p11[2]);
        M6(tx, p11[0], zi);
        M6(ty, p11[1], zi);
        pack25519(r16, ty);
        r16[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p11, q4, s17) {
        var b10, i34;
        set25519(p11[0], gf0);
        set25519(p11[1], gf1);
        set25519(p11[2], gf1);
        set25519(p11[3], gf0);
        for (i34 = 255; i34 >= 0; --i34) {
          b10 = s17[i34 / 8 | 0] >> (i34 & 7) & 1;
          cswap(p11, q4, b10);
          add3(q4, p11);
          add3(p11, p11);
          cswap(p11, q4, b10);
        }
      }
      function scalarbase(p11, s17) {
        var q4 = [gf(), gf(), gf(), gf()];
        set25519(q4[0], X4);
        set25519(q4[1], Y3);
        set25519(q4[2], gf1);
        M6(q4[3], X4, Y3);
        scalarmult(p11, q4, s17);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d10 = new Uint8Array(64);
        var p11 = [gf(), gf(), gf(), gf()];
        var i34;
        if (!seeded)
          randombytes(sk, 32);
        crypto_hash(d10, sk, 32);
        d10[0] &= 248;
        d10[31] &= 127;
        d10[31] |= 64;
        scalarbase(p11, d10);
        pack(pk, p11);
        for (i34 = 0; i34 < 32; i34++)
          sk[i34 + 32] = pk[i34];
        return 0;
      }
      var L4 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r16, x9) {
        var carry, i34, j4, k3;
        for (i34 = 63; i34 >= 32; --i34) {
          carry = 0;
          for (j4 = i34 - 32, k3 = i34 - 12; j4 < k3; ++j4) {
            x9[j4] += carry - 16 * x9[i34] * L4[j4 - (i34 - 32)];
            carry = Math.floor((x9[j4] + 128) / 256);
            x9[j4] -= carry * 256;
          }
          x9[j4] += carry;
          x9[i34] = 0;
        }
        carry = 0;
        for (j4 = 0; j4 < 32; j4++) {
          x9[j4] += carry - (x9[31] >> 4) * L4[j4];
          carry = x9[j4] >> 8;
          x9[j4] &= 255;
        }
        for (j4 = 0; j4 < 32; j4++)
          x9[j4] -= carry * L4[j4];
        for (i34 = 0; i34 < 32; i34++) {
          x9[i34 + 1] += x9[i34] >> 8;
          r16[i34] = x9[i34] & 255;
        }
      }
      function reduce(r16) {
        var x9 = new Float64Array(64), i34;
        for (i34 = 0; i34 < 64; i34++)
          x9[i34] = r16[i34];
        for (i34 = 0; i34 < 64; i34++)
          r16[i34] = 0;
        modL(r16, x9);
      }
      function crypto_sign(sm, m13, n24, sk) {
        var d10 = new Uint8Array(64), h14 = new Uint8Array(64), r16 = new Uint8Array(64);
        var i34, j4, x9 = new Float64Array(64);
        var p11 = [gf(), gf(), gf(), gf()];
        crypto_hash(d10, sk, 32);
        d10[0] &= 248;
        d10[31] &= 127;
        d10[31] |= 64;
        var smlen = n24 + 64;
        for (i34 = 0; i34 < n24; i34++)
          sm[64 + i34] = m13[i34];
        for (i34 = 0; i34 < 32; i34++)
          sm[32 + i34] = d10[32 + i34];
        crypto_hash(r16, sm.subarray(32), n24 + 32);
        reduce(r16);
        scalarbase(p11, r16);
        pack(sm, p11);
        for (i34 = 32; i34 < 64; i34++)
          sm[i34] = sk[i34];
        crypto_hash(h14, sm, n24 + 64);
        reduce(h14);
        for (i34 = 0; i34 < 64; i34++)
          x9[i34] = 0;
        for (i34 = 0; i34 < 32; i34++)
          x9[i34] = r16[i34];
        for (i34 = 0; i34 < 32; i34++) {
          for (j4 = 0; j4 < 32; j4++) {
            x9[i34 + j4] += h14[i34] * d10[j4];
          }
        }
        modL(sm.subarray(32), x9);
        return smlen;
      }
      function unpackneg(r16, p11) {
        var t25 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r16[2], gf1);
        unpack25519(r16[1], p11);
        S7(num, r16[1]);
        M6(den, num, D7);
        Z5(num, num, r16[2]);
        A13(den, r16[2], den);
        S7(den2, den);
        S7(den4, den2);
        M6(den6, den4, den2);
        M6(t25, den6, num);
        M6(t25, t25, den);
        pow2523(t25, t25);
        M6(t25, t25, num);
        M6(t25, t25, den);
        M6(t25, t25, den);
        M6(r16[0], t25, den);
        S7(chk, r16[0]);
        M6(chk, chk, den);
        if (neq25519(chk, num))
          M6(r16[0], r16[0], I5);
        S7(chk, r16[0]);
        M6(chk, chk, den);
        if (neq25519(chk, num))
          return -1;
        if (par25519(r16[0]) === p11[31] >> 7)
          Z5(r16[0], gf0, r16[0]);
        M6(r16[3], r16[0], r16[1]);
        return 0;
      }
      function crypto_sign_open(m13, sm, n24, pk) {
        var i34;
        var t25 = new Uint8Array(32), h14 = new Uint8Array(64);
        var p11 = [gf(), gf(), gf(), gf()], q4 = [gf(), gf(), gf(), gf()];
        if (n24 < 64)
          return -1;
        if (unpackneg(q4, pk))
          return -1;
        for (i34 = 0; i34 < n24; i34++)
          m13[i34] = sm[i34];
        for (i34 = 0; i34 < 32; i34++)
          m13[i34 + 32] = pk[i34];
        crypto_hash(h14, m13, n24);
        reduce(h14);
        scalarmult(p11, q4, h14);
        scalarbase(q4, sm.subarray(32));
        add3(p11, q4);
        pack(t25, p11);
        n24 -= 64;
        if (crypto_verify_32(sm, 0, t25, 0)) {
          for (i34 = 0; i34 < n24; i34++)
            m13[i34] = 0;
          return -1;
        }
        for (i34 = 0; i34 < n24; i34++)
          m13[i34] = sm[i34 + 64];
        return n24;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D7,
        L: L4,
        pack25519,
        unpack25519,
        M: M6,
        A: A13,
        S: S7,
        Z: Z5,
        pow2523,
        add: add3,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k3, n24) {
        if (k3.length !== crypto_secretbox_KEYBYTES)
          throw new Error("bad key size");
        if (n24.length !== crypto_secretbox_NONCEBYTES)
          throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i34 = 0; i34 < arguments.length; i34++) {
          if (!(arguments[i34] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i34 = 0; i34 < arr.length; i34++)
          arr[i34] = 0;
      }
      nacl.randomBytes = function(n24) {
        var b10 = new Uint8Array(n24);
        randombytes(b10, n24);
        return b10;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m13 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c10 = new Uint8Array(m13.length);
        for (var i34 = 0; i34 < msg.length; i34++)
          m13[i34 + crypto_secretbox_ZEROBYTES] = msg[i34];
        crypto_secretbox(c10, m13, m13.length, nonce, key);
        return c10.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c10 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m13 = new Uint8Array(c10.length);
        for (var i34 = 0; i34 < box.length; i34++)
          c10[i34 + crypto_secretbox_BOXZEROBYTES] = box[i34];
        if (c10.length < 32)
          return null;
        if (crypto_secretbox_open(m13, c10, c10.length, nonce, key) !== 0)
          return null;
        return m13.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n24, p11) {
        checkArrayTypes(n24, p11);
        if (n24.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        if (p11.length !== crypto_scalarmult_BYTES)
          throw new Error("bad p size");
        var q4 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q4, n24, p11);
        return q4;
      };
      nacl.scalarMult.base = function(n24) {
        checkArrayTypes(n24);
        if (n24.length !== crypto_scalarmult_SCALARBYTES)
          throw new Error("bad n size");
        var q4 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q4, n24);
        return q4;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k3);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k3 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k3, publicKey, secretKey);
        return k3;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k3 = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k3);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0)
          return null;
        var m13 = new Uint8Array(mlen);
        for (var i34 = 0; i34 < m13.length; i34++)
          m13[i34] = tmp[i34];
        return m13;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i34 = 0; i34 < sig.length; i34++)
          sig[i34] = signedMsg[i34];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m13 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i34;
        for (i34 = 0; i34 < crypto_sign_BYTES; i34++)
          sm[i34] = sig[i34];
        for (i34 = 0; i34 < msg.length; i34++)
          sm[i34 + crypto_sign_BYTES] = msg[i34];
        return crypto_sign_open(m13, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i34 = 0; i34 < pk.length; i34++)
          pk[i34] = secretKey[32 + i34];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i34 = 0; i34 < 32; i34++)
          sk[i34] = seed[i34];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h14 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h14, msg, msg.length);
        return h14;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x9, y12) {
        checkArrayTypes(x9, y12);
        if (x9.length === 0 || y12.length === 0)
          return false;
        if (x9.length !== y12.length)
          return false;
        return vn(x9, 0, y12, 0, x9.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto3 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto3 && crypto3.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x9, n24) {
            var i34, v6 = new Uint8Array(n24);
            for (i34 = 0; i34 < n24; i34 += QUOTA) {
              crypto3.getRandomValues(v6.subarray(i34, i34 + Math.min(n24 - i34, QUOTA)));
            }
            for (i34 = 0; i34 < n24; i34++)
              x9[i34] = v6[i34];
            cleanup(v6);
          });
        } else if (typeof __require !== "undefined") {
          crypto3 = require_crypto();
          if (crypto3 && crypto3.randomBytes) {
            nacl.setPRNG(function(x9, n24) {
              var i34, v6 = crypto3.randomBytes(n24);
              for (i34 = 0; i34 < n24; i34++)
                x9[i34] = v6[i34];
              cleanup(v6);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// E:/Proj/HXProjs/lucky-pocket/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "E:/Proj/HXProjs/lucky-pocket/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter2() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter2.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter2.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i34 = 0, l12 = handlers.length, ee2 = new Array(l12); i34 < l12; i34++) {
        ee2[i34] = handlers[i34].fn;
      }
      return ee2;
    };
    EventEmitter2.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter2.prototype.emit = function emit(event, a1, a22, a32, a42, a52) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i34;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a22), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a22, a32), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a22, a32, a42, a52), true;
        }
        for (i34 = 1, args = new Array(len - 1); i34 < len; i34++) {
          args[i34 - 1] = arguments[i34];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j4;
        for (i34 = 0; i34 < length; i34++) {
          if (listeners[i34].once)
            this.removeListener(event, listeners[i34].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i34].fn.call(listeners[i34].context);
              break;
            case 2:
              listeners[i34].fn.call(listeners[i34].context, a1);
              break;
            case 3:
              listeners[i34].fn.call(listeners[i34].context, a1, a22);
              break;
            case 4:
              listeners[i34].fn.call(listeners[i34].context, a1, a22, a32);
              break;
            default:
              if (!args)
                for (j4 = 1, args = new Array(len - 1); j4 < len; j4++) {
                  args[j4 - 1] = arguments[j4];
                }
              listeners[i34].fn.apply(listeners[i34].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter2.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter2.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i34 = 0, events = [], length = listeners.length; i34 < length; i34++) {
          if (listeners[i34].fn !== fn || once && !listeners[i34].once || context && listeners[i34].context !== context) {
            events.push(listeners[i34]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
    EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
    EventEmitter2.prefixed = prefix;
    EventEmitter2.EventEmitter = EventEmitter2;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter2;
    }
  }
});

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LG7RJQ57.mjs
var s = class extends Error {
  constructor(e2, i34) {
    super(e2), this.invalidReason = i34;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/_assert.js
function number(n24) {
  if (!Number.isSafeInteger(n24) || n24 < 0)
    throw new Error(`positive integer expected, not ${n24}`);
}
function isBytes(a19) {
  return a19 instanceof Uint8Array || a19 != null && typeof a19 === "object" && a19.constructor.name === "Uint8Array";
}
function bytes(b10, ...lengths) {
  if (!isBytes(b10))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b10.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b10.length}`);
}
function hash(h14) {
  if (typeof h14 !== "function" || typeof h14.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h14.outputLen);
  number(h14.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i34 = 0; i34 < arr.length; i34++) {
    arr[i34] = byteSwap(arr[i34]);
  }
}
var hexes = Array.from({ length: 256 }, (_6, i34) => i34.toString(16).padStart(2, "0"));
function bytesToHex(bytes3) {
  bytes(bytes3);
  let hex2 = "";
  for (let i34 = 0; i34 < bytes3.length; i34++) {
    hex2 += hexes[bytes3[i34]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n24 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n24 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n24;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i34 = 0; i34 < arrays.length; i34++) {
    const a19 = arrays[i34];
    bytes(a19);
    sum += a19.length;
  }
  const res = new Uint8Array(sum);
  for (let i34 = 0, pad = 0; i34 < arrays.length; i34++) {
    const a19 = arrays[i34];
    res.set(a19, pad);
    pad += a19.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BZMO6Q6L.mjs
var l = ((e2) => (e2.TOO_SHORT = "too_short", e2.INVALID_LENGTH = "invalid_length", e2.INVALID_HEX_CHARS = "invalid_hex_chars", e2))(l || {});
var i = class n {
  constructor(t25) {
    this.data = t25;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromString(t25) {
    let r16 = t25;
    if (r16.startsWith("0x") && (r16 = r16.slice(2)), r16.length === 0)
      throw new s("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (r16.length % 2 !== 0)
      throw new s("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new n(hexToBytes(r16));
    } catch (e2) {
      throw new s(`Hex string contains invalid hex characters: ${e2 == null ? void 0 : e2.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(t25) {
    return t25 instanceof Uint8Array ? new n(t25) : n.fromString(t25);
  }
  static isValid(t25) {
    try {
      return n.fromString(t25), { valid: true };
    } catch (r16) {
      return { valid: false, invalidReason: r16 == null ? void 0 : r16.invalidReason, invalidReasonMessage: r16 == null ? void 0 : r16.message };
    }
  }
  equals(t25) {
    return this.data.length !== t25.data.length ? false : this.data.every((r16, e2) => r16 === t25.data[e2]);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-56CNRT2K.mjs
var t = 255;
var n2 = 65535;
var U = 4294967295;
var _ = 18446744073709551615n;
var o = 340282366920938463463374607431768211455n;
var i2 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FVA2OPG4.mjs
var h = Object.defineProperty;
var i3 = Object.getOwnPropertyDescriptor;
var j = (g8, b10, d10, c10) => {
  for (var a19 = c10 > 1 ? void 0 : c10 ? i3(b10, d10) : b10, e2 = g8.length - 1, f13; e2 >= 0; e2--)
    (f13 = g8[e2]) && (a19 = (c10 ? f13(b10, d10, a19) : f13(a19)) || a19);
  return c10 && a19 && h(b10, d10, a19), a19;
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-W2XLZW4Y.mjs
var B = class {
  bcsToBytes() {
    let e2 = new n3();
    return this.serialize(e2), e2.toUint8Array();
  }
  bcsToHex() {
    let e2 = this.bcsToBytes();
    return i.fromHexInput(e2);
  }
};
var n3 = class {
  constructor(e2 = 64) {
    if (e2 <= 0)
      throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(e2), this.offset = 0;
  }
  ensureBufferWillHandleSize(e2) {
    for (; this.buffer.byteLength < this.offset + e2; ) {
      let t25 = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(t25).set(new Uint8Array(this.buffer)), this.buffer = t25;
    }
  }
  appendToBuffer(e2) {
    this.ensureBufferWillHandleSize(e2.length), new Uint8Array(this.buffer, this.offset).set(e2), this.offset += e2.length;
  }
  serializeWithFunction(e2, t25, i34) {
    this.ensureBufferWillHandleSize(t25);
    let a19 = new DataView(this.buffer, this.offset);
    e2.apply(a19, [0, i34, true]), this.offset += t25;
  }
  serializeStr(e2) {
    let t25 = new TextEncoder();
    this.serializeBytes(t25.encode(e2));
  }
  serializeBytes(e2) {
    this.serializeU32AsUleb128(e2.length), this.appendToBuffer(e2);
  }
  serializeFixedBytes(e2) {
    this.appendToBuffer(e2);
  }
  serializeBool(e2) {
    A(e2);
    let t25 = e2 ? 1 : 0;
    this.appendToBuffer(new Uint8Array([t25]));
  }
  serializeU8(e2) {
    this.appendToBuffer(new Uint8Array([e2]));
  }
  serializeU16(e2) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, e2);
  }
  serializeU32(e2) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, e2);
  }
  serializeU64(e2) {
    let t25 = BigInt(e2) & BigInt(U), i34 = BigInt(e2) >> BigInt(32);
    this.serializeU32(Number(t25)), this.serializeU32(Number(i34));
  }
  serializeU128(e2) {
    let t25 = BigInt(e2) & _, i34 = BigInt(e2) >> BigInt(64);
    this.serializeU64(t25), this.serializeU64(i34);
  }
  serializeU256(e2) {
    let t25 = BigInt(e2) & o, i34 = BigInt(e2) >> BigInt(128);
    this.serializeU128(t25), this.serializeU128(i34);
  }
  serializeU32AsUleb128(e2) {
    let t25 = e2, i34 = [];
    for (; t25 >>> 7; )
      i34.push(t25 & 127 | 128), t25 >>>= 7;
    i34.push(t25), this.appendToBuffer(new Uint8Array(i34));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(e2) {
    e2.serialize(this);
  }
  serializeVector(e2) {
    this.serializeU32AsUleb128(e2.length), e2.forEach((t25) => {
      t25.serialize(this);
    });
  }
};
j([o2(0, t)], n3.prototype, "serializeU8", 1), j([o2(0, n2)], n3.prototype, "serializeU16", 1), j([o2(0, U)], n3.prototype, "serializeU32", 1), j([o2(BigInt(0), _)], n3.prototype, "serializeU64", 1), j([o2(BigInt(0), o)], n3.prototype, "serializeU128", 1), j([o2(BigInt(0), i2)], n3.prototype, "serializeU256", 1), j([o2(0, U)], n3.prototype, "serializeU32AsUleb128", 1);
function A(r16) {
  if (typeof r16 != "boolean")
    throw new Error(`${r16} is not a boolean value`);
}
var g = (r16, e2, t25) => `${r16} is out of range: [${e2}, ${t25}]`;
function w(r16, e2, t25) {
  let i34 = BigInt(r16);
  if (i34 > BigInt(t25) || i34 < BigInt(e2))
    throw new Error(g(r16, e2, t25));
}
function o2(r16, e2) {
  return (t25, i34, a19) => {
    let p11 = a19.value;
    return a19.value = function(l12) {
      return w(l12, r16, e2), p11.apply(this, [l12]);
    }, a19;
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JPG25VX2.mjs
var h2 = ((s17) => (s17.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", s17.INVALID_HEX_CHARS = "invalid_hex_chars", s17.TOO_SHORT = "too_short", s17.TOO_LONG = "too_long", s17.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", s17.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", s17.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", s17))(h2 || {});
var r = class r2 extends B {
  constructor(t25) {
    if (super(), t25.length !== r2.LENGTH)
      throw new s("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = t25;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((t25) => t25 === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let t25 = bytesToHex(this.data);
    return this.isSpecial() && (t25 = t25[t25.length - 1]), t25;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(t25) {
    t25.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(t25) {
    let e2 = this.bcsToBytes();
    t25.serializeBytes(e2);
  }
  serializeForScriptFunction(t25) {
    t25.serializeU32AsUleb128(3), t25.serialize(this);
  }
  static deserialize(t25) {
    let e2 = t25.deserializeFixedBytes(r2.LENGTH);
    return new r2(e2);
  }
  static fromStringStrict(t25) {
    if (!t25.startsWith("0x"))
      throw new s("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let e2 = r2.fromString(t25);
    if (t25.length !== r2.LONG_STRING_LENGTH + 2)
      if (e2.isSpecial()) {
        if (t25.length !== 3)
          throw new s(`The given hex string ${t25} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
      } else
        throw new s(`The given hex string ${t25} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return e2;
  }
  static fromString(t25) {
    let e2 = t25;
    if (t25.startsWith("0x") && (e2 = t25.slice(2)), e2.length === 0)
      throw new s("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (e2.length > 64)
      throw new s("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    let n24;
    try {
      n24 = hexToBytes(e2.padStart(64, "0"));
    } catch (d10) {
      throw new s(`Hex characters are invalid: ${d10 == null ? void 0 : d10.message}`, "invalid_hex_chars");
    }
    return new r2(n24);
  }
  static from(t25) {
    return t25 instanceof r2 ? t25 : t25 instanceof Uint8Array ? new r2(t25) : r2.fromString(t25);
  }
  static fromStrict(t25) {
    return t25 instanceof r2 ? t25 : t25 instanceof Uint8Array ? new r2(t25) : r2.fromStringStrict(t25);
  }
  static isValid(t25) {
    try {
      return t25.strict ? r2.fromStrict(t25.input) : r2.from(t25.input), { valid: true };
    } catch (e2) {
      return { valid: false, invalidReason: e2 == null ? void 0 : e2.invalidReason, invalidReasonMessage: e2 == null ? void 0 : e2.message };
    }
  }
  equals(t25) {
    return this.data.length !== t25.data.length ? false : this.data.every((e2, n24) => e2 === t25.data[n24]);
  }
};
r.LENGTH = 32, r.LONG_STRING_LENGTH = 64, r.ZERO = r.from("0x0"), r.ONE = r.from("0x1"), r.TWO = r.from("0x2"), r.THREE = r.from("0x3"), r.FOUR = r.from("0x4");
var c = r;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-S4SEFF4K.mjs
var i4 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var a = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
}
    `;
var s2 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var _2 = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var u = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var c2 = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var d = `
    query getAccountOwnedObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var l2 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var y = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var p = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var m = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var g2 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var b = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var T = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
var k = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var $ = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var f = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
var v = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var h3 = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
  }
}
    `;
var A2 = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${a}`;
var w2 = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var G = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
var C = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${i4}`;
var q = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var Q = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GHYE26Q5.mjs
var s3 = class extends Error {
  constructor(e2, t25, a19) {
    super(a19), this.name = "AptosApiError", this.url = t25.url, this.status = t25.status, this.statusText = t25.statusText, this.data = t25.data, this.request = e2;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GSLZL2LN.mjs
var o3 = "1.10.0";

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CYFKE643.mjs
var l3 = { 400: "Bad Request", 401: "Unauthorized", 403: "Forbidden", 404: "Not Found", 429: "Too Many Requests", 500: "Internal Server Error", 502: "Bad Gateway", 503: "Service Unavailable" };
async function c3(o19, a19) {
  let { url: r16, method: i34, body: u11, contentType: s17, params: e2, overrides: t25 } = o19, n24 = { ...t25 == null ? void 0 : t25.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o3}`, "content-type": s17 ?? "application/json" };
  return (t25 == null ? void 0 : t25.AUTH_TOKEN) && r16.includes("faucet") && (n24.Authorization = `Bearer ${t25 == null ? void 0 : t25.AUTH_TOKEN}`), (t25 == null ? void 0 : t25.API_KEY) && !r16.includes("faucet") && (n24.Authorization = `Bearer ${t25 == null ? void 0 : t25.API_KEY}`), a19.provider({ url: r16, method: i34, body: u11, params: e2, headers: n24, overrides: t25 });
}
async function T2(o19, a19) {
  let { url: r16, path: i34 } = o19, u11 = i34 ? `${r16}/${i34}` : r16, s17 = await c3({ ...o19, url: u11 }, a19.client), e2 = { status: s17.status, statusText: s17.statusText, data: s17.data, headers: s17.headers, config: s17.config, request: s17.request, url: u11 };
  if (a19.isIndexerRequest(r16)) {
    let n24 = e2.data;
    if (n24.errors)
      throw new s3(o19, e2, `Indexer error: ${n24.errors[0].message}` ?? `Indexer unhandled Error ${s17.status} : ${s17.statusText}`);
    e2.data = n24.data;
  }
  if (e2.status >= 200 && e2.status < 300)
    return e2;
  let t25;
  throw e2 && e2.data && "message" in e2.data && "error_code" in e2.data ? t25 = JSON.stringify(e2.data) : e2.status in l3 ? t25 = l3[e2.status] : t25 = `Unhandled Error ${e2.status} : ${e2.statusText}`, new s3(o19, e2, `${a19.isFullnodeRequest(r16) ? "Fullnode" : "Faucet"} error: ${t25}`);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6TIQD57I.mjs
async function s4(e2) {
  let { type: p11, originMethod: n24, path: i34, body: r16, acceptType: R6, contentType: y12, params: u11, aptosConfig: t25, overrides: m13 } = e2, c10 = t25.getRequestUrl(p11);
  return T2({ url: c10, method: "POST", originMethod: n24, path: i34, body: r16, contentType: y12 == null ? void 0 : y12.valueOf(), acceptType: R6 == null ? void 0 : R6.valueOf(), params: u11, overrides: { ...t25.clientConfig, ...m13 } }, t25);
}
async function A3(e2) {
  return s4({ ...e2, type: 0 });
}
async function f2(e2) {
  return s4({ ...e2, type: 1 });
}
async function x(e2) {
  return s4({ ...e2, type: 2 });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RQSMDDYP.mjs
async function p2(e2) {
  let { aptosConfig: t25, overrides: s17, params: n24, contentType: o19, acceptType: i34, path: a19, originMethod: u11, type: R6 } = e2, d10 = t25.getRequestUrl(R6);
  return T2({ url: d10, method: "GET", originMethod: u11, path: a19, contentType: o19 == null ? void 0 : o19.valueOf(), acceptType: i34 == null ? void 0 : i34.valueOf(), params: n24, overrides: { ...t25.clientConfig, ...s17 } }, t25);
}
async function g3(e2) {
  return p2({ ...e2, type: 0 });
}
async function f3(e2) {
  let t25 = [], s17, n24 = e2.params;
  do {
    let o19 = await p2({ type: 0, aptosConfig: e2.aptosConfig, originMethod: e2.originMethod, path: e2.path, params: n24, overrides: e2.overrides });
    s17 = o19.headers["x-aptos-cursor"], delete o19.headers, t25.push(...o19.data), n24.start = s17;
  } while (s17 != null);
  return t25;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SOFGN24M.mjs
async function l4(o19) {
  let { aptosConfig: e2 } = o19, { data: t25 } = await g3({ aptosConfig: e2, originMethod: "getLedgerInfo", path: "" });
  return t25;
}
async function h4(o19) {
  let { aptosConfig: e2, ledgerVersion: t25, options: s17 } = o19, { data: r16 } = await g3({ aptosConfig: e2, originMethod: "getBlockByVersion", path: `blocks/by_version/${t25}`, params: { with_transactions: s17 == null ? void 0 : s17.withTransactions } });
  return r16;
}
async function m2(o19) {
  let { aptosConfig: e2, blockHeight: t25, options: s17 } = o19, { data: r16 } = await g3({ aptosConfig: e2, originMethod: "getBlockByHeight", path: `blocks/by_height/${t25}`, params: { with_transactions: s17 == null ? void 0 : s17.withTransactions } });
  return r16;
}
async function C2(o19) {
  let { aptosConfig: e2, handle: t25, data: s17, options: r16 } = o19;
  return (await A3({ aptosConfig: e2, originMethod: "getTableItem", path: `tables/${t25}/item`, params: { ledger_version: r16 == null ? void 0 : r16.ledgerVersion }, body: s17 })).data;
}
async function T3(o19) {
  let { aptosConfig: e2, payload: t25, options: s17 } = o19, { data: r16 } = await A3({ aptosConfig: e2, originMethod: "view", path: "view", params: { ledger_version: s17 == null ? void 0 : s17.ledgerVersion }, body: { function: t25.function, type_arguments: t25.typeArguments ?? [], arguments: t25.functionArguments ?? [] } });
  return r16;
}
async function q2(o19) {
  let { aptosConfig: e2, limit: t25 } = o19;
  return (await p3({ aptosConfig: e2, query: { query: b, variables: { limit: t25 } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function p3(o19) {
  let { aptosConfig: e2, query: t25, originMethod: s17 } = o19, { data: r16 } = await f2({ aptosConfig: e2, originMethod: s17 ?? "queryIndexer", path: "", body: t25, overrides: { WITH_CREDENTIALS: false } });
  return r16;
}
async function f4(o19) {
  let { aptosConfig: e2 } = o19;
  return (await p3({ aptosConfig: e2, query: { query: G }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function w3(o19) {
  let e2 = await f4({ aptosConfig: o19.aptosConfig });
  return BigInt(e2[0].last_success_version);
}
async function A4(o19) {
  let { aptosConfig: e2, processorType: t25 } = o19, s17 = { processor: { _eq: t25.valueOf() } };
  return (await p3({ aptosConfig: e2, query: { query: G, variables: { where_condition: s17 } }, originMethod: "getProcessorStatus" })).processor_status[0];
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2IKY56WM.mjs
async function m3(e2) {
  let { aptosConfig: t25, poolAddress: o19 } = e2, r16 = c.from(o19).toStringLong(), i34 = await p3({ aptosConfig: t25, query: { query: w2, variables: { where_condition: { pool_address: { _eq: r16 } } } } });
  return i34.num_active_delegator_per_pool[0] ? i34.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function f5(e2) {
  let { aptosConfig: t25, options: o19 } = e2, r16 = { query: w2, variables: { order_by: o19 == null ? void 0 : o19.orderBy } };
  return (await p3({ aptosConfig: t25, query: r16 })).num_active_delegator_per_pool;
}
async function A5(e2) {
  let { aptosConfig: t25, delegatorAddress: o19, poolAddress: r16 } = e2, a19 = { query: $, variables: { delegatorAddress: c.from(o19).toStringLong(), poolAddress: c.from(r16).toStringLong() } };
  return (await p3({ aptosConfig: t25, query: a19 })).delegated_staking_activities;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AH44UPM4.mjs
var n4 = /* @__PURE__ */ new Map();
function m4(r16, e2, t25) {
  return async (...s17) => {
    if (n4.has(e2)) {
      let { value: i34, timestamp: u11 } = n4.get(e2);
      if (t25 === void 0 || Date.now() - u11 <= t25)
        return i34;
    }
    let a19 = await r16(...s17);
    return n4.set(e2, { value: a19, timestamp: Date.now() }), a19;
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3JPVQHOR.mjs
async function r3(e2) {
  return new Promise((n24) => {
    setTimeout(n24, e2);
  });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HEPV52CH.mjs
var O = ((S7) => (S7[S7.FULLNODE = 0] = "FULLNODE", S7[S7.INDEXER = 1] = "INDEXER", S7[S7.FAUCET = 2] = "FAUCET", S7))(O || {});
var t2 = 2e5;
var R = 20;
var n5 = 20;
var N = "0x1::aptos_coin::AptosCoin";
var T4 = "APTOS::RawTransaction";
var o4 = "APTOS::RawTransactionWithData";
var E = ((_6) => (_6.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", _6.DEFAULT = "default_processor", _6.EVENTS_PROCESSOR = "events_processor", _6.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", _6.STAKE_PROCESSOR = "stake_processor", _6.TOKEN_V2_PROCESSOR = "token_v2_processor", _6.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", _6))(E || {});

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RV2KJIXD.mjs
async function F(s17) {
  let { aptosConfig: n24, options: t25 } = s17;
  return f3({ aptosConfig: n24, originMethod: "getTransactions", path: "transactions", params: { start: t25 == null ? void 0 : t25.offset, limit: t25 == null ? void 0 : t25.limit } });
}
async function L(s17) {
  let { aptosConfig: n24 } = s17;
  return m4(async () => {
    let { data: t25 } = await g3({ aptosConfig: n24, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return t25;
  }, `gas-price-${n24.network}`, 1e3 * 60 * 5)();
}
async function v2(s17) {
  let { aptosConfig: n24, ledgerVersion: t25 } = s17, { data: o19 } = await g3({ aptosConfig: n24, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t25}` });
  return o19;
}
async function x2(s17) {
  let { aptosConfig: n24, transactionHash: t25 } = s17, { data: o19 } = await g3({ aptosConfig: n24, path: `transactions/by_hash/${t25}`, originMethod: "getTransactionByHash" });
  return o19;
}
async function N2(s17) {
  let { aptosConfig: n24, transactionHash: t25 } = s17;
  try {
    return (await x2({ aptosConfig: n24, transactionHash: t25 })).type === "pending_transaction";
  } catch (o19) {
    if ((o19 == null ? void 0 : o19.status) === 404)
      return true;
    throw o19;
  }
}
async function G2(s17) {
  let { aptosConfig: n24, transactionHash: t25, options: o19 } = s17, r16 = (o19 == null ? void 0 : o19.timeoutSecs) ?? 20, f13 = (o19 == null ? void 0 : o19.checkSuccess) ?? true, i34 = true, u11 = 0, e2, g8, m13 = 200, P6 = 1.5;
  for (; i34 && !(u11 >= r16); ) {
    try {
      if (e2 = await x2({ aptosConfig: n24, transactionHash: t25 }), i34 = e2.type === "pending_transaction", !i34)
        break;
    } catch (a19) {
      if (!(a19 instanceof s3) || (g8 = a19, a19.status !== 404 && a19.status >= 400 && a19.status < 500))
        throw a19;
    }
    await r3(m13), u11 += m13 / 1e3, m13 *= P6;
  }
  if (e2 === void 0)
    throw g8 || new p4(`Fetching transaction ${t25} failed and timed out after ${r16} seconds`, e2);
  if (e2.type === "pending_transaction")
    throw new p4(`Transaction ${t25} timed out in pending state after ${r16} seconds`, e2);
  if (!f13)
    return e2;
  if (!e2.success)
    throw new T5(`Transaction ${t25} failed with an error: ${e2.vm_status}`, e2);
  return e2;
}
async function D(s17) {
  let { aptosConfig: n24, processorType: t25 } = s17, o19 = BigInt(s17.minimumLedgerVersion), r16 = 3e3, f13 = (/* @__PURE__ */ new Date()).getTime(), i34 = BigInt(-1);
  for (; i34 < o19; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - f13 > r16)
      throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (t25 === void 0 ? i34 = await w3({ aptosConfig: n24 }) : i34 = (await A4({ aptosConfig: n24, processorType: t25 })).last_success_version, i34 >= o19)
      break;
    await r3(200);
  }
}
var p4 = class extends Error {
  constructor(n24, t25) {
    super(n24), this.lastSubmittedTransaction = t25;
  }
};
var T5 = class extends Error {
  constructor(n24, t25) {
    super(n24), this.transaction = t25;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6EERYUB2.mjs
async function i5(o19) {
  o19.minimumLedgerVersion !== void 0 && await D({ aptosConfig: o19.config, minimumLedgerVersion: o19.minimumLedgerVersion, processorType: o19.processorType });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HXNVG4RI.mjs
var t3 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getNumberOfDelegators(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "stake_processor" }), m3({ aptosConfig: this.config, ...e2 });
  }
  async getNumberOfDelegatorsForAllPools(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "stake_processor" }), f5({ aptosConfig: this.config, ...e2 });
  }
  async getDelegatedStakingActivities(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "stake_processor" }), A5({ aptosConfig: this.config, ...e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6EMN3BOV.mjs
function o5(a19, i34, e2) {
  let r16 = e2.value;
  return e2.value = async function(...t25) {
    let [n24] = t25;
    if (n24.transaction.feePayerAddress && !n24.feePayerAuthenticator)
      throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
    return r16.apply(this, t25);
  }, e2;
}
function u2(a19, i34, e2) {
  let r16 = e2.value;
  return e2.value = async function(...t25) {
    let [n24] = t25;
    if (n24.transaction.feePayerAddress && !n24.feePayerPublicKey)
      throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
    return r16.apply(this, t25);
  }, e2;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-M6TKSJ4I.mjs
var r4 = class t4 extends B {
  constructor(i34) {
    super(), this.identifier = i34;
  }
  serialize(i34) {
    i34.serializeStr(this.identifier);
  }
  static deserialize(i34) {
    let s17 = i34.deserializeStr();
    return new t4(s17);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HWTX3HVX.mjs
var t5 = class extends B {
  static deserialize(e2) {
    let r16 = e2.deserializeUleb128AsU32();
    switch (r16) {
      case 0:
        return c4.load(e2);
      case 1:
        return u3.load(e2);
      case 2:
        return p5.load(e2);
      case 3:
        return z.load(e2);
      case 4:
        return S.load(e2);
      case 5:
        return U2.load(e2);
      case 6:
        return y2.load(e2);
      case 7:
        return b2.load(e2);
      case 8:
        return d2.load(e2);
      case 9:
        return g4.load(e2);
      case 10:
        return T6.load(e2);
      case 255:
        return h5.load(e2);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${r16}`);
    }
  }
  isBool() {
    return this instanceof c4;
  }
  isAddress() {
    return this instanceof S;
  }
  isGeneric() {
    return this instanceof h5;
  }
  isSigner() {
    return this instanceof U2;
  }
  isVector() {
    return this instanceof y2;
  }
  isStruct() {
    return this instanceof b2;
  }
  isU8() {
    return this instanceof u3;
  }
  isU16() {
    return this instanceof d2;
  }
  isU32() {
    return this instanceof g4;
  }
  isU64() {
    return this instanceof p5;
  }
  isU128() {
    return this instanceof z;
  }
  isU256() {
    return this instanceof T6;
  }
};
var c4 = class i6 extends t5 {
  toString() {
    return "bool";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(0);
  }
  static load(e2) {
    return new i6();
  }
};
var u3 = class i7 extends t5 {
  toString() {
    return "u8";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(1);
  }
  static load(e2) {
    return new i7();
  }
};
var d2 = class i8 extends t5 {
  toString() {
    return "u16";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(8);
  }
  static load(e2) {
    return new i8();
  }
};
var g4 = class i9 extends t5 {
  toString() {
    return "u32";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(9);
  }
  static load(e2) {
    return new i9();
  }
};
var p5 = class i10 extends t5 {
  toString() {
    return "u64";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(2);
  }
  static load(e2) {
    return new i10();
  }
};
var z = class i11 extends t5 {
  toString() {
    return "u128";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(3);
  }
  static load(e2) {
    return new i11();
  }
};
var T6 = class i12 extends t5 {
  toString() {
    return "u256";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(10);
  }
  static load(e2) {
    return new i12();
  }
};
var S = class i13 extends t5 {
  toString() {
    return "address";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(4);
  }
  static load(e2) {
    return new i13();
  }
};
var U2 = class i14 extends t5 {
  toString() {
    return "signer";
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(5);
  }
  static load(e2) {
    return new i14();
  }
};
var x3 = class i15 extends t5 {
  constructor(r16) {
    super();
    this.value = r16;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(r16) {
    r16.serializeU32AsUleb128(254);
  }
  static load(r16) {
    let s17 = t5.deserialize(r16);
    return new i15(s17);
  }
};
var h5 = class i16 extends t5 {
  constructor(r16) {
    super();
    this.value = r16;
    if (r16 < 0)
      throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(r16) {
    r16.serializeU32AsUleb128(255), r16.serializeU32(this.value);
  }
  static load(r16) {
    let s17 = r16.deserializeU32();
    return new i16(s17);
  }
};
var y2 = class i17 extends t5 {
  constructor(r16) {
    super();
    this.value = r16;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new i17(new u3());
  }
  serialize(r16) {
    r16.serializeU32AsUleb128(6), this.value.serialize(r16);
  }
  static load(r16) {
    let s17 = t5.deserialize(r16);
    return new i17(s17);
  }
};
var b2 = class i18 extends t5 {
  constructor(r16) {
    super();
    this.value = r16;
  }
  toString() {
    let r16 = "";
    return this.value.typeArgs.length > 0 && (r16 = `<${this.value.typeArgs.map((s17) => s17.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${r16}`;
  }
  serialize(r16) {
    r16.serializeU32AsUleb128(7), this.value.serialize(r16);
  }
  static load(r16) {
    let s17 = o6.deserialize(r16);
    return new i18(s17);
  }
  isTypeTag(r16, s17, l12) {
    return this.value.moduleName.identifier === s17 && this.value.name.identifier === l12 && this.value.address.equals(r16);
  }
  isString() {
    return this.isTypeTag(c.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(c.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(c.ONE, "object", "Object");
  }
};
var o6 = class i19 extends B {
  constructor(e2, r16, s17, l12) {
    super(), this.address = e2, this.moduleName = r16, this.name = s17, this.typeArgs = l12;
  }
  serialize(e2) {
    e2.serialize(this.address), e2.serialize(this.moduleName), e2.serialize(this.name), e2.serializeVector(this.typeArgs);
  }
  static deserialize(e2) {
    let r16 = c.deserialize(e2), s17 = r4.deserialize(e2), l12 = r4.deserialize(e2), f13 = e2.deserializeVector(t5);
    return new i19(r16, s17, l12, f13);
  }
};
function O2() {
  return new o6(c.ONE, new r4("aptos_coin"), new r4("AptosCoin"), []);
}
function E2() {
  return new o6(c.ONE, new r4("string"), new r4("String"), []);
}
function V(i34) {
  return new o6(c.ONE, new r4("option"), new r4("Option"), [i34]);
}
function j2(i34) {
  return new o6(c.ONE, new r4("object"), new r4("Object"), [i34]);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RC5K63LK.mjs
function N3(e2) {
  return !!e2.match(/^[_a-zA-Z0-9]+$/);
}
function V2(e2) {
  return !!e2.match(/\s/);
}
function $2(e2) {
  return !!e2.match(/^T[0-9]+$/);
}
function F2(e2, n24) {
  let i34 = n24;
  for (; i34 < e2.length; i34 += 1) {
    let c10 = e2[i34];
    if (!V2(c10))
      break;
  }
  return i34;
}
var S2 = ((t25) => (t25.InvalidTypeTag = "unknown type", t25.UnexpectedGenericType = "unexpected generic type", t25.UnexpectedTypeArgumentClose = "unexpected '>'", t25.UnexpectedWhitespaceCharacter = "unexpected whitespace character", t25.UnexpectedComma = "unexpected ','", t25.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", t25.MissingTypeArgumentClose = "no matching '>' for '<'", t25.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", t25.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", t25.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", t25.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", t25.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", t25))(S2 || {});
var r5 = class extends Error {
  constructor(n24, i34) {
    super(`Failed to parse typeTag '${n24}', ${i34}`);
  }
};
function Z(e2, n24) {
  let i34 = (n24 == null ? void 0 : n24.allowGenerics) ?? false, c10 = [], o19 = [], p11 = [], T10 = 0, a19 = "", u11 = 1;
  for (; T10 < e2.length; ) {
    let g8 = e2[T10];
    if (g8 === "<")
      c10.push({ savedExpectedTypes: u11, savedStr: a19, savedTypes: p11 }), a19 = "", p11 = [], u11 = 1;
    else if (g8 === ">") {
      if (a19 !== "") {
        let _6 = m5(a19, o19, i34);
        p11.push(_6);
      }
      let s17 = c10.pop();
      if (s17 === void 0)
        throw new r5(e2, "unexpected '>'");
      if (u11 !== p11.length)
        throw new r5(e2, "type argument count doesn't match expected amount");
      let { savedStr: h14, savedTypes: t25, savedExpectedTypes: W5 } = s17;
      o19 = p11, p11 = t25, a19 = h14, u11 = W5;
    } else if (g8 === ",") {
      if (a19.length !== 0) {
        let s17 = m5(a19, o19, i34);
        o19 = [], p11.push(s17), a19 = "", u11 += 1;
      }
    } else if (V2(g8)) {
      let s17 = false;
      if (a19.length !== 0) {
        let t25 = m5(a19, o19, i34);
        o19 = [], p11.push(t25), a19 = "", s17 = true;
      }
      T10 = F2(e2, T10);
      let h14 = e2[T10];
      if (T10 < e2.length && s17 && h14 !== "," && h14 !== ">")
        throw new r5(e2, "unexpected whitespace character");
      continue;
    } else
      a19 += g8;
    T10 += 1;
  }
  if (c10.length > 0)
    throw new r5(e2, "no matching '>' for '<'");
  switch (p11.length) {
    case 0:
      return m5(a19, o19, i34);
    case 1:
      if (a19 === "")
        return p11[0];
      throw new r5(e2, "unexpected ','");
    default:
      throw new r5(e2, "unexpected whitespace character");
  }
}
function m5(e2, n24, i34) {
  switch (e2) {
    case "&signer":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new x3(new U2());
    case "signer":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new U2();
    case "bool":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new c4();
    case "address":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new S();
    case "u8":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new u3();
    case "u16":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new d2();
    case "u32":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new g4();
    case "u64":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new p5();
    case "u128":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new z();
    case "u256":
      if (n24.length > 0)
        throw new r5(e2, "primitive types not expected to have type arguments");
      return new T6();
    case "vector":
      if (n24.length !== 1)
        throw new r5(e2, "vector type expected to have exactly one type argument");
      return new y2(n24[0]);
    default:
      if ($2(e2)) {
        if (i34)
          return new h5(Number(e2.split("T")[1]));
        throw new r5(e2, "unexpected generic type");
      }
      if (!e2.match(/:/))
        throw new r5(e2, "unknown type");
      let c10 = e2.split("::");
      if (c10.length !== 3)
        throw new r5(e2, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      if (!N3(c10[1]))
        throw new r5(e2, "module name must only contain alphanumeric or '_' characters");
      if (!N3(c10[2]))
        throw new r5(e2, "struct name must only contain alphanumeric or '_' characters");
      return new b2(new o6(c.fromString(c10[0]), new r4(c10[1]), new r4(c10[2]), n24));
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IFVMIUMO.mjs
var t6 = class a2 extends B {
  constructor(e2) {
    super(), this.value = i.fromHexInput(e2).toUint8Array();
  }
  serialize(e2) {
    e2.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(e2) {
    e2.serialize(this);
  }
  serializeForScriptFunction(e2) {
    e2.serialize(this);
  }
  static deserialize(e2, s17) {
    let o19 = e2.deserializeFixedBytes(s17);
    return new a2(o19);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BKWJ4G7T.mjs
var d3 = class i20 extends B {
  constructor(e2) {
    super(), A(e2), this.value = e2;
  }
  serialize(e2) {
    e2.serializeBool(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(5), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i20(e2.deserializeBool());
  }
};
var U3 = class i21 extends B {
  constructor(e2) {
    super(), w(e2, 0, t), this.value = e2;
  }
  serialize(e2) {
    e2.serializeU8(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(0), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i21(e2.deserializeU8());
  }
};
var p6 = class i22 extends B {
  constructor(e2) {
    super(), w(e2, 0, n2), this.value = e2;
  }
  serialize(e2) {
    e2.serializeU16(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(6), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i22(e2.deserializeU16());
  }
};
var b3 = class i23 extends B {
  constructor(e2) {
    super(), w(e2, 0, U), this.value = e2;
  }
  serialize(e2) {
    e2.serializeU32(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(7), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i23(e2.deserializeU32());
  }
};
var y3 = class i24 extends B {
  constructor(e2) {
    super(), w(e2, BigInt(0), _), this.value = BigInt(e2);
  }
  serialize(e2) {
    e2.serializeU64(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(1), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i24(e2.deserializeU64());
  }
};
var m6 = class i25 extends B {
  constructor(e2) {
    super(), w(e2, BigInt(0), o), this.value = BigInt(e2);
  }
  serialize(e2) {
    e2.serializeU128(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(2), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i25(e2.deserializeU128());
  }
};
var B2 = class i26 extends B {
  constructor(e2) {
    super(), w(e2, BigInt(0), i2), this.value = BigInt(e2);
  }
  serialize(e2) {
    e2.serializeU256(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    e2.serializeU32AsUleb128(8), e2.serialize(this);
  }
  static deserialize(e2) {
    return new i26(e2.deserializeU256());
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VZJ62XF7.mjs
var t7 = class n6 extends B {
  constructor(e2) {
    super(), this.values = e2;
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    if (!(this.values[0] instanceof U3) && this.values[0] !== void 0)
      throw new Error("Script function arguments only accept u8 vectors");
    e2.serializeU32AsUleb128(4), e2.serialize(this);
  }
  static U8(e2) {
    let r16;
    if (Array.isArray(e2) && typeof e2[0] == "number")
      r16 = e2;
    else if (typeof e2 == "string") {
      let i34 = i.fromHexInput(e2);
      r16 = Array.from(i34.toUint8Array());
    } else if (e2 instanceof Uint8Array)
      r16 = Array.from(e2);
    else
      throw new Error("Invalid input type");
    return new n6(r16.map((i34) => new U3(i34)));
  }
  static U16(e2) {
    return new n6(e2.map((r16) => new p6(r16)));
  }
  static U32(e2) {
    return new n6(e2.map((r16) => new b3(r16)));
  }
  static U64(e2) {
    return new n6(e2.map((r16) => new y3(r16)));
  }
  static U128(e2) {
    return new n6(e2.map((r16) => new m6(r16)));
  }
  static U256(e2) {
    return new n6(e2.map((r16) => new B2(r16)));
  }
  static Bool(e2) {
    return new n6(e2.map((r16) => new d3(r16)));
  }
  static MoveString(e2) {
    return new n6(e2.map((r16) => new a3(r16)));
  }
  serialize(e2) {
    e2.serializeVector(this.values);
  }
  static deserialize(e2, r16) {
    let i34 = e2.deserializeUleb128AsU32(), p11 = new Array();
    for (let y12 = 0; y12 < i34; y12 += 1)
      p11.push(r16.deserialize(e2));
    return new n6(p11);
  }
};
var a3 = class n7 extends B {
  constructor(e2) {
    super(), this.value = e2;
  }
  serialize(e2) {
    e2.serializeStr(this.value);
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  serializeForScriptFunction(e2) {
    let r16 = this.bcsToBytes().slice(1);
    t7.U8(r16).serializeForScriptFunction(e2);
  }
  static deserialize(e2) {
    return new n7(e2.deserializeStr());
  }
};
var z2 = class n8 extends B {
  constructor(e2) {
    super(), typeof e2 < "u" && e2 !== null ? this.vec = new t7([e2]) : this.vec = new t7([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(e2) {
    let r16 = this.bcsToBytes();
    e2.serializeBytes(r16);
  }
  unwrap() {
    if (this.isSome())
      return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(e2) {
    this.vec.serialize(e2);
  }
  static U8(e2) {
    return new n8(e2 != null ? new U3(e2) : void 0);
  }
  static U16(e2) {
    return new n8(e2 != null ? new p6(e2) : void 0);
  }
  static U32(e2) {
    return new n8(e2 != null ? new b3(e2) : void 0);
  }
  static U64(e2) {
    return new n8(e2 != null ? new y3(e2) : void 0);
  }
  static U128(e2) {
    return new n8(e2 != null ? new m6(e2) : void 0);
  }
  static U256(e2) {
    return new n8(e2 != null ? new B2(e2) : void 0);
  }
  static Bool(e2) {
    return new n8(e2 != null ? new d3(e2) : void 0);
  }
  static MoveString(e2) {
    return new n8(e2 != null ? new a3(e2) : void 0);
  }
  static deserialize(e2, r16) {
    let i34 = t7.deserialize(e2, r16);
    return new n8(i34.values[0]);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-K5XJKIFT.mjs
function M(n24) {
  return typeof n24 == "boolean";
}
function D2(n24) {
  return typeof n24 == "string";
}
function N4(n24) {
  return typeof n24 == "number";
}
function P(n24) {
  return typeof n24 == "number" || typeof n24 == "bigint" || typeof n24 == "string";
}
function w4(n24) {
  return n24 == null;
}
function G3(n24) {
  return A6(n24) || x4(n24) || S3(n24) || B3(n24) || U4(n24) || I(n24) || b4(n24) || T7(n24) || E3(n24) || d4(n24) || n24 instanceof t7 || n24 instanceof z2;
}
function A6(n24) {
  return n24 instanceof d3;
}
function T7(n24) {
  return n24 instanceof c;
}
function E3(n24) {
  return n24 instanceof a3;
}
function d4(n24) {
  return n24 instanceof t6;
}
function x4(n24) {
  return n24 instanceof U3;
}
function S3(n24) {
  return n24 instanceof p6;
}
function B3(n24) {
  return n24 instanceof b3;
}
function U4(n24) {
  return n24 instanceof y3;
}
function I(n24) {
  return n24 instanceof m6;
}
function b4(n24) {
  return n24 instanceof B2;
}
function $3(n24) {
  return "bytecode" in n24;
}
function R2(n24, t25) {
  throw new Error(`Type mismatch for argument ${t25}, expected '${n24}'`);
}
function W(n24) {
  let t25 = n24.params.findIndex((e2) => e2 !== "signer" && e2 !== "&signer");
  return t25 < 0 ? n24.params.length : t25;
}
function L2(n24) {
  let t25 = n24.split("::");
  if (t25.length !== 3)
    throw new Error(`Invalid function ${n24}`);
  let e2 = t25[0], F6 = t25[1], l12 = t25[2];
  return { moduleAddress: e2, moduleName: F6, functionName: l12 };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GTCDSGOA.mjs
var t8 = class extends B {
  toString() {
    let n24 = this.toUint8Array();
    return i.fromHexInput(n24).toString();
  }
};
var a4 = class extends t8 {
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CUWAGKEP.mjs
var o7 = class extends B {
  toString() {
    let i34 = this.toUint8Array();
    return i.fromHexInput(i34).toString();
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i34 = 0; i34 < pad.length; i34++)
      pad[i34] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i34 = 0; i34 < pad.length; i34++)
      pad[i34] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h14 = isLE3 ? 4 : 0;
  const l12 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h14, wh, isLE3);
  view.setUint32(byteOffset + l12, wl, isLE3);
}
var Chi = (a19, b10, c10) => a19 & b10 ^ ~a19 & c10;
var Maj = (a19, b10, c10) => a19 & b10 ^ a19 & c10 ^ b10 & c10;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i34 = pos; i34 < blockLen; i34++)
      buffer[i34] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i34 = 0; i34 < outLen; i34++)
      oview.setUint32(4 * i34, state[i34], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n24, le = false) {
  if (le)
    return { h: Number(n24 & U32_MASK64), l: Number(n24 >> _32n & U32_MASK64) };
  return { h: Number(n24 >> _32n & U32_MASK64) | 0, l: Number(n24 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i34 = 0; i34 < lst.length; i34++) {
    const { h: h14, l: l12 } = fromBig(lst[i34], le);
    [Ah[i34], Al[i34]] = [h14, l12];
  }
  return [Ah, Al];
}
var toBig = (h14, l12) => BigInt(h14 >>> 0) << _32n | BigInt(l12 >>> 0);
var shrSH = (h14, _l, s17) => h14 >>> s17;
var shrSL = (h14, l12, s17) => h14 << 32 - s17 | l12 >>> s17;
var rotrSH = (h14, l12, s17) => h14 >>> s17 | l12 << 32 - s17;
var rotrSL = (h14, l12, s17) => h14 << 32 - s17 | l12 >>> s17;
var rotrBH = (h14, l12, s17) => h14 << 64 - s17 | l12 >>> s17 - 32;
var rotrBL = (h14, l12, s17) => h14 >>> s17 - 32 | l12 << 64 - s17;
var rotr32H = (_h, l12) => l12;
var rotr32L = (h14, _l) => h14;
var rotlSH = (h14, l12, s17) => h14 << s17 | l12 >>> 32 - s17;
var rotlSL = (h14, l12, s17) => l12 << s17 | h14 >>> 32 - s17;
var rotlBH = (h14, l12, s17) => l12 << s17 - 32 | h14 >>> 64 - s17;
var rotlBL = (h14, l12, s17) => h14 << s17 - 32 | l12 >>> 64 - s17;
function add(Ah, Al, Bh, Bl) {
  const l12 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l12 / 2 ** 32 | 0) | 0, l: l12 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n24) => BigInt(n24))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i34 = 0; i34 < 16; i34++, offset += 4) {
      SHA512_W_H[i34] = view.getUint32(offset);
      SHA512_W_L[i34] = view.getUint32(offset += 4);
    }
    for (let i34 = 16; i34 < 80; i34++) {
      const W15h = SHA512_W_H[i34 - 15] | 0;
      const W15l = SHA512_W_L[i34 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i34 - 2] | 0;
      const W2l = SHA512_W_L[i34 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i34 - 7], SHA512_W_L[i34 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i34 - 7], SHA512_W_H[i34 - 16]);
      SHA512_W_H[i34] = SUMh | 0;
      SHA512_W_L[i34] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i34 = 0; i34 < 80; i34++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i34], SHA512_W_L[i34]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i34], SHA512_W_H[i34]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js
function number2(n24) {
  if (!Number.isSafeInteger(n24) || n24 < 0)
    throw new Error(`Wrong positive integer: ${n24}`);
}
function isBytes2(a19) {
  return a19 instanceof Uint8Array || a19 != null && typeof a19 === "object" && a19.constructor.name === "Uint8Array";
}
function bytes2(b10, ...lengths) {
  if (!isBytes2(b10))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b10.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b10.length}`);
}
function hash2(hash3) {
  if (typeof hash3 !== "function" || typeof hash3.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number2(hash3.outputLen);
  number2(hash3.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js
function isBytes3(a19) {
  return a19 instanceof Uint8Array || a19 != null && typeof a19 === "object" && a19.constructor.name === "Uint8Array";
}
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (_6, i34) => i34.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  if (!isBytes3(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr2 = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr2.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash2 {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash2(hash3);
    const key = toBytes2(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i34 = 0; i34 < pad.length; i34++)
      pad[i34] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i34 = 0; i34 < pad.length; i34++)
      pad[i34] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists2(this);
    bytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash3, key, message) => new HMAC2(hash3, key).update(message).digest();
hmac2.create = (hash3, key) => new HMAC2(hash3, key);

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash3, _password, _salt, _opts) {
  hash2(hash3);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c10, dkLen, asyncTick } = opts;
  number2(c10);
  number2(dkLen);
  number2(asyncTick);
  if (c10 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes2(_password);
  const salt2 = toBytes2(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt2);
  return { c: c10, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u11) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u11.fill(0);
  return DK;
}
function pbkdf2(hash3, password, salt2, opts) {
  const { c: c10, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView2(arr);
  const u11 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u11);
    Ti.set(u11.subarray(0, Ti.length));
    for (let ui = 1; ui < c10; ui++) {
      PRF._cloneInto(prfW).update(u11).digestInto(u11);
      for (let i34 = 0; i34 < Ti.length; i34++)
        Ti[i34] ^= u11[i34];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u11);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h14 = isLE3 ? 4 : 0;
  const l12 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h14, wh, isLE3);
  view.setUint32(byteOffset + l12, wl, isLE3);
}
var SHA2 = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    exists2(this);
    const { view, buffer, blockLen } = this;
    data = toBytes2(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists2(this);
    output2(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i34 = pos; i34 < blockLen; i34++)
      buffer[i34] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i34 = 0; i34 < outLen; i34++)
      oview.setUint32(4 * i34, state[i34], isLE3);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a19, b10, c10) => a19 & b10 ^ ~a19 & c10;
var Maj2 = (a19, b10, c10) => a19 & b10 ^ a19 & c10 ^ b10 & c10;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A13, B: B6, C: C6, D: D7, E: E7, F: F6, G: G7, H: H3 } = this;
    return [A13, B6, C6, D7, E7, F6, G7, H3];
  }
  // prettier-ignore
  set(A13, B6, C6, D7, E7, F6, G7, H3) {
    this.A = A13 | 0;
    this.B = B6 | 0;
    this.C = C6 | 0;
    this.D = D7 | 0;
    this.E = E7 | 0;
    this.F = F6 | 0;
    this.G = G7 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i34 = 0; i34 < 16; i34++, offset += 4)
      SHA256_W[i34] = view.getUint32(offset, false);
    for (let i34 = 16; i34 < 64; i34++) {
      const W15 = SHA256_W[i34 - 15];
      const W22 = SHA256_W[i34 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W22, 17) ^ rotr2(W22, 19) ^ W22 >>> 10;
      SHA256_W[i34] = s1 + SHA256_W[i34 - 7] + s0 + SHA256_W[i34 - 16] | 0;
    }
    let { A: A13, B: B6, C: C6, D: D7, E: E7, F: F6, G: G7, H: H3 } = this;
    for (let i34 = 0; i34 < 64; i34++) {
      const sigma1 = rotr2(E7, 6) ^ rotr2(E7, 11) ^ rotr2(E7, 25);
      const T1 = H3 + sigma1 + Chi2(E7, F6, G7) + SHA256_K[i34] + SHA256_W[i34] | 0;
      const sigma0 = rotr2(A13, 2) ^ rotr2(A13, 13) ^ rotr2(A13, 22);
      const T22 = sigma0 + Maj2(A13, B6, C6) | 0;
      H3 = G7;
      G7 = F6;
      F6 = E7;
      E7 = D7 + T1 | 0;
      D7 = C6;
      C6 = B6;
      B6 = A13;
      A13 = T1 + T22 | 0;
    }
    A13 = A13 + this.A | 0;
    B6 = B6 + this.B | 0;
    C6 = C6 + this.C | 0;
    D7 = D7 + this.D | 0;
    E7 = E7 + this.E | 0;
    F6 = F6 + this.F | 0;
    G7 = G7 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A13, B6, C6, D7, E7, F6, G7, H3);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor2(() => new SHA256());
var sha224 = wrapConstructor2(() => new SHA224());

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
function fromBig2(n24, le = false) {
  if (le)
    return { h: Number(n24 & U32_MASK642), l: Number(n24 >> _32n2 & U32_MASK642) };
  return { h: Number(n24 >> _32n2 & U32_MASK642) | 0, l: Number(n24 & U32_MASK642) | 0 };
}
function split2(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i34 = 0; i34 < lst.length; i34++) {
    const { h: h14, l: l12 } = fromBig2(lst[i34], le);
    [Ah[i34], Al[i34]] = [h14, l12];
  }
  return [Ah, Al];
}
var toBig2 = (h14, l12) => BigInt(h14 >>> 0) << _32n2 | BigInt(l12 >>> 0);
var shrSH2 = (h14, _l, s17) => h14 >>> s17;
var shrSL2 = (h14, l12, s17) => h14 << 32 - s17 | l12 >>> s17;
var rotrSH2 = (h14, l12, s17) => h14 >>> s17 | l12 << 32 - s17;
var rotrSL2 = (h14, l12, s17) => h14 << 32 - s17 | l12 >>> s17;
var rotrBH2 = (h14, l12, s17) => h14 << 64 - s17 | l12 >>> s17 - 32;
var rotrBL2 = (h14, l12, s17) => h14 >>> s17 - 32 | l12 << 64 - s17;
var rotr32H2 = (_h, l12) => l12;
var rotr32L2 = (h14, _l) => h14;
var rotlSH2 = (h14, l12, s17) => h14 << s17 | l12 >>> 32 - s17;
var rotlSL2 = (h14, l12, s17) => l12 << s17 | h14 >>> 32 - s17;
var rotlBH2 = (h14, l12, s17) => l12 << s17 - 32 | h14 >>> 64 - s17;
var rotlBL2 = (h14, l12, s17) => h14 << s17 - 32 | l12 >>> 64 - s17;
function add2(Ah, Al, Bh, Bl) {
  const l12 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l12 / 2 ** 32 | 0) | 0, l: l12 | 0 };
}
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u642 = {
  fromBig: fromBig2,
  split: split2,
  toBig: toBig2,
  shrSH: shrSH2,
  shrSL: shrSL2,
  rotrSH: rotrSH2,
  rotrSL: rotrSL2,
  rotrBH: rotrBH2,
  rotrBL: rotrBL2,
  rotr32H: rotr32H2,
  rotr32L: rotr32L2,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add: add2,
  add3L: add3L2,
  add3H: add3H2,
  add4L: add4L2,
  add4H: add4H2,
  add5H: add5H2,
  add5L: add5L2
};
var u64_default2 = u642;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh2, SHA512_Kl2] = (() => u64_default2.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n24) => BigInt(n24))))();
var SHA512_W_H2 = new Uint32Array(80);
var SHA512_W_L2 = new Uint32Array(80);
var SHA5122 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i34 = 0; i34 < 16; i34++, offset += 4) {
      SHA512_W_H2[i34] = view.getUint32(offset);
      SHA512_W_L2[i34] = view.getUint32(offset += 4);
    }
    for (let i34 = 16; i34 < 80; i34++) {
      const W15h = SHA512_W_H2[i34 - 15] | 0;
      const W15l = SHA512_W_L2[i34 - 15] | 0;
      const s0h = u64_default2.rotrSH(W15h, W15l, 1) ^ u64_default2.rotrSH(W15h, W15l, 8) ^ u64_default2.shrSH(W15h, W15l, 7);
      const s0l = u64_default2.rotrSL(W15h, W15l, 1) ^ u64_default2.rotrSL(W15h, W15l, 8) ^ u64_default2.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i34 - 2] | 0;
      const W2l = SHA512_W_L2[i34 - 2] | 0;
      const s1h = u64_default2.rotrSH(W2h, W2l, 19) ^ u64_default2.rotrBH(W2h, W2l, 61) ^ u64_default2.shrSH(W2h, W2l, 6);
      const s1l = u64_default2.rotrSL(W2h, W2l, 19) ^ u64_default2.rotrBL(W2h, W2l, 61) ^ u64_default2.shrSL(W2h, W2l, 6);
      const SUMl = u64_default2.add4L(s0l, s1l, SHA512_W_L2[i34 - 7], SHA512_W_L2[i34 - 16]);
      const SUMh = u64_default2.add4H(SUMl, s0h, s1h, SHA512_W_H2[i34 - 7], SHA512_W_H2[i34 - 16]);
      SHA512_W_H2[i34] = SUMh | 0;
      SHA512_W_L2[i34] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i34 = 0; i34 < 80; i34++) {
      const sigma1h = u64_default2.rotrSH(Eh, El, 14) ^ u64_default2.rotrSH(Eh, El, 18) ^ u64_default2.rotrBH(Eh, El, 41);
      const sigma1l = u64_default2.rotrSL(Eh, El, 14) ^ u64_default2.rotrSL(Eh, El, 18) ^ u64_default2.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default2.add5L(Hl, sigma1l, CHIl, SHA512_Kl2[i34], SHA512_W_L2[i34]);
      const T1h = u64_default2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i34], SHA512_W_H2[i34]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default2.rotrSH(Ah, Al, 28) ^ u64_default2.rotrBH(Ah, Al, 34) ^ u64_default2.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default2.rotrSL(Ah, Al, 28) ^ u64_default2.rotrBL(Ah, Al, 34) ^ u64_default2.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default2.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default2.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default2.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default2.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H2.fill(0);
    SHA512_W_L2.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_2242 = class extends SHA5122 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_2562 = class extends SHA5122 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA3842 = class extends SHA5122 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha5122 = wrapConstructor2(() => new SHA5122());
var sha512_2242 = wrapConstructor2(() => new SHA512_2242());
var sha512_2562 = wrapConstructor2(() => new SHA512_2562());
var sha3842 = wrapConstructor2(() => new SHA3842());

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/base/lib/esm/index.js
function assertNumber(n24) {
  if (!Number.isSafeInteger(n24))
    throw new Error(`Wrong integer: ${n24}`);
}
function isBytes4(a19) {
  return a19 instanceof Uint8Array || a19 != null && typeof a19 === "object" && a19.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id = (a19) => a19;
  const wrap = (a19, b10) => (c10) => a19(b10(c10));
  const encode3 = args.map((x9) => x9.encode).reduceRight(wrap, id);
  const decode = args.map((x9) => x9.decode).reduce(wrap, id);
  return { encode: encode3, decode };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i34) => {
        assertNumber(i34);
        if (i34 < 0 || i34 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i34} (alphabet: ${alphabet2.length})`);
        return alphabet2[i34];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i34 of from)
        if (typeof i34 !== "string")
          throw new Error(`join.encode: non-string input=${i34}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i34 of data)
        if (typeof i34 !== "string")
          throw new Error(`padding.encode: non-string input=${i34}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i34 of input)
        if (typeof i34 !== "string")
          throw new Error(`padding.decode: non-string input=${i34}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn) {
  if (typeof fn !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d10) => {
    assertNumber(d10);
    if (d10 < 0 || d10 >= from)
      throw new Error(`Wrong integer: ${d10}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i34 = pos; i34 < digits.length; i34++) {
      const digit = digits[i34];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i34] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i34;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i34 = 0; i34 < data.length - 1 && data[i34] === 0; i34++)
    res.push(0);
  return res.reverse();
}
var gcd = (
  /* @__NO_SIDE_EFFECTS__ */
  (a19, b10) => !b10 ? a19 : gcd(b10, a19 % b10)
);
var radix2carry = (
  /*@__NO_SIDE_EFFECTS__ */
  (from, to) => from + (to - gcd(from, to))
);
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n24 of data) {
    assertNumber(n24);
    if (n24 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n24} from=${from}`);
    carry = carry << from | n24;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  assertNumber(num);
  return {
    encode: (bytes3) => {
      if (!isBytes4(bytes3))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes3), 2 ** 8, num);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes3) => {
      if (!isBytes4(bytes3))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes3), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn) {
  if (typeof fn !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn.apply(null, args);
    } catch (e2) {
    }
  };
}
function checksum(len, fn) {
  assertNumber(len);
  if (typeof fn !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!isBytes4(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes4(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i34 = 0; i34 < len; i34++)
        if (newChecksum[i34] !== oldChecksum[i34])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s17) => s17.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2563) => chain(checksum(4, (data) => sha2563(sha2563(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b10 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i34 = 0; i34 < POLYMOD_GENERATORS.length; i34++) {
    if ((b10 >> i34 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i34];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i34 = 0; i34 < len; i34++) {
    const c10 = prefix.charCodeAt(i34);
    if (c10 < 33 || c10 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c10 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i34 = 0; i34 < len; i34++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i34) & 31;
  for (let v6 of words)
    chk = bech32Polymod(chk) ^ v6;
  for (let i34 = 0; i34 < 6; i34++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode3(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0)
      throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode);
  function decodeToBytes(str) {
    const { prefix, words } = decode(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode3, decode, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s17) => {
  if (typeof s17 !== "string" || s17.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s17} with length ${s17.length}`);
  return s17.toLowerCase();
}));

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha5122, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LR65XHSF.mjs
var d5 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var m7 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var y4 = ((t25) => (t25.ED25519 = "ed25519 seed", t25))(y4 || {});
var g5 = 2147483648;
function D3(e2) {
  return m7.test(e2);
}
function E4(e2) {
  return d5.test(e2);
}
var A7 = (e2, t25) => {
  let r16 = hmac.create(sha512, e2).update(t25).digest();
  return { key: r16.slice(0, 32), chainCode: r16.slice(32) };
};
var f6 = ({ key: e2, chainCode: t25 }, r16) => {
  let n24 = new ArrayBuffer(4);
  new DataView(n24).setUint32(0, r16);
  let o19 = new Uint8Array(n24), s17 = new Uint8Array([0]), a19 = new Uint8Array([...s17, ...e2, ...o19]);
  return A7(t25, a19);
};
var x5 = (e2) => e2.replace("'", "");
var U5 = (e2) => e2.split("/").slice(1).map(x5);
var h6 = (e2) => {
  let t25 = e2.trim().split(/\s+/).map((r16) => r16.toLowerCase()).join(" ");
  return mnemonicToSeedSync(t25);
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R6 = _1n, x9 = 1, y12 = 0; round < 24; round++) {
  [x9, y12] = [y12, (2 * x9 + 3 * y12) % 5];
  SHA3_PI.push(2 * (5 * y12 + x9));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t25 = _0n;
  for (let j4 = 0; j4 < 7; j4++) {
    R6 = (R6 << _1n ^ (R6 >> _7n) * _0x71n) % _256n;
    if (R6 & _2n)
      t25 ^= _1n << (_1n << BigInt(j4)) - _1n;
  }
  _SHA3_IOTA.push(t25);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h14, l12, s17) => s17 > 32 ? rotlBH(h14, l12, s17) : rotlSH(h14, l12, s17);
var rotlL = (h14, l12, s17) => s17 > 32 ? rotlBL(h14, l12, s17) : rotlSL(h14, l12, s17);
function keccakP(s17, rounds = 24) {
  const B6 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x9 = 0; x9 < 10; x9++)
      B6[x9] = s17[x9] ^ s17[x9 + 10] ^ s17[x9 + 20] ^ s17[x9 + 30] ^ s17[x9 + 40];
    for (let x9 = 0; x9 < 10; x9 += 2) {
      const idx1 = (x9 + 8) % 10;
      const idx0 = (x9 + 2) % 10;
      const B0 = B6[idx0];
      const B1 = B6[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B6[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B6[idx1 + 1];
      for (let y12 = 0; y12 < 50; y12 += 10) {
        s17[x9 + y12] ^= Th;
        s17[x9 + y12 + 1] ^= Tl;
      }
    }
    let curH = s17[2];
    let curL = s17[3];
    for (let t25 = 0; t25 < 24; t25++) {
      const shift = SHA3_ROTL[t25];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t25];
      curH = s17[PI];
      curL = s17[PI + 1];
      s17[PI] = Th;
      s17[PI + 1] = Tl;
    }
    for (let y12 = 0; y12 < 50; y12 += 10) {
      for (let x9 = 0; x9 < 10; x9++)
        B6[x9] = s17[y12 + x9];
      for (let x9 = 0; x9 < 10; x9++)
        s17[y12 + x9] ^= ~B6[(x9 + 2) % 10] & B6[(x9 + 4) % 10];
    }
    s17[0] ^= SHA3_IOTA_H[round];
    s17[1] ^= SHA3_IOTA_L[round];
  }
  B6.fill(0);
}
var Keccak = class extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i34 = 0; i34 < take; i34++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes3) {
    number(bytes3);
    return this.xofInto(new Uint8Array(bytes3));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RZNFFGTD.mjs
var r6 = class r7 extends B {
  constructor(t25) {
    super();
    let { data: e2 } = t25, i34 = i.fromHexInput(e2);
    if (i34.toUint8Array().length !== r7.LENGTH)
      throw new Error(`Authentication Key length should be ${r7.LENGTH}`);
    this.data = i34;
  }
  serialize(t25) {
    t25.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(t25) {
    let e2 = t25.deserializeFixedBytes(r7.LENGTH);
    return new r7({ data: e2 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromSchemeAndBytes(t25) {
    let { scheme: e2, input: i34 } = t25, u11 = i.fromHexInput(i34).toUint8Array(), h14 = new Uint8Array([...u11, e2]), a19 = sha3_256.create();
    a19.update(h14);
    let y12 = a19.digest();
    return new r7({ data: y12 });
  }
  static fromPublicKeyAndScheme(t25) {
    let { publicKey: e2 } = t25;
    return e2.authKey();
  }
  static fromPublicKey(t25) {
    let { publicKey: e2 } = t25;
    return e2.authKey();
  }
  derivedAddress() {
    return new c(this.data.toUint8Array());
  }
};
r6.LENGTH = 32;
var c5 = r6;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NUBFOYQZ.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var n9 = class n10 extends a4 {
  constructor(e2) {
    super();
    let t25 = i.fromHexInput(e2);
    if (t25.toUint8Array().length !== n10.LENGTH)
      throw new Error(`PublicKey length should be ${n10.LENGTH}`);
    this.key = t25;
  }
  verifySignature(e2) {
    let { message: t25, signature: s17 } = e2;
    if (!(s17 instanceof y5))
      return false;
    let c10 = i.fromHexInput(t25).toUint8Array(), u11 = s17.toUint8Array(), l12 = this.key.toUint8Array();
    return import_tweetnacl.default.sign.detached.verify(c10, u11, l12);
  }
  authKey() {
    return c5.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e2) {
    e2.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e2) {
    let t25 = e2.deserializeBytes();
    return new n10(t25);
  }
  static isPublicKey(e2) {
    return e2 instanceof n10;
  }
};
n9.LENGTH = 32;
var m8 = n9;
var r8 = class r9 extends B {
  constructor(e2) {
    super();
    let t25 = i.fromHexInput(e2);
    if (t25.toUint8Array().length !== r9.LENGTH)
      throw new Error(`PrivateKey length should be ${r9.LENGTH}`);
    this.signingKeyPair = import_tweetnacl.default.sign.keyPair.fromSeed(t25.toUint8Array().slice(0, r9.LENGTH));
  }
  static generate() {
    let e2 = import_tweetnacl.default.sign.keyPair();
    return new r9(e2.secretKey.slice(0, r9.LENGTH));
  }
  static fromDerivationPath(e2, t25) {
    if (!E4(e2))
      throw new Error(`Invalid derivation path ${e2}`);
    return r9.fromDerivationPathInner(e2, h6(t25));
  }
  static fromDerivationPathInner(e2, t25, s17 = g5) {
    let { key: c10, chainCode: u11 } = A7(r9.SLIP_0010_SEED, t25), l12 = U5(e2).map((d10) => parseInt(d10, 10)), { key: x9 } = l12.reduce((d10, U11) => f6(d10, U11 + s17), { key: c10, chainCode: u11 });
    return new r9(x9);
  }
  publicKey() {
    let e2 = this.signingKeyPair.publicKey;
    return new m8(e2);
  }
  sign(e2) {
    let t25 = i.fromHexInput(e2).toUint8Array(), s17 = import_tweetnacl.default.sign.detached(t25, this.signingKeyPair.secretKey);
    return new y5(s17);
  }
  toUint8Array() {
    return this.signingKeyPair.secretKey.slice(0, r9.LENGTH);
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  serialize(e2) {
    e2.serializeBytes(this.toUint8Array());
  }
  static deserialize(e2) {
    let t25 = e2.deserializeBytes();
    return new r9(t25);
  }
  static isPrivateKey(e2) {
    return e2 instanceof r9;
  }
};
r8.LENGTH = 32, r8.SLIP_0010_SEED = "ed25519 seed";
var S4 = r8;
var a5 = class a6 extends o7 {
  constructor(e2) {
    super();
    let t25 = i.fromHexInput(e2);
    if (t25.toUint8Array().length !== a6.LENGTH)
      throw new Error(`Signature length should be ${a6.LENGTH}`);
    this.data = t25;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e2) {
    e2.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e2) {
    let t25 = e2.deserializeBytes();
    return new a6(t25);
  }
};
a5.LENGTH = 64;
var y5 = a5;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QJ2OLGAW.mjs
var o9 = class o10 extends a4 {
  constructor(r16) {
    super();
    let { publicKeys: e2, threshold: t25 } = r16;
    if (e2.length > o10.MAX_KEYS || e2.length < o10.MIN_KEYS)
      throw new Error(`Must have between ${o10.MIN_KEYS} and ${o10.MAX_KEYS} public keys, inclusive`);
    if (t25 < o10.MIN_THRESHOLD || t25 > e2.length)
      throw new Error(`Threshold must be between ${o10.MIN_THRESHOLD} and ${e2.length}, inclusive`);
    this.publicKeys = e2, this.threshold = t25;
  }
  verifySignature(r16) {
    let { message: e2, signature: t25 } = r16;
    if (!(t25 instanceof y6))
      return false;
    let s17 = [];
    for (let i34 = 0; i34 < 4; i34 += 1)
      for (let n24 = 0; n24 < 8; n24 += 1)
        if ((t25.bitmap[i34] & 1 << 7 - n24) !== 0) {
          let u11 = i34 * 8 + n24;
          s17.push(u11);
        }
    if (s17.length !== t25.signatures.length)
      throw new Error("Bitmap and signatures length mismatch");
    if (s17.length < this.threshold)
      throw new Error("Not enough signatures");
    for (let i34 = 0; i34 < s17.length; i34 += 1)
      if (!this.publicKeys[s17[i34]].verifySignature({ message: e2, signature: t25.signatures[i34] }))
        return false;
    return true;
  }
  authKey() {
    return c5.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
  }
  toUint8Array() {
    let r16 = new Uint8Array(this.publicKeys.length * m8.LENGTH + 1);
    return this.publicKeys.forEach((e2, t25) => {
      r16.set(e2.toUint8Array(), t25 * m8.LENGTH);
    }), r16[this.publicKeys.length * m8.LENGTH] = this.threshold, r16;
  }
  serialize(r16) {
    r16.serializeBytes(this.toUint8Array());
  }
  static deserialize(r16) {
    let e2 = r16.deserializeBytes(), t25 = e2[e2.length - 1], s17 = [];
    for (let i34 = 0; i34 < e2.length - 1; i34 += m8.LENGTH) {
      let n24 = i34;
      s17.push(new m8(e2.subarray(n24, n24 + m8.LENGTH)));
    }
    return new o10({ publicKeys: s17, threshold: t25 });
  }
};
o9.MAX_KEYS = 32, o9.MIN_KEYS = 2, o9.MIN_THRESHOLD = 1;
var d6 = o9;
var a7 = class a8 extends o7 {
  constructor(r16) {
    super();
    let { signatures: e2, bitmap: t25 } = r16;
    if (e2.length > a8.MAX_SIGNATURES_SUPPORTED)
      throw new Error(`The number of signatures cannot be greater than ${a8.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = e2, !(t25 instanceof Uint8Array))
      this.bitmap = a8.createBitmap({ bits: t25 });
    else {
      if (t25.length !== a8.BITMAP_LEN)
        throw new Error(`"bitmap" length should be ${a8.BITMAP_LEN}`);
      this.bitmap = t25;
    }
  }
  toUint8Array() {
    let r16 = new Uint8Array(this.signatures.length * y5.LENGTH + a8.BITMAP_LEN);
    return this.signatures.forEach((e2, t25) => {
      r16.set(e2.toUint8Array(), t25 * y5.LENGTH);
    }), r16.set(this.bitmap, this.signatures.length * y5.LENGTH), r16;
  }
  serialize(r16) {
    r16.serializeBytes(this.toUint8Array());
  }
  static deserialize(r16) {
    let e2 = r16.deserializeBytes(), t25 = e2.subarray(e2.length - 4), s17 = [];
    for (let i34 = 0; i34 < e2.length - t25.length; i34 += y5.LENGTH) {
      let n24 = i34;
      s17.push(new y5(e2.subarray(n24, n24 + y5.LENGTH)));
    }
    return new a8({ signatures: s17, bitmap: t25 });
  }
  static createBitmap(r16) {
    let { bits: e2 } = r16, t25 = 128, s17 = new Uint8Array([0, 0, 0, 0]), i34 = /* @__PURE__ */ new Set();
    return e2.forEach((n24, c10) => {
      if (n24 >= a8.MAX_SIGNATURES_SUPPORTED)
        throw new Error(`Cannot have a signature larger than ${a8.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (i34.has(n24))
        throw new Error("Duplicate bits detected.");
      if (c10 > 0 && n24 <= e2[c10 - 1])
        throw new Error("The bits need to be sorted in ascending order.");
      i34.add(n24);
      let u11 = Math.floor(n24 / 8), b10 = s17[u11];
      b10 |= t25 >> n24 % 8, s17[u11] = b10;
    }), s17;
  }
};
a7.MAX_SIGNATURES_SUPPORTED = 32, a7.BITMAP_LEN = 4;
var y6 = a7;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A13, B: B6, C: C6, D: D7, E: E7, F: F6, G: G7, H: H3 } = this;
    return [A13, B6, C6, D7, E7, F6, G7, H3];
  }
  // prettier-ignore
  set(A13, B6, C6, D7, E7, F6, G7, H3) {
    this.A = A13 | 0;
    this.B = B6 | 0;
    this.C = C6 | 0;
    this.D = D7 | 0;
    this.E = E7 | 0;
    this.F = F6 | 0;
    this.G = G7 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i34 = 0; i34 < 16; i34++, offset += 4)
      SHA256_W2[i34] = view.getUint32(offset, false);
    for (let i34 = 16; i34 < 64; i34++) {
      const W15 = SHA256_W2[i34 - 15];
      const W22 = SHA256_W2[i34 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W2[i34] = s1 + SHA256_W2[i34 - 7] + s0 + SHA256_W2[i34 - 16] | 0;
    }
    let { A: A13, B: B6, C: C6, D: D7, E: E7, F: F6, G: G7, H: H3 } = this;
    for (let i34 = 0; i34 < 64; i34++) {
      const sigma1 = rotr(E7, 6) ^ rotr(E7, 11) ^ rotr(E7, 25);
      const T1 = H3 + sigma1 + Chi(E7, F6, G7) + SHA256_K2[i34] + SHA256_W2[i34] | 0;
      const sigma0 = rotr(A13, 2) ^ rotr(A13, 13) ^ rotr(A13, 22);
      const T22 = sigma0 + Maj(A13, B6, C6) | 0;
      H3 = G7;
      G7 = F6;
      F6 = E7;
      E7 = D7 + T1 | 0;
      D7 = C6;
      C6 = B6;
      B6 = A13;
      A13 = T1 + T22 | 0;
    }
    A13 = A13 + this.A | 0;
    B6 = B6 + this.B | 0;
    C6 = C6 + this.C | 0;
    D7 = D7 + this.D | 0;
    E7 = E7 + this.E | 0;
    F6 = F6 + this.F | 0;
    G7 = G7 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A13, B6, C6, D7, E7, F6, G7, H3);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2242 = class extends SHA2562 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha2562 = wrapConstructor(() => new SHA2562());
var sha2242 = wrapConstructor(() => new SHA2242());

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  isBytes: () => isBytes5,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
function isBytes5(a19) {
  return a19 instanceof Uint8Array || a19 != null && typeof a19 === "object" && a19.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes5(item))
    throw new Error("Uint8Array expected");
}
var hexes3 = Array.from({ length: 256 }, (_6, i34) => i34.toString(16).padStart(2, "0"));
function bytesToHex2(bytes3) {
  abytes(bytes3);
  let hex2 = "";
  for (let i34 = 0; i34 < bytes3.length; i34++) {
    hex2 += hexes3[bytes3[i34]];
  }
  return hex2;
}
function numberToHexUnpadded(num) {
  const hex2 = num.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase162(char) {
  if (char >= asciis2._0 && char <= asciis2._9)
    return char - asciis2._0;
  if (char >= asciis2._A && char <= asciis2._F)
    return char - (asciis2._A - 10);
  if (char >= asciis2._a && char <= asciis2._f)
    return char - (asciis2._a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi));
    const n24 = asciiToBase162(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n24 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n24;
  }
  return array;
}
function bytesToNumberBE(bytes3) {
  return hexToNumber(bytesToHex2(bytes3));
}
function bytesToNumberLE(bytes3) {
  abytes(bytes3);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes3).reverse()));
}
function numberToBytesBE(n24, len) {
  return hexToBytes2(n24.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n24, len) {
  return numberToBytesBE(n24, len).reverse();
}
function numberToVarBytesBE(n24) {
  return hexToBytes2(numberToHexUnpadded(n24));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e2) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e2}`);
    }
  } else if (isBytes5(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i34 = 0; i34 < arrays.length; i34++) {
    const a19 = arrays[i34];
    abytes(a19);
    sum += a19.length;
  }
  const res = new Uint8Array(sum);
  for (let i34 = 0, pad = 0; i34 < arrays.length; i34++) {
    const a19 = arrays[i34];
    res.set(a19, pad);
    pad += a19.length;
  }
  return res;
}
function equalBytes(a19, b10) {
  if (a19.length !== b10.length)
    return false;
  let diff = 0;
  for (let i34 = 0; i34 < a19.length; i34++)
    diff |= a19[i34] ^ b10[i34];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n24) {
  let len;
  for (len = 0; n24 > _0n2; n24 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n24, pos) {
  return n24 >> BigInt(pos) & _1n2;
}
function bitSet(n24, pos, value) {
  return n24 | (value ? _1n2 : _0n2) << BigInt(pos);
}
var bitMask = (n24) => (_2n2 << BigInt(n24 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v6 = u8n(hashLen);
  let k3 = u8n(hashLen);
  let i34 = 0;
  const reset = () => {
    v6.fill(1);
    k3.fill(0);
    i34 = 0;
  };
  const h14 = (...b10) => hmacFn(k3, v6, ...b10);
  const reseed = (seed = u8n()) => {
    k3 = h14(u8fr([0]), seed);
    v6 = h14();
    if (seed.length === 0)
      return;
    k3 = h14(u8fr([1]), seed);
    v6 = h14();
  };
  const gen2 = () => {
    if (i34++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v6 = h14();
      const sl = v6.slice();
      out.push(sl);
      len += v6.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes5(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a19, b10) {
  const result = a19 % b10;
  return result >= _0n3 ? result : b10 + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x9, power, modulo) {
  let res = x9;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number3, modulo) {
  if (number3 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number3} mod=${modulo}`);
  }
  let a19 = mod(number3, modulo);
  let b10 = modulo;
  let x9 = _0n3, y12 = _1n3, u11 = _1n3, v6 = _0n3;
  while (a19 !== _0n3) {
    const q4 = b10 / a19;
    const r16 = b10 % a19;
    const m13 = x9 - u11 * q4;
    const n24 = y12 - v6 * q4;
    b10 = a19, a19 = r16, x9 = u11, y12 = v6, u11 = m13, v6 = n24;
  }
  const gcd2 = b10;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x9, modulo);
}
function tonelliShanks(P6) {
  const legendreC = (P6 - _1n3) / _2n3;
  let Q4, S7, Z5;
  for (Q4 = P6 - _1n3, S7 = 0; Q4 % _2n3 === _0n3; Q4 /= _2n3, S7++)
    ;
  for (Z5 = _2n3; Z5 < P6 && pow(Z5, legendreC, P6) !== P6 - _1n3; Z5++)
    ;
  if (S7 === 1) {
    const p1div4 = (P6 + _1n3) / _4n;
    return function tonelliFast(Fp2, n24) {
      const root = Fp2.pow(n24, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q4 + _1n3) / _2n3;
  return function tonelliSlow(Fp2, n24) {
    if (Fp2.pow(n24, legendreC) === Fp2.neg(Fp2.ONE))
      throw new Error("Cannot find square root");
    let r16 = S7;
    let g8 = Fp2.pow(Fp2.mul(Fp2.ONE, Z5), Q4);
    let x9 = Fp2.pow(n24, Q1div2);
    let b10 = Fp2.pow(n24, Q4);
    while (!Fp2.eql(b10, Fp2.ONE)) {
      if (Fp2.eql(b10, Fp2.ZERO))
        return Fp2.ZERO;
      let m13 = 1;
      for (let t25 = Fp2.sqr(b10); m13 < r16; m13++) {
        if (Fp2.eql(t25, Fp2.ONE))
          break;
        t25 = Fp2.sqr(t25);
      }
      const ge2 = Fp2.pow(g8, _1n3 << BigInt(r16 - m13 - 1));
      g8 = Fp2.sqr(ge2);
      x9 = Fp2.mul(x9, ge2);
      b10 = Fp2.mul(b10, g8);
      r16 = m13;
    }
    return x9;
  };
}
function FpSqrt(P6) {
  if (P6 % _4n === _3n) {
    const p1div4 = (P6 + _1n3) / _4n;
    return function sqrt3mod4(Fp2, n24) {
      const root = Fp2.pow(n24, p1div4);
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P6 % _8n === _5n) {
    const c1 = (P6 - _5n) / _8n;
    return function sqrt5mod8(Fp2, n24) {
      const n25 = Fp2.mul(n24, _2n3);
      const v6 = Fp2.pow(n25, c1);
      const nv = Fp2.mul(n24, v6);
      const i34 = Fp2.mul(Fp2.mul(nv, _2n3), v6);
      const root = Fp2.mul(nv, Fp2.sub(i34, Fp2.ONE));
      if (!Fp2.eql(Fp2.sqr(root), n24))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P6 % _16n === _9n) {
  }
  return tonelliShanks(P6);
}
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f13, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f13.ONE;
  if (power === _1n3)
    return num;
  let p11 = f13.ONE;
  let d10 = num;
  while (power > _0n3) {
    if (power & _1n3)
      p11 = f13.mul(p11, d10);
    d10 = f13.sqr(d10);
    power >>= _1n3;
  }
  return p11;
}
function FpInvertBatch(f13, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i34) => {
    if (f13.is0(num))
      return acc;
    tmp[i34] = acc;
    return f13.mul(acc, num);
  }, f13.ONE);
  const inverted = f13.inv(lastMultiplied);
  nums.reduceRight((acc, num, i34) => {
    if (f13.is0(num))
      return acc;
    tmp[i34] = f13.mul(acc, tmp[i34]);
    return f13.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n24, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n24.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE3 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f13 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f13, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n24) => sqrtP(f13, n24)),
    invertBatch: (lst) => FpInvertBatch(f13, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a19, b10, c10) => c10 ? b10 : a19,
    toBytes: (num) => isLE3 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes3) => {
      if (bytes3.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes3.length}`);
      return isLE3 ? bytesToNumberLE(bytes3) : bytesToNumberBE(bytes3);
    }
  });
  return Object.freeze(f13);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE3 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE3 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE3 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
function wNAF(c10, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W5) => {
    const windows = Math.ceil(bits / W5) + 1;
    const windowSize = 2 ** (W5 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n24) {
      let p11 = c10.ZERO;
      let d10 = elm;
      while (n24 > _0n4) {
        if (n24 & _1n4)
          p11 = p11.add(d10);
        d10 = d10.double();
        n24 >>= _1n4;
      }
      return p11;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(1) * (Math.ceil( / ) + 1), where:
     * -  is the window size
     * -  is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W5) {
      const { windows, windowSize } = opts(W5);
      const points = [];
      let p11 = elm;
      let base = p11;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p11;
        points.push(base);
        for (let i34 = 1; i34 < windowSize; i34++) {
          base = base.add(p11);
          points.push(base);
        }
        p11 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W5, precomputes, n24) {
      const { windows, windowSize } = opts(W5);
      let p11 = c10.ZERO;
      let f13 = c10.BASE;
      const mask = BigInt(2 ** W5 - 1);
      const maxNumber = 2 ** W5;
      const shiftBy = BigInt(W5);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n24 & mask);
        n24 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n24 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f13 = f13.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p11 = p11.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p11, f: f13 };
    },
    wNAFCached(P6, precomputesMap, n24, transform) {
      const W5 = P6._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P6);
      if (!comp) {
        comp = this.precomputeWindow(P6, W5);
        if (W5 !== 1) {
          precomputesMap.set(P6, transform(comp));
        }
      }
      return this.wNAF(W5, comp, n24);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp2, a: a19 } = opts;
  if (endo) {
    if (!Fp2.eql(a19, Fp2.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m13 = "") {
      super(m13);
    }
  },
  _parseInt(data) {
    const { Err: E7 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E7("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E7("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E7("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E7("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E7 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes(data);
    let l12 = data.length;
    if (l12 < 2 || data[0] != 48)
      throw new E7("Invalid signature tag");
    if (data[1] !== l12 - 2)
      throw new E7("Invalid signature: incorrect length");
    const { d: r16, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s17, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E7("Invalid signature: left bytes after parsing");
    return { r: r16, s: s17 };
  },
  hexFromSig(sig) {
    const slice = (s18) => Number.parseInt(s18[0], 16) & 8 ? "00" + s18 : s18;
    const h14 = (num) => {
      const hex2 = num.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s17 = slice(h14(sig.s));
    const r16 = slice(h14(sig.r));
    const shl = s17.length / 2;
    const rhl = r16.length / 2;
    const sl = h14(shl);
    const rl = h14(rhl);
    return `30${h14(rhl + shl + 4)}02${rl}${r16}02${sl}${s17}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp2 } = CURVE;
  const toBytes3 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a19 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp2.toBytes(a19.x), Fp2.toBytes(a19.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes3) => {
    const tail = bytes3.subarray(1);
    const x9 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
    const y12 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
    return { x: x9, y: y12 };
  });
  function weierstrassEquation(x9) {
    const { a: a19, b: b10 } = CURVE;
    const x22 = Fp2.sqr(x9);
    const x32 = Fp2.mul(x22, x9);
    return Fp2.add(Fp2.add(x32, Fp2.mul(x9, a19)), b10);
  }
  if (!Fp2.eql(Fp2.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n24 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes5(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n24);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point3))
      throw new Error("ProjectivePoint expected");
  }
  class Point3 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp2.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp2.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp2.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p11) {
      const { x: x9, y: y12 } = p11 || {};
      if (!p11 || !Fp2.isValid(x9) || !Fp2.isValid(y12))
        throw new Error("invalid affine point");
      if (p11 instanceof Point3)
        throw new Error("projective point not allowed");
      const is0 = (i34) => Fp2.eql(i34, Fp2.ZERO);
      if (is0(x9) && is0(y12))
        return Point3.ZERO;
      return new Point3(x9, y12, Fp2.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp2.invertBatch(points.map((p11) => p11.pz));
      return points.map((p11, i34) => p11.toAffine(toInv[i34])).map(Point3.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P6 = Point3.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P6.assertValidity();
      return P6;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point3.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp2.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x9, y: y12 } = this.toAffine();
      if (!Fp2.isValid(x9) || !Fp2.isValid(y12))
        throw new Error("bad point: x or y not FE");
      const left = Fp2.sqr(y12);
      const right = weierstrassEquation(x9);
      if (!Fp2.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y12 } = this.toAffine();
      if (Fp2.isOdd)
        return !Fp2.isOdd(y12);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp2.eql(Fp2.mul(X1, Z22), Fp2.mul(X22, Z1));
      const U22 = Fp2.eql(Fp2.mul(Y1, Z22), Fp2.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point3(this.px, Fp2.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a19, b: b10 } = CURVE;
      const b32 = Fp2.mul(b10, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp2.ZERO, Y3 = Fp2.ZERO, Z32 = Fp2.ZERO;
      let t0 = Fp2.mul(X1, X1);
      let t1 = Fp2.mul(Y1, Y1);
      let t25 = Fp2.mul(Z1, Z1);
      let t32 = Fp2.mul(X1, Y1);
      t32 = Fp2.add(t32, t32);
      Z32 = Fp2.mul(X1, Z1);
      Z32 = Fp2.add(Z32, Z32);
      X32 = Fp2.mul(a19, Z32);
      Y3 = Fp2.mul(b32, t25);
      Y3 = Fp2.add(X32, Y3);
      X32 = Fp2.sub(t1, Y3);
      Y3 = Fp2.add(t1, Y3);
      Y3 = Fp2.mul(X32, Y3);
      X32 = Fp2.mul(t32, X32);
      Z32 = Fp2.mul(b32, Z32);
      t25 = Fp2.mul(a19, t25);
      t32 = Fp2.sub(t0, t25);
      t32 = Fp2.mul(a19, t32);
      t32 = Fp2.add(t32, Z32);
      Z32 = Fp2.add(t0, t0);
      t0 = Fp2.add(Z32, t0);
      t0 = Fp2.add(t0, t25);
      t0 = Fp2.mul(t0, t32);
      Y3 = Fp2.add(Y3, t0);
      t25 = Fp2.mul(Y1, Z1);
      t25 = Fp2.add(t25, t25);
      t0 = Fp2.mul(t25, t32);
      X32 = Fp2.sub(X32, t0);
      Z32 = Fp2.mul(t25, t1);
      Z32 = Fp2.add(Z32, Z32);
      Z32 = Fp2.add(Z32, Z32);
      return new Point3(X32, Y3, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp2.ZERO, Y3 = Fp2.ZERO, Z32 = Fp2.ZERO;
      const a19 = CURVE.a;
      const b32 = Fp2.mul(CURVE.b, _3n2);
      let t0 = Fp2.mul(X1, X22);
      let t1 = Fp2.mul(Y1, Y22);
      let t25 = Fp2.mul(Z1, Z22);
      let t32 = Fp2.add(X1, Y1);
      let t42 = Fp2.add(X22, Y22);
      t32 = Fp2.mul(t32, t42);
      t42 = Fp2.add(t0, t1);
      t32 = Fp2.sub(t32, t42);
      t42 = Fp2.add(X1, Z1);
      let t52 = Fp2.add(X22, Z22);
      t42 = Fp2.mul(t42, t52);
      t52 = Fp2.add(t0, t25);
      t42 = Fp2.sub(t42, t52);
      t52 = Fp2.add(Y1, Z1);
      X32 = Fp2.add(Y22, Z22);
      t52 = Fp2.mul(t52, X32);
      X32 = Fp2.add(t1, t25);
      t52 = Fp2.sub(t52, X32);
      Z32 = Fp2.mul(a19, t42);
      X32 = Fp2.mul(b32, t25);
      Z32 = Fp2.add(X32, Z32);
      X32 = Fp2.sub(t1, Z32);
      Z32 = Fp2.add(t1, Z32);
      Y3 = Fp2.mul(X32, Z32);
      t1 = Fp2.add(t0, t0);
      t1 = Fp2.add(t1, t0);
      t25 = Fp2.mul(a19, t25);
      t42 = Fp2.mul(b32, t42);
      t1 = Fp2.add(t1, t25);
      t25 = Fp2.sub(t0, t25);
      t25 = Fp2.mul(a19, t25);
      t42 = Fp2.add(t42, t25);
      t0 = Fp2.mul(t1, t42);
      Y3 = Fp2.add(Y3, t0);
      t0 = Fp2.mul(t52, t42);
      X32 = Fp2.mul(t32, X32);
      X32 = Fp2.sub(X32, t0);
      t0 = Fp2.mul(t32, t1);
      Z32 = Fp2.mul(t52, Z32);
      Z32 = Fp2.add(Z32, t0);
      return new Point3(X32, Y3, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point3.ZERO);
    }
    wNAF(n24) {
      return wnaf.wNAFCached(this, pointPrecomputes, n24, (comp) => {
        const toInv = Fp2.invertBatch(comp.map((p11) => p11.pz));
        return comp.map((p11, i34) => p11.toAffine(toInv[i34])).map(Point3.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n24) {
      const I5 = Point3.ZERO;
      if (n24 === _0n5)
        return I5;
      assertGE(n24);
      if (n24 === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n24);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n24);
      let k1p = I5;
      let k2p = I5;
      let d10 = this;
      while (k1 > _0n5 || k22 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d10);
        if (k22 & _1n5)
          k2p = k2p.add(d10);
        d10 = d10.double();
        k1 >>= _1n5;
        k22 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n24 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n24);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point3(Fp2.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p11, f: f13 } = this.wNAF(n24);
        point = p11;
        fake = f13;
      }
      return Point3.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q4, a19, b10) {
      const G7 = Point3.BASE;
      const mul = (P6, a20) => a20 === _0n5 || a20 === _1n5 || !P6.equals(G7) ? P6.multiplyUnsafe(a20) : P6.multiply(a20);
      const sum = mul(this, a19).add(mul(Q4, b10));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z)  (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x9, py: y12, pz: z5 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp2.ONE : Fp2.inv(z5);
      const ax = Fp2.mul(x9, iz);
      const ay = Fp2.mul(y12, iz);
      const zz = Fp2.mul(z5, iz);
      if (is0)
        return { x: Fp2.ZERO, y: Fp2.ZERO };
      if (!Fp2.eql(zz, Fp2.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point3, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point3, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes3(Point3, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point3.BASE = new Point3(CURVE.Gx, CURVE.Gy, Fp2.ONE);
  Point3.ZERO = new Point3(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point3, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point3,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp2, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp2.BYTES + 1;
  const uncompressedLen = 2 * Fp2.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp2.ORDER;
  }
  function modN2(a19) {
    return mod(a19, CURVE_ORDER);
  }
  function invN(a19) {
    return invert(a19, CURVE_ORDER);
  }
  const { ProjectivePoint: Point3, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a19 = point.toAffine();
      const x9 = Fp2.toBytes(a19.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x9);
      } else {
        return cat(Uint8Array.from([4]), x9, Fp2.toBytes(a19.y));
      }
    },
    fromBytes(bytes3) {
      const len = bytes3.length;
      const head = bytes3[0];
      const tail = bytes3.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x9 = bytesToNumberBE(tail);
        if (!isValidFieldElement(x9))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x9);
        let y12;
        try {
          y12 = Fp2.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y12 & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y12 = Fp2.neg(y12);
        return { x: x9, y: y12 };
      } else if (len === uncompressedLen && head === 4) {
        const x9 = Fp2.fromBytes(tail.subarray(0, Fp2.BYTES));
        const y12 = Fp2.fromBytes(tail.subarray(Fp2.BYTES, 2 * Fp2.BYTES));
        return { x: x9, y: y12 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex2(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number3) {
    const HALF = CURVE_ORDER >> _1n5;
    return number3 > HALF;
  }
  function normalizeS(s17) {
    return isBiggerThanHalfOrder(s17) ? modN2(-s17) : s17;
  }
  const slcNum = (b10, from, to) => bytesToNumberBE(b10.slice(from, to));
  class Signature {
    constructor(r16, s17, recovery) {
      this.r = r16;
      this.s = s17;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l12 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l12 * 2);
      return new Signature(slcNum(hex2, 0, l12), slcNum(hex2, l12, 2 * l12));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r16, s: s17 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r16, s17);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r16, s: s17, recovery: rec } = this;
      const h14 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r16 + CURVE.n : r16;
      if (radj >= Fp2.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R6 = Point3.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN2(-h14 * ir);
      const u22 = modN2(s17 * ir);
      const Q4 = Point3.BASE.multiplyAndAddUnsafe(R6, u1, u22);
      if (!Q4)
        throw new Error("point at infinify");
      Q4.assertValidity();
      return Q4;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN2(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point3.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point3.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes5(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point3)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b10 = Point3.fromHex(publicB);
    return b10.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes3) {
    const num = bytesToNumberBE(bytes3);
    const delta = bytes3.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes3) {
    return modN2(bits2int(bytes3));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k3) => k3 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d10 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d10), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e2 = ent === true ? randomBytes3(Fp2.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e2));
    }
    const seed = concatBytes2(...seedArgs);
    const m13 = h1int;
    function k2sig(kBytes) {
      const k3 = bits2int(kBytes);
      if (!isWithinCurveOrder(k3))
        return;
      const ik = invN(k3);
      const q4 = Point3.BASE.multiply(k3).toAffine();
      const r16 = modN2(q4.x);
      if (r16 === _0n5)
        return;
      const s17 = modN2(ik * modN2(m13 + r16 * d10));
      if (s17 === _0n5)
        return;
      let recovery = (q4.x === r16 ? 0 : 2) | Number(q4.y & _1n5);
      let normS = s17;
      if (lowS && isBiggerThanHalfOrder(s17)) {
        normS = normalizeS(s17);
        recovery ^= 1;
      }
      return new Signature(r16, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C6 = CURVE;
    const drbg = createHmacDrbg(C6.hash.outputLen, C6.nByteLength, C6.hmac);
    return drbg(seed, k2sig);
  }
  Point3.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P6;
    try {
      if (typeof sg === "string" || isBytes5(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r17, s: s18 } = sg;
        _sig = new Signature(r17, s18);
      } else {
        throw new Error("PARSE");
      }
      P6 = Point3.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r16, s: s17 } = _sig;
    const h14 = bits2int_modN(msgHash);
    const is = invN(s17);
    const u1 = modN2(h14 * is);
    const u22 = modN2(r16 * is);
    const R6 = (_a = Point3.BASE.multiplyAndAddUnsafe(P6, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R6)
      return false;
    const v6 = modN2(R6.x);
    return v6 === r16;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point3,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp2, Z5) {
  const q4 = Fp2.ORDER;
  let l12 = _0n5;
  for (let o19 = q4 - _1n5; o19 % _2n4 === _0n5; o19 /= _2n4)
    l12 += _1n5;
  const c1 = l12;
  const _2n_pow_c1_1 = _2n4 << c1 - _1n5 - _1n5;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
  const c22 = (q4 - _1n5) / _2n_pow_c1;
  const c32 = (c22 - _1n5) / _2n4;
  const c42 = _2n_pow_c1 - _1n5;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp2.pow(Z5, c22);
  const c72 = Fp2.pow(Z5, (c22 + _1n5) / _2n4);
  let sqrtRatio = (u11, v6) => {
    let tv1 = c62;
    let tv2 = Fp2.pow(v6, c42);
    let tv3 = Fp2.sqr(tv2);
    tv3 = Fp2.mul(tv3, v6);
    let tv5 = Fp2.mul(u11, tv3);
    tv5 = Fp2.pow(tv5, c32);
    tv5 = Fp2.mul(tv5, tv2);
    tv2 = Fp2.mul(tv5, v6);
    tv3 = Fp2.mul(tv5, u11);
    let tv4 = Fp2.mul(tv3, tv2);
    tv5 = Fp2.pow(tv4, c52);
    let isQR = Fp2.eql(tv5, Fp2.ONE);
    tv2 = Fp2.mul(tv3, c72);
    tv5 = Fp2.mul(tv4, tv1);
    tv3 = Fp2.cmov(tv2, tv3, isQR);
    tv4 = Fp2.cmov(tv5, tv4, isQR);
    for (let i34 = c1; i34 > _1n5; i34--) {
      let tv52 = i34 - _2n4;
      tv52 = _2n4 << tv52 - _1n5;
      let tvv5 = Fp2.pow(tv4, tv52);
      const e1 = Fp2.eql(tvv5, Fp2.ONE);
      tv2 = Fp2.mul(tv3, tv1);
      tv1 = Fp2.mul(tv1, tv1);
      tvv5 = Fp2.mul(tv4, tv1);
      tv3 = Fp2.cmov(tv2, tv3, e1);
      tv4 = Fp2.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp2.ORDER % _4n2 === _3n2) {
    const c12 = (Fp2.ORDER - _3n2) / _4n2;
    const c23 = Fp2.sqrt(Fp2.neg(Z5));
    sqrtRatio = (u11, v6) => {
      let tv1 = Fp2.sqr(v6);
      const tv2 = Fp2.mul(u11, v6);
      tv1 = Fp2.mul(tv1, tv2);
      let y1 = Fp2.pow(tv1, c12);
      y1 = Fp2.mul(y1, tv2);
      const y22 = Fp2.mul(y1, c23);
      const tv3 = Fp2.mul(Fp2.sqr(y1), v6);
      const isQR = Fp2.eql(tv3, u11);
      let y12 = Fp2.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y12 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp2, opts) {
  validateField(Fp2);
  if (!Fp2.isValid(opts.A) || !Fp2.isValid(opts.B) || !Fp2.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp2, opts.Z);
  if (!Fp2.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u11) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x9, y12;
    tv1 = Fp2.sqr(u11);
    tv1 = Fp2.mul(tv1, opts.Z);
    tv2 = Fp2.sqr(tv1);
    tv2 = Fp2.add(tv2, tv1);
    tv3 = Fp2.add(tv2, Fp2.ONE);
    tv3 = Fp2.mul(tv3, opts.B);
    tv4 = Fp2.cmov(opts.Z, Fp2.neg(tv2), !Fp2.eql(tv2, Fp2.ZERO));
    tv4 = Fp2.mul(tv4, opts.A);
    tv2 = Fp2.sqr(tv3);
    tv6 = Fp2.sqr(tv4);
    tv5 = Fp2.mul(tv6, opts.A);
    tv2 = Fp2.add(tv2, tv5);
    tv2 = Fp2.mul(tv2, tv3);
    tv6 = Fp2.mul(tv6, tv4);
    tv5 = Fp2.mul(tv6, opts.B);
    tv2 = Fp2.add(tv2, tv5);
    x9 = Fp2.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y12 = Fp2.mul(tv1, u11);
    y12 = Fp2.mul(y12, value);
    x9 = Fp2.cmov(x9, tv3, isValid);
    y12 = Fp2.cmov(y12, value, isValid);
    const e1 = Fp2.isOdd(u11) === Fp2.isOdd(y12);
    y12 = Fp2.cmov(Fp2.neg(y12), y12, e1);
    x9 = Fp2.div(x9, tv4);
    return { x: x9, y: y12 };
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i34 = length - 1; i34 >= 0; i34--) {
    res[i34] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a19, b10) {
  const arr = new Uint8Array(a19.length);
  for (let i34 = 0; i34 < a19.length; i34++) {
    arr[i34] = a19[i34] ^ b10[i34];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H3) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H3(concatBytes2(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b10 = new Array(ell);
  const b_0 = H3(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b10[0] = H3(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i34 = 1; i34 <= ell; i34++) {
    const args = [strxor(b_0, b10[i34 - 1]), i2osp(i34 + 1, 1), DST_prime];
    b10[i34] = H3(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b10);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k3, H3) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k3 / 8);
    DST = H3.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p11, k: k3, m: m13, hash: hash3, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
  const log2p = p11.toString(2).length;
  const L4 = Math.ceil((log2p + k3) / 8);
  const len_in_bytes = count * m13 * L4;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash3);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k3, hash3);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u11 = new Array(count);
  for (let i34 = 0; i34 < count; i34++) {
    const e2 = new Array(m13);
    for (let j4 = 0; j4 < m13; j4++) {
      const elm_offset = L4 * (j4 + i34 * m13);
      const tv = prb.subarray(elm_offset, elm_offset + L4);
      e2[j4] = mod(os2ip(tv), p11);
    }
    u11[i34] = e2;
  }
  return u11;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i34) => Array.from(i34).reverse());
  return (x9, y12) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i34) => field.add(field.mul(acc, x9), i34)));
    x9 = field.div(xNum, xDen);
    y12 = field.mul(y12, field.div(yNum, yDen));
    return { x: x9, y: y12 };
  };
}
function createHasher(Point3, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u11 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point3.fromAffine(mapToCurve(u11[0]));
      const u1 = Point3.fromAffine(mapToCurve(u11[1]));
      const P6 = u0.add(u1).clearCofactor();
      P6.assertValidity();
      return P6;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u11 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P6 = Point3.fromAffine(mapToCurve(u11[0])).clearCofactor();
      P6.assertValidity();
      return P6;
    }
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a19, b10) => (a19 + b10 / _2n5) / b10;
function sqrtMod(y12) {
  const P6 = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y12 * y12 * y12 % P6;
  const b32 = b22 * b22 * y12 % P6;
  const b62 = pow2(b32, _3n3, P6) * b32 % P6;
  const b92 = pow2(b62, _3n3, P6) * b32 % P6;
  const b11 = pow2(b92, _2n5, P6) * b22 % P6;
  const b222 = pow2(b11, _11n, P6) * b11 % P6;
  const b44 = pow2(b222, _22n, P6) * b222 % P6;
  const b88 = pow2(b44, _44n, P6) * b44 % P6;
  const b176 = pow2(b88, _88n, P6) * b88 % P6;
  const b220 = pow2(b176, _44n, P6) * b44 % P6;
  const b223 = pow2(b220, _3n3, P6) * b32 % P6;
  const t1 = pow2(b223, _23n, P6) * b222 % P6;
  const t25 = pow2(t1, _6n, P6) * b22 % P6;
  const root = pow2(t25, _2n5, P6);
  if (!Fp.eql(Fp.sqr(root), y12))
    throw new Error("Cannot find square root");
  return root;
}
var Fp = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k3) => {
      const n24 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k3, n24);
      const c22 = divNearest(-b1 * k3, n24);
      let k1 = mod(k3 - c1 * a1 - c22 * a22, n24);
      let k22 = mod(-c1 * b1 - c22 * b22, n24);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n24 - k1;
      if (k2neg)
        k22 = n24 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k3);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha2562);
var _0n6 = BigInt(0);
var fe = (x9) => typeof x9 === "bigint" && _0n6 < x9 && x9 < secp256k1P;
var ge = (x9) => typeof x9 === "bigint" && _0n6 < x9 && x9 < secp256k1N;
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha2562(Uint8Array.from(tag, (c10) => c10.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha2562(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n24) => numberToBytesBE(n24, 32);
var modP = (x9) => mod(x9, secp256k1P);
var modN = (x9) => mod(x9, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q4, a19, b10) => Point.BASE.multiplyAndAddUnsafe(Q4, a19, b10);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p11 = Point.fromPrivateKey(d_);
  const scalar = p11.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p11) };
}
function lift_x(x9) {
  if (!fe(x9))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP(x9 * x9);
  const c10 = modP(xx * x9 + BigInt(7));
  let y12 = sqrtMod(c10);
  if (y12 % _2n5 !== _0n6)
    y12 = modP(-y12);
  const p11 = new Point(x9, y12, _1n6);
  p11.assertValidity();
  return p11;
}
function challenge(...args) {
  return modN(bytesToNumberBE(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m13 = ensureBytes("message", message);
  const { bytes: px, scalar: d10 } = schnorrGetExtPubKey(privateKey);
  const a19 = ensureBytes("auxRand", auxRand, 32);
  const t25 = numTo32b(d10 ^ bytesToNumberBE(taggedHash("BIP0340/aux", a19)));
  const rand = taggedHash("BIP0340/nonce", t25, px, m13);
  const k_ = modN(bytesToNumberBE(rand));
  if (k_ === _0n6)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k3 } = schnorrGetExtPubKey(k_);
  const e2 = challenge(rx, px, m13);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k3 + e2 * d10)), 32);
  if (!schnorrVerify(sig, m13, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m13 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P6 = lift_x(bytesToNumberBE(pub));
    const r16 = bytesToNumberBE(sig.subarray(0, 32));
    if (!fe(r16))
      return false;
    const s17 = bytesToNumberBE(sig.subarray(32, 64));
    if (!ge(s17))
      return false;
    const e2 = challenge(numTo32b(r16), pointToBytes(P6), m13);
    const R6 = GmulAdd(P6, s17, modN(-e2));
    if (!R6 || !R6.hasEvenY() || R6.toAffine().x !== r16)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i34) => i34.map((j4) => BigInt(j4)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp.create(BigInt("-11"))
}))();
var htf = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x9, y: y12 } = mapSWU(Fp.create(scalars[0]));
  return isoMap(x9, y12);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha2562
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// E:/Proj/HXProjs/lucky-pocket/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_6, i34) => i34));
var Pi = Id.map((i34) => (9 * i34 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i34 = 0; i34 < 4; i34++)
  for (let j4 of [idxL, idxR])
    j4.push(j4[i34].map((k3) => Rho[k3]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i34) => new Uint8Array(i34));
var shiftsL = idxL.map((idx, i34) => idx.map((j4) => shifts[i34][j4]));
var shiftsR = idxR.map((idx, i34) => idx.map((j4) => shifts[i34][j4]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f7(group, x9, y12, z5) {
  if (group === 0)
    return x9 ^ y12 ^ z5;
  else if (group === 1)
    return x9 & y12 | ~x9 & z5;
  else if (group === 2)
    return (x9 | ~y12) ^ z5;
  else if (group === 3)
    return x9 & z5 | y12 & ~z5;
  else
    return x9 ^ (y12 | ~z5);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i34 = 0; i34 < 16; i34++, offset += 4)
      R_BUF[i34] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i34 = 0; i34 < 16; i34++) {
        const tl = rotl(al + f7(group, bl, cl, dl) + R_BUF[rl[i34]] + hbl, sl[i34]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i34 = 0; i34 < 16; i34++) {
        const tr = rotl(ar + f7(rGroup, br, cr, dr) + R_BUF[rr[i34]] + hbr, sr[i34]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// E:/Proj/HXProjs/lucky-pocket/node_modules/@scure/bip32/lib/esm/index.js
var Point2 = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha2562);
function bytesToNumber(bytes3) {
  return BigInt(`0x${bytesToHex(bytes3)}`);
}
function numberToBytes(num) {
  return hexToBytes(num.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha2562(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n24) => {
  if (!Number.isSafeInteger(n24) || n24 < 0 || n24 > 2 ** 32 - 1) {
    throw new Error(`Invalid number=${n24}. Should be from 0 to 2 ** 32 - 1`);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n24, false);
  return buf;
};
var HDKey = class {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    bytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    }
    const I5 = hmac(sha512, MASTER_SECRET, seed);
    return new HDKey({
      versions,
      chainCode: I5.slice(32),
      privateKey: I5.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point2.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c10 of parts) {
      const m13 = /^(\d+)('?)$/.exec(c10);
      const m1 = m13 && m13[1];
      if (!m13 || m13.length !== 3 || typeof m1 !== "string") {
        throw new Error(`Invalid child index: ${c10}`);
      }
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m13[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I5 = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I5.slice(0, 32));
    const chainCode = I5.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point2.fromHex(this.pubKey).add(Point2.fromPrivateKey(childTweak));
        if (added.equals(Point2.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash3) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    bytes(hash3, 32);
    return secp256k1.sign(hash3, this.privKey).toCompactRawBytes();
  }
  verify(hash3, signature) {
    bytes(hash3, 32);
    bytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash3, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    bytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RNFDAXUZ.mjs
var n11 = class n12 extends t8 {
  constructor(e2) {
    super();
    let r16 = i.fromHexInput(e2);
    if (r16.toUint8Array().length !== n12.LENGTH)
      throw new Error(`PublicKey length should be ${n12.LENGTH}`);
    this.key = r16;
  }
  verifySignature(e2) {
    let { message: r16, signature: i34 } = e2;
    if (!(i34 instanceof y7))
      return false;
    let l12 = i.fromHexInput(r16).toUint8Array(), v6 = sha3_256(l12), H3 = i34.toUint8Array();
    return secp256k1.verify(H3, v6, this.key.toUint8Array());
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e2) {
    e2.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e2) {
    let r16 = e2.deserializeBytes();
    return new n12(r16);
  }
  static isPublicKey(e2) {
    return e2 instanceof n12;
  }
};
n11.LENGTH = 65;
var u4 = n11;
var t9 = class t10 extends B {
  constructor(e2) {
    super();
    let r16 = i.fromHexInput(e2);
    if (r16.toUint8Array().length !== t10.LENGTH)
      throw new Error(`PrivateKey length should be ${t10.LENGTH}`);
    this.key = r16;
  }
  static generate() {
    let e2 = secp256k1.utils.randomPrivateKey();
    return new t10(e2);
  }
  static fromDerivationPath(e2, r16) {
    if (!D3(e2))
      throw new Error(`Invalid derivation path ${e2}`);
    return t10.fromDerivationPathInner(e2, h6(r16));
  }
  static fromDerivationPathInner(e2, r16) {
    let { privateKey: i34 } = HDKey.fromMasterSeed(r16).derive(e2);
    if (i34 === null)
      throw new Error("Invalid key");
    return new t10(i34);
  }
  sign(e2) {
    let r16 = i.fromHexInput(e2), i34 = sha3_256(r16.toUint8Array()), l12 = secp256k1.sign(i34, this.key.toUint8Array());
    return new y7(l12.toCompactRawBytes());
  }
  publicKey() {
    let e2 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new u4(e2);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  serialize(e2) {
    e2.serializeBytes(this.toUint8Array());
  }
  static deserialize(e2) {
    let r16 = e2.deserializeBytes();
    return new t10(r16);
  }
  static isPrivateKey(e2) {
    return e2 instanceof t10;
  }
};
t9.LENGTH = 32;
var f8 = t9;
var s5 = class s6 extends o7 {
  constructor(e2) {
    super();
    let r16 = i.fromHexInput(e2);
    if (r16.toUint8Array().length !== s6.LENGTH)
      throw new Error(`Signature length should be ${s6.LENGTH}, received ${r16.toUint8Array().length}`);
    this.data = r16;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e2) {
    e2.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e2) {
    let r16 = e2.deserializeBytes();
    return new s6(r16);
  }
};
s5.LENGTH = 64;
var y7 = s5;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ETGZG4G7.mjs
var b5 = class t11 extends a4 {
  constructor(e2) {
    if (super(), this.publicKey = e2, e2 instanceof m8)
      this.variant = 0;
    else if (e2 instanceof u4)
      this.variant = 1;
    else
      throw new Error("Unsupported public key type");
  }
  verifySignature(e2) {
    let { message: r16, signature: i34 } = e2;
    return i34 instanceof o11 ? this.publicKey.verifySignature({ message: r16, signature: i34.signature }) : false;
  }
  authKey() {
    return c5.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(this.variant), this.publicKey.serialize(e2);
  }
  static deserialize(e2) {
    let r16 = e2.deserializeUleb128AsU32(), i34;
    switch (r16) {
      case 0:
        i34 = m8.deserialize(e2);
        break;
      case 1:
        i34 = u4.deserialize(e2);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${r16}`);
    }
    return new t11(i34);
  }
  static isPublicKey(e2) {
    return e2 instanceof t11;
  }
  isEd25519() {
    return this.publicKey instanceof m8;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof u4;
  }
};
var o11 = class t12 extends o7 {
  constructor(e2) {
    if (super(), this.signature = e2, e2 instanceof y5)
      this.variant = 0;
    else if (e2 instanceof y7)
      this.variant = 1;
    else
      throw new Error("Unsupported signature type");
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(this.variant), this.signature.serialize(e2);
  }
  static deserialize(e2) {
    let r16 = e2.deserializeUleb128AsU32(), i34;
    switch (r16) {
      case 0:
        i34 = y5.deserialize(e2);
        break;
      case 1:
        i34 = y7.deserialize(e2);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${r16}`);
    }
    return new t12(i34);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SEAOSYSZ.mjs
function p7(l12) {
  let e2 = l12;
  return e2 -= e2 >> 1 & 1431655765, e2 = (e2 & 858993459) + (e2 >> 2 & 858993459), (e2 + (e2 >> 4) & 252645135) * 16843009 >> 24;
}
var f9 = class l5 extends a4 {
  constructor(e2) {
    super();
    let { publicKeys: s17, signaturesRequired: t25 } = e2;
    if (t25 < 1)
      throw new Error("The number of required signatures needs to be greater than 0");
    if (s17.length < t25)
      throw new Error(`Provided ${s17.length} public keys is smaller than the ${t25} required signatures`);
    this.publicKeys = s17.map((r16) => r16 instanceof b5 ? r16 : new b5(r16)), this.signaturesRequired = t25;
  }
  verifySignature(e2) {
    throw new Error("not implemented");
  }
  authKey() {
    return c5.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e2) {
    e2.serializeVector(this.publicKeys), e2.serializeU8(this.signaturesRequired);
  }
  static deserialize(e2) {
    let s17 = e2.deserializeVector(b5), t25 = e2.deserializeU8();
    return new l5({ publicKeys: s17, signaturesRequired: t25 });
  }
  createBitmap(e2) {
    let { bits: s17 } = e2, t25 = 128, r16 = new Uint8Array([0, 0, 0, 0]), n24 = /* @__PURE__ */ new Set();
    return s17.forEach((i34, o19) => {
      if (o19 + 1 > this.publicKeys.length)
        throw new Error(`Signature index ${o19 + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (n24.has(i34))
        throw new Error(`Duplicate bit ${i34} detected.`);
      n24.add(i34);
      let u11 = Math.floor(i34 / 8), y12 = r16[u11];
      y12 |= t25 >> i34 % 8, r16[u11] = y12;
    }), r16;
  }
};
var a9 = class a10 extends o7 {
  constructor(e2) {
    super();
    let { signatures: s17, bitmap: t25 } = e2;
    if (s17.length > a10.MAX_SIGNATURES_SUPPORTED)
      throw new Error(`The number of signatures cannot be greater than ${a10.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = s17.map((n24) => n24 instanceof o11 ? n24 : new o11(n24)), !(t25 instanceof Uint8Array))
      this.bitmap = a10.createBitmap({ bits: t25 });
    else {
      if (t25.length !== a10.BITMAP_LEN)
        throw new Error(`"bitmap" length should be ${a10.BITMAP_LEN}`);
      this.bitmap = t25;
    }
    let r16 = this.bitmap.reduce((n24, i34) => n24 + p7(i34), 0);
    if (r16 !== this.signatures.length)
      throw new Error(`Expecting ${r16} signatures from the bitmap, but got ${this.signatures.length}`);
  }
  static createBitmap(e2) {
    let { bits: s17 } = e2, t25 = 128, r16 = new Uint8Array([0, 0, 0, 0]), n24 = /* @__PURE__ */ new Set();
    return s17.forEach((i34) => {
      if (i34 >= a10.MAX_SIGNATURES_SUPPORTED)
        throw new Error(`Cannot have a signature larger than ${a10.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (n24.has(i34))
        throw new Error("Duplicate bits detected.");
      n24.add(i34);
      let o19 = Math.floor(i34 / 8), u11 = r16[o19];
      u11 |= t25 >> i34 % 8, r16[o19] = u11;
    }), r16;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e2) {
    e2.serializeVector(this.signatures), e2.serializeBytes(this.bitmap);
  }
  static deserialize(e2) {
    let s17 = e2.deserializeBytes(), t25 = s17.reduce((n24, i34) => n24 + p7(i34), 0), r16 = [];
    for (let n24 = 0; n24 < t25; n24 += 1) {
      let i34 = o11.deserialize(e2);
      r16.push(i34);
    }
    return new a10({ signatures: r16, bitmap: s17 });
  }
};
a9.BITMAP_LEN = 4, a9.MAX_SIGNATURES_SUPPORTED = a9.BITMAP_LEN * 8;
var A8 = a9;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JPNK6EKM.mjs
var r10 = class extends B {
  static deserialize(i34) {
    let e2 = i34.deserializeUleb128AsU32();
    switch (e2) {
      case 0:
        return n13.load(i34);
      case 1:
        return a11.load(i34);
      case 2:
        return u5.load(i34);
      case 3:
        return l6.load(i34);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${e2}`);
    }
  }
  isEd25519() {
    return this instanceof n13;
  }
  isMultiEd25519() {
    return this instanceof a11;
  }
  isSingleKey() {
    return this instanceof u5;
  }
  isMultiKey() {
    return this instanceof l6;
  }
};
var n13 = class s7 extends r10 {
  constructor(i34, e2) {
    super(), this.public_key = i34, this.signature = e2;
  }
  serialize(i34) {
    i34.serializeU32AsUleb128(0), this.public_key.serialize(i34), this.signature.serialize(i34);
  }
  static load(i34) {
    let e2 = m8.deserialize(i34), t25 = y5.deserialize(i34);
    return new s7(e2, t25);
  }
};
var a11 = class s8 extends r10 {
  constructor(i34, e2) {
    super(), this.public_key = i34, this.signature = e2;
  }
  serialize(i34) {
    i34.serializeU32AsUleb128(1), this.public_key.serialize(i34), this.signature.serialize(i34);
  }
  static load(i34) {
    let e2 = d6.deserialize(i34), t25 = y6.deserialize(i34);
    return new s8(e2, t25);
  }
};
var u5 = class s9 extends r10 {
  constructor(i34, e2) {
    super(), this.public_key = i34, this.signature = e2;
  }
  serialize(i34) {
    i34.serializeU32AsUleb128(2), this.public_key.serialize(i34), this.signature.serialize(i34);
  }
  static load(i34) {
    let e2 = b5.deserialize(i34), t25 = o11.deserialize(i34);
    return new s9(e2, t25);
  }
};
var l6 = class s10 extends r10 {
  constructor(i34, e2, t25) {
    super(), this.public_keys = i34, this.signatures = e2, this.signatures_bitmap = t25;
  }
  serialize(i34) {
    i34.serializeU32AsUleb128(3), this.public_keys.serialize(i34), i34.serializeVector(this.signatures), i34.serializeBytes(this.signatures_bitmap);
  }
  static load(i34) {
    let e2 = f9.deserialize(i34), t25 = i34.deserializeVector(o11), A13 = i34.deserializeBytes();
    return new s10(e2, t25, A13);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-77CVU2W7.mjs
var a12 = class n14 {
  constructor(e2) {
    this.signingScheme = 0;
    let { privateKey: t25, address: r16 } = e2;
    this.privateKey = t25, this.publicKey = t25.publicKey(), this.accountAddress = r16 ? c.from(r16) : this.publicKey.authKey().derivedAddress();
  }
  static generate() {
    let e2 = S4.generate();
    return new n14({ privateKey: e2 });
  }
  static fromDerivationPath(e2) {
    let { path: t25, mnemonic: r16 } = e2, c10 = S4.fromDerivationPath(t25, r16);
    return new n14({ privateKey: c10 });
  }
  verifySignature(e2) {
    return this.publicKey.verifySignature(e2);
  }
  signWithAuthenticator(e2) {
    let t25 = this.privateKey.sign(e2);
    return new n13(this.publicKey, t25);
  }
  sign(e2) {
    return this.signWithAuthenticator(e2).signature;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZOQ3ZG7U.mjs
var p8 = class a13 {
  constructor(e2) {
    this.signingScheme = 2;
    let { privateKey: t25, address: r16 } = e2;
    this.privateKey = t25, this.publicKey = new b5(t25.publicKey()), this.accountAddress = r16 ? c.from(r16) : this.publicKey.authKey().derivedAddress();
  }
  static generate(e2 = {}) {
    let { scheme: t25 = 0 } = e2, r16;
    switch (t25) {
      case 0:
        r16 = S4.generate();
        break;
      case 2:
        r16 = f8.generate();
        break;
      default:
        throw new Error(`Unsupported signature scheme ${t25}`);
    }
    return new a13({ privateKey: r16 });
  }
  static fromDerivationPath(e2) {
    let { scheme: t25 = 0, path: r16, mnemonic: c10 } = e2, n24;
    switch (t25) {
      case 0:
        n24 = S4.fromDerivationPath(r16, c10);
        break;
      case 2:
        n24 = f8.fromDerivationPath(r16, c10);
        break;
      default:
        throw new Error(`Unsupported signature scheme ${t25}`);
    }
    return new a13({ privateKey: n24 });
  }
  verifySignature(e2) {
    return this.publicKey.verifySignature(e2);
  }
  signWithAuthenticator(e2) {
    let t25 = this.privateKey.sign(e2), r16 = new o11(t25);
    return new u5(this.publicKey, r16);
  }
  sign(e2) {
    return this.signWithAuthenticator(e2).signature;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-E36XGHUE.mjs
var o12 = class {
  static generate(e2 = {}) {
    let { scheme: t25 = 0, legacy: r16 = true } = e2;
    return t25 === 0 && r16 ? a12.generate() : p8.generate({ scheme: t25 });
  }
  static fromPrivateKey(e2) {
    let { privateKey: t25, address: r16, legacy: a19 = true } = e2;
    return t25 instanceof S4 && a19 ? new a12({ privateKey: t25, address: r16 }) : new p8({ privateKey: t25, address: r16 });
  }
  static fromPrivateKeyAndAddress(e2) {
    return this.fromPrivateKey(e2);
  }
  static fromDerivationPath(e2) {
    let { scheme: t25 = 0, mnemonic: r16, path: a19, legacy: s17 = true } = e2;
    return t25 === 0 && s17 ? a12.fromDerivationPath({ mnemonic: r16, path: a19 }) : p8.fromDerivationPath({ scheme: t25, mnemonic: r16, path: a19 });
  }
  static authKey(e2) {
    let { publicKey: t25 } = e2;
    return t25.authKey();
  }
  verifySignature(e2) {
    return this.publicKey.verifySignature(e2);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6XMAPYSX.mjs
async function M2(e2) {
  let { aptosConfig: n24, accountAddress: t25 } = e2, { data: o19 } = await g3({ aptosConfig: n24, originMethod: "getInfo", path: `accounts/${c.from(t25).toString()}` });
  return o19;
}
async function go(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2;
  return f3({ aptosConfig: n24, originMethod: "getModules", path: `accounts/${c.from(t25).toString()}/modules`, params: { ledger_version: o19 == null ? void 0 : o19.ledgerVersion, start: o19 == null ? void 0 : o19.offset, limit: (o19 == null ? void 0 : o19.limit) ?? 1e3 } });
}
async function Ao(e2) {
  var _a;
  return ((_a = e2.options) == null ? void 0 : _a.ledgerVersion) !== void 0 ? P2(e2) : m4(async () => P2(e2), `module-${e2.accountAddress}-${e2.moduleName}`, 1e3 * 60 * 5)();
}
async function P2(e2) {
  let { aptosConfig: n24, accountAddress: t25, moduleName: o19, options: r16 } = e2, { data: s17 } = await g3({ aptosConfig: n24, originMethod: "getModule", path: `accounts/${c.from(t25).toString()}/module/${o19}`, params: { ledger_version: r16 == null ? void 0 : r16.ledgerVersion } });
  return s17;
}
async function po(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2;
  return f3({ aptosConfig: n24, originMethod: "getTransactions", path: `accounts/${c.from(t25).toString()}/transactions`, params: { start: o19 == null ? void 0 : o19.offset, limit: o19 == null ? void 0 : o19.limit } });
}
async function fo(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2;
  return f3({ aptosConfig: n24, originMethod: "getResources", path: `accounts/${c.from(t25).toString()}/resources`, params: { ledger_version: o19 == null ? void 0 : o19.ledgerVersion, start: o19 == null ? void 0 : o19.offset, limit: (o19 == null ? void 0 : o19.limit) ?? 999 } });
}
async function K(e2) {
  let { aptosConfig: n24, accountAddress: t25, resourceType: o19, options: r16 } = e2, { data: s17 } = await g3({ aptosConfig: n24, originMethod: "getResource", path: `accounts/${c.from(t25).toString()}/resource/${o19}`, params: { ledger_version: r16 == null ? void 0 : r16.ledgerVersion } });
  return s17.data;
}
async function Q2(e2) {
  let { aptosConfig: n24, authenticationKey: t25, options: o19 } = e2, r16 = await K({ aptosConfig: n24, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: o19 }), { address_map: { handle: s17 } } = r16, a19 = c.from(t25);
  try {
    let i34 = await C2({ aptosConfig: n24, handle: s17, data: { key: a19.toString(), key_type: "address", value_type: "address" }, options: o19 });
    return c.from(i34);
  } catch (i34) {
    if (i34 instanceof s3 && i34.data.error_code === "table_item_not_found")
      return a19;
    throw i34;
  }
}
async function lo(e2) {
  let { aptosConfig: n24, accountAddress: t25 } = e2, r16 = { owner_address: { _eq: c.from(t25).toStringLong() }, amount: { _gt: 0 } }, a19 = await p3({ aptosConfig: n24, query: { query: m, variables: { where_condition: r16 } }, originMethod: "getAccountTokensCount" });
  return a19.current_token_ownerships_v2_aggregate.aggregate ? a19.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function yo(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2, s17 = { owner_address: { _eq: c.from(t25).toStringLong() }, amount: { _gt: 0 } };
  (o19 == null ? void 0 : o19.tokenStandard) && (s17.token_standard = { _eq: o19 == null ? void 0 : o19.tokenStandard });
  let a19 = { query: l2, variables: { where_condition: s17, offset: o19 == null ? void 0 : o19.offset, limit: o19 == null ? void 0 : o19.limit, order_by: o19 == null ? void 0 : o19.orderBy } };
  return (await p3({ aptosConfig: n24, query: a19, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function mo(e2) {
  let { aptosConfig: n24, accountAddress: t25, collectionAddress: o19, options: r16 } = e2, s17 = c.from(t25).toStringLong(), a19 = c.from(o19).toStringLong(), i34 = { owner_address: { _eq: s17 }, current_token_data: { collection_id: { _eq: a19 } }, amount: { _gt: 0 } };
  (r16 == null ? void 0 : r16.tokenStandard) && (i34.token_standard = { _eq: r16 == null ? void 0 : r16.tokenStandard });
  let u11 = { query: p, variables: { where_condition: i34, offset: r16 == null ? void 0 : r16.offset, limit: r16 == null ? void 0 : r16.limit, order_by: r16 == null ? void 0 : r16.orderBy } };
  return (await p3({ aptosConfig: n24, query: u11, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function _o(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2, s17 = { owner_address: { _eq: c.from(t25).toStringLong() }, amount: { _gt: 0 } };
  (o19 == null ? void 0 : o19.tokenStandard) && (s17.current_collection = { token_standard: { _eq: o19 == null ? void 0 : o19.tokenStandard } });
  let a19 = { query: c2, variables: { where_condition: s17, offset: o19 == null ? void 0 : o19.offset, limit: o19 == null ? void 0 : o19.limit, order_by: o19 == null ? void 0 : o19.orderBy } };
  return (await p3({ aptosConfig: n24, query: a19, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function Co(e2) {
  let { aptosConfig: n24, accountAddress: t25 } = e2, o19 = c.from(t25).toStringLong(), s17 = await p3({ aptosConfig: n24, query: { query: g2, variables: { address: o19 } }, originMethod: "getAccountTransactionsCount" });
  return s17.account_transactions_aggregate.aggregate ? s17.account_transactions_aggregate.aggregate.count : 0;
}
async function ho(e2) {
  let { aptosConfig: n24, accountAddress: t25, coinType: o19 } = e2, r16 = c.from(t25).toStringLong(), s17 = await I2({ aptosConfig: n24, accountAddress: r16, options: { where: { asset_type: { _eq: o19 } } } });
  return s17[0] ? s17[0].amount : 0;
}
async function I2(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2, r16 = c.from(t25).toStringLong(), s17 = { ...o19 == null ? void 0 : o19.where, owner_address: { _eq: r16 } }, a19 = { query: u, variables: { where_condition: s17, offset: o19 == null ? void 0 : o19.offset, limit: o19 == null ? void 0 : o19.limit, order_by: o19 == null ? void 0 : o19.orderBy } };
  return (await p3({ aptosConfig: n24, query: a19, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function wo(e2) {
  let { aptosConfig: n24, accountAddress: t25 } = e2, o19 = c.from(t25).toStringLong(), s17 = await p3({ aptosConfig: n24, query: { query: _2, variables: { address: o19 } }, originMethod: "getAccountCoinsCount" });
  if (!s17.current_fungible_asset_balances_aggregate.aggregate)
    throw Error("Failed to get the count of account coins");
  return s17.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function ko(e2) {
  let { aptosConfig: n24, accountAddress: t25, options: o19 } = e2, s17 = { owner_address: { _eq: c.from(t25).toStringLong() } }, a19 = { query: d, variables: { where_condition: s17, offset: o19 == null ? void 0 : o19.offset, limit: o19 == null ? void 0 : o19.limit, order_by: o19 == null ? void 0 : o19.orderBy } };
  return (await p3({ aptosConfig: n24, query: a19, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function To(e2) {
  let { aptosConfig: n24, privateKey: t25 } = e2, o19 = new b5(t25.publicKey());
  if (t25 instanceof f8) {
    let s17 = c5.fromPublicKeyAndScheme({ publicKey: o19, scheme: 2 }).derivedAddress();
    return o12.fromPrivateKeyAndAddress({ privateKey: t25, address: s17 });
  }
  if (t25 instanceof S4) {
    let r16 = c5.fromPublicKeyAndScheme({ publicKey: o19, scheme: 2 });
    if (await G4({ authKey: r16, aptosConfig: n24 })) {
      let u11 = r16.derivedAddress();
      return o12.fromPrivateKeyAndAddress({ privateKey: t25, address: u11, legacy: false });
    }
    let a19 = c5.fromPublicKeyAndScheme({ publicKey: o19.publicKey, scheme: 0 });
    if (await G4({ authKey: a19, aptosConfig: n24 })) {
      let u11 = a19.derivedAddress();
      return o12.fromPrivateKeyAndAddress({ privateKey: t25, address: u11, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${t25}`);
}
async function G4(e2) {
  let { aptosConfig: n24, authKey: t25 } = e2, o19 = await Q2({ aptosConfig: n24, authenticationKey: t25.derivedAddress() });
  try {
    return await M2({ aptosConfig: n24, accountAddress: o19 }), true;
  } catch (r16) {
    if (r16.status === 404)
      return false;
    throw new Error(`Error while looking for an account info ${o19.toString()}`);
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CRFZIYSY.mjs
var R3 = new TextEncoder();
function Z2(e2) {
  return (e2 == null ? void 0 : e2.map((n24) => D2(n24) ? Z(n24) : n24)) ?? [];
}
async function P3(e2, n24, t25, i34) {
  var _a;
  let f13 = (_a = (await Ao({ aptosConfig: i34, accountAddress: e2, moduleName: n24 })).abi) == null ? void 0 : _a.exposed_functions.find((o19) => o19.name === t25);
  if (!f13)
    throw new Error(`Could not find entry function ABI for '${e2}::${n24}::${t25}'`);
  if (!f13.is_entry)
    throw new Error(`'${e2}::${n24}::${t25}' is not an entry function`);
  let N7 = W(f13), g8 = [];
  for (let o19 = N7; o19 < f13.params.length; o19 += 1)
    g8.push(Z(f13.params[o19], { allowGenerics: true }));
  return { typeParameters: f13.generic_type_params, parameters: g8 };
}
function a14(e2, n24, t25, i34, u11) {
  if (i34 >= n24.parameters.length)
    throw new Error(`Too many arguments for '${e2}', expected ${n24.parameters.length}`);
  let f13 = n24.parameters[i34];
  return U6(t25, f13, i34, u11);
}
function U6(e2, n24, t25, i34) {
  return G3(e2) ? (m9(n24, e2, t25), e2) : X(e2, n24, t25, i34);
}
function X(e2, n24, t25, i34) {
  if (n24.isBool()) {
    if (M(e2))
      return new d3(e2);
    R2("boolean", t25);
  }
  if (n24.isAddress()) {
    if (D2(e2))
      return c.fromString(e2);
    R2("string | AccountAddress", t25);
  }
  if (n24.isU8()) {
    if (N4(e2))
      return new U3(e2);
    R2("number", t25);
  }
  if (n24.isU16()) {
    if (N4(e2))
      return new p6(e2);
    R2("number", t25);
  }
  if (n24.isU32()) {
    if (N4(e2))
      return new b3(e2);
    R2("number", t25);
  }
  if (n24.isU64()) {
    if (P(e2))
      return new y3(BigInt(e2));
    R2("bigint | number | string", t25);
  }
  if (n24.isU128()) {
    if (P(e2))
      return new m6(BigInt(e2));
    R2("bigint | number | string", t25);
  }
  if (n24.isU256()) {
    if (P(e2))
      return new B2(BigInt(e2));
    R2("bigint | number | string", t25);
  }
  if (n24.isGeneric()) {
    let u11 = n24.value;
    if (u11 < 0 || u11 >= i34.length)
      throw new Error(`Generic argument ${n24.toString()} is invalid for argument ${t25}`);
    return U6(e2, i34[u11], t25, i34);
  }
  if (n24.isVector()) {
    if (n24.value.isU8()) {
      if (D2(e2))
        return t7.U8(R3.encode(e2));
      if (e2 instanceof Uint8Array)
        return t7.U8(e2);
      if (e2 instanceof ArrayBuffer)
        return t7.U8(new Uint8Array(e2));
    }
    if (Array.isArray(e2))
      return new t7(e2.map((u11) => U6(u11, n24.value, t25, i34)));
    throw new Error(`Type mismatch for argument ${t25}, type '${n24.toString()}'`);
  }
  if (n24.isStruct()) {
    if (n24.isString()) {
      if (D2(e2))
        return new a3(e2);
      R2("string", t25);
    }
    if (n24.isObject()) {
      if (D2(e2))
        return c.fromString(e2);
      R2("string | AccountAddress", t25);
    }
    if (n24.isOption())
      return w4(e2) ? new z2(null) : new z2(U6(e2, n24.value.typeArgs[0], t25, i34));
    throw new Error(`Unsupported struct input type for argument ${t25}, type '${n24.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${t25}, type '${n24.toString()}'`);
}
function m9(e2, n24, t25) {
  if (e2.isBool()) {
    if (A6(n24))
      return;
    R2("Bool", t25);
  }
  if (e2.isAddress()) {
    if (T7(n24))
      return;
    R2("AccountAddress", t25);
  }
  if (e2.isU8()) {
    if (x4(n24))
      return;
    R2("U8", t25);
  }
  if (e2.isU16()) {
    if (S3(n24))
      return;
    R2("U16", t25);
  }
  if (e2.isU32()) {
    if (B3(n24))
      return;
    R2("U32", t25);
  }
  if (e2.isU64()) {
    if (U4(n24))
      return;
    R2("U64", t25);
  }
  if (e2.isU128()) {
    if (I(n24))
      return;
    R2("U128", t25);
  }
  if (e2.isU256()) {
    if (b4(n24))
      return;
    R2("U256", t25);
  }
  if (e2.isVector()) {
    if (n24 instanceof t7) {
      n24.values.length > 0 && m9(e2.value, n24.values[0], t25);
      return;
    }
    R2("MoveVector", t25);
  }
  if (e2 instanceof b2) {
    if (e2.isString()) {
      if (E3(n24))
        return;
      R2("MoveString", t25);
    }
    if (e2.isObject()) {
      if (T7(n24))
        return;
      R2("AccountAddress", t25);
    }
    if (e2.isOption()) {
      if (n24 instanceof z2) {
        n24.value !== void 0 && m9(e2.value.typeArgs[0], n24.value, t25);
        return;
      }
      R2("MoveOption", t25);
    }
  }
  throw new Error(`Type mismatch for argument ${t25}, expected '${e2.toString()}'`);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5PIO6MFF.mjs
var o13 = class t13 extends B {
  constructor(e2, r16) {
    super(), this.address = e2, this.name = r16;
  }
  static fromStr(e2) {
    let r16 = e2.split("::");
    if (r16.length !== 2)
      throw new Error("Invalid module id.");
    return new t13(c.fromString(r16[0]), new r4(r16[1]));
  }
  serialize(e2) {
    this.address.serialize(e2), this.name.serialize(e2);
  }
  static deserialize(e2) {
    let r16 = c.deserialize(e2), n24 = r4.deserialize(e2);
    return new t13(r16, n24);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4LUWUDBX.mjs
var t14 = class l7 extends B {
  constructor(e2) {
    super(), this.value = new t6(e2);
  }
  serialize(e2) {
    e2.serialize(this.value);
  }
  serializeForEntryFunction(e2) {
    e2.serializeU32AsUleb128(this.value.value.length), e2.serialize(this);
  }
  static deserialize(e2, s17) {
    let a19 = t6.deserialize(e2, s17);
    return new l7(a19.value);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VQM4LMCW.mjs
function D4(t25) {
  let e2 = t25.deserializeUleb128AsU32();
  switch (e2) {
    case 0:
      return U3.deserialize(t25);
    case 1:
      return y3.deserialize(t25);
    case 2:
      return m6.deserialize(t25);
    case 3:
      return c.deserialize(t25);
    case 4:
      return t7.deserialize(t25, U3);
    case 5:
      return d3.deserialize(t25);
    case 6:
      return p6.deserialize(t25);
    case 7:
      return b3.deserialize(t25);
    case 8:
      return B2.deserialize(t25);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e2}`);
  }
}
var a15 = class extends B {
  static deserialize(e2) {
    let r16 = e2.deserializeUleb128AsU32();
    switch (r16) {
      case 0:
        return A9.load(e2);
      case 2:
        return z3.load(e2);
      case 3:
        return h7.load(e2);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${r16}`);
    }
  }
};
var A9 = class t15 extends a15 {
  constructor(e2) {
    super(), this.script = e2;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(0), this.script.serialize(e2);
  }
  static load(e2) {
    let r16 = U7.deserialize(e2);
    return new t15(r16);
  }
};
var z3 = class t16 extends a15 {
  constructor(e2) {
    super(), this.entryFunction = e2;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(2), this.entryFunction.serialize(e2);
  }
  static load(e2) {
    let r16 = l8.deserialize(e2);
    return new t16(r16);
  }
};
var h7 = class t17 extends a15 {
  constructor(e2) {
    super(), this.multiSig = e2;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(3), this.multiSig.serialize(e2);
  }
  static load(e2) {
    let r16 = f10.deserialize(e2);
    return new t17(r16);
  }
};
var l8 = class t18 {
  constructor(e2, r16, i34, n24) {
    this.module_name = e2, this.function_name = r16, this.type_args = i34, this.args = n24;
  }
  static build(e2, r16, i34, n24) {
    return new t18(o13.fromStr(e2), new r4(r16), i34, n24);
  }
  serialize(e2) {
    this.module_name.serialize(e2), this.function_name.serialize(e2), e2.serializeVector(this.type_args), e2.serializeU32AsUleb128(this.args.length), this.args.forEach((r16) => {
      r16.serializeForEntryFunction(e2);
    });
  }
  static deserialize(e2) {
    let r16 = o13.deserialize(e2), i34 = r4.deserialize(e2), n24 = e2.deserializeVector(t5), o19 = e2.deserializeUleb128AsU32(), s17 = new Array();
    for (let c10 = 0; c10 < o19; c10 += 1) {
      let M6 = e2.deserializeUleb128AsU32(), B6 = t14.deserialize(e2, M6);
      s17.push(B6);
    }
    return new t18(r16, i34, n24, s17);
  }
};
var U7 = class t19 {
  constructor(e2, r16, i34) {
    this.bytecode = e2, this.type_args = r16, this.args = i34;
  }
  serialize(e2) {
    e2.serializeBytes(this.bytecode), e2.serializeVector(this.type_args), e2.serializeU32AsUleb128(this.args.length), this.args.forEach((r16) => {
      r16.serializeForScriptFunction(e2);
    });
  }
  static deserialize(e2) {
    let r16 = e2.deserializeBytes(), i34 = e2.deserializeVector(t5), n24 = e2.deserializeUleb128AsU32(), o19 = new Array();
    for (let s17 = 0; s17 < n24; s17 += 1) {
      let c10 = D4(e2);
      o19.push(c10);
    }
    return new t19(r16, i34, o19);
  }
};
var f10 = class t20 {
  constructor(e2, r16) {
    this.multisig_address = e2, this.transaction_payload = r16;
  }
  serialize(e2) {
    this.multisig_address.serialize(e2), this.transaction_payload === void 0 ? e2.serializeBool(false) : (e2.serializeBool(true), this.transaction_payload.serialize(e2));
  }
  static deserialize(e2) {
    let r16 = c.deserialize(e2), i34 = e2.deserializeBool(), n24;
    return i34 && (n24 = b6.deserialize(e2)), new t20(r16, n24);
  }
};
var b6 = class t21 extends B {
  constructor(e2) {
    super(), this.transaction_payload = e2;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(0), this.transaction_payload.serialize(e2);
  }
  static deserialize(e2) {
    return e2.deserializeUleb128AsU32(), new t21(l8.deserialize(e2));
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TWHTXYMB.mjs
var r11 = class a16 extends B {
  constructor(e2) {
    super(), this.chainId = e2;
  }
  serialize(e2) {
    e2.serializeU8(this.chainId);
  }
  static deserialize(e2) {
    let s17 = e2.deserializeU8();
    return new a16(s17);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NA2H44NE.mjs
var t22 = class i27 extends B {
  constructor(e2, s17, a19, r16, c10, d10, l12) {
    super(), this.sender = e2, this.sequence_number = s17, this.payload = a19, this.max_gas_amount = r16, this.gas_unit_price = c10, this.expiration_timestamp_secs = d10, this.chain_id = l12;
  }
  serialize(e2) {
    this.sender.serialize(e2), e2.serializeU64(this.sequence_number), this.payload.serialize(e2), e2.serializeU64(this.max_gas_amount), e2.serializeU64(this.gas_unit_price), e2.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e2);
  }
  static deserialize(e2) {
    let s17 = c.deserialize(e2), a19 = e2.deserializeU64(), r16 = a15.deserialize(e2), c10 = e2.deserializeU64(), d10 = e2.deserializeU64(), l12 = e2.deserializeU64(), m13 = r11.deserialize(e2);
    return new i27(s17, a19, r16, c10, d10, l12, m13);
  }
};
var o14 = class extends B {
  static deserialize(e2) {
    let s17 = e2.deserializeUleb128AsU32();
    switch (s17) {
      case 0:
        return u6.load(e2);
      case 1:
        return p9.load(e2);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${s17}`);
    }
  }
};
var u6 = class i28 extends o14 {
  constructor(e2, s17) {
    super(), this.raw_txn = e2, this.secondary_signer_addresses = s17;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(0), this.raw_txn.serialize(e2), e2.serializeVector(this.secondary_signer_addresses);
  }
  static load(e2) {
    let s17 = t22.deserialize(e2), a19 = e2.deserializeVector(c);
    return new i28(s17, a19);
  }
};
var p9 = class i29 extends o14 {
  constructor(e2, s17, a19) {
    super(), this.raw_txn = e2, this.secondary_signer_addresses = s17, this.fee_payer_address = a19;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(1), this.raw_txn.serialize(e2), e2.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e2);
  }
  static load(e2) {
    let s17 = t22.deserialize(e2), a19 = e2.deserializeVector(c), r16 = c.deserialize(e2);
    return new i29(s17, a19, r16);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MUKBXGU3.mjs
var n15 = class extends B {
  static deserialize(e2) {
    let r16 = e2.deserializeUleb128AsU32();
    switch (r16) {
      case 0:
        return o15.load(e2);
      case 1:
        return d7.load(e2);
      case 2:
        return u7.load(e2);
      case 3:
        return l9.load(e2);
      case 4:
        return A10.load(e2);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${r16}`);
    }
  }
};
var o15 = class s11 extends n15 {
  constructor(e2, r16) {
    super(), this.public_key = e2, this.signature = r16;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(0), this.public_key.serialize(e2), this.signature.serialize(e2);
  }
  static load(e2) {
    let r16 = m8.deserialize(e2), t25 = y5.deserialize(e2);
    return new s11(r16, t25);
  }
};
var d7 = class s12 extends n15 {
  constructor(e2, r16) {
    super(), this.public_key = e2, this.signature = r16;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(1), this.public_key.serialize(e2), this.signature.serialize(e2);
  }
  static load(e2) {
    let r16 = d6.deserialize(e2), t25 = y6.deserialize(e2);
    return new s12(r16, t25);
  }
};
var u7 = class s13 extends n15 {
  constructor(e2, r16, t25) {
    super(), this.sender = e2, this.secondary_signer_addresses = r16, this.secondary_signers = t25;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(2), this.sender.serialize(e2), e2.serializeVector(this.secondary_signer_addresses), e2.serializeVector(this.secondary_signers);
  }
  static load(e2) {
    let r16 = r10.deserialize(e2), t25 = e2.deserializeVector(c), c10 = e2.deserializeVector(r10);
    return new s13(r16, t25, c10);
  }
};
var l9 = class s14 extends n15 {
  constructor(e2, r16, t25, c10) {
    super(), this.sender = e2, this.secondary_signer_addresses = r16, this.secondary_signers = t25, this.fee_payer = c10;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(3), this.sender.serialize(e2), e2.serializeVector(this.secondary_signer_addresses), e2.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e2), this.fee_payer.authenticator.serialize(e2);
  }
  static load(e2) {
    let r16 = r10.deserialize(e2), t25 = e2.deserializeVector(c), c10 = e2.deserializeVector(r10), _6 = c.deserialize(e2), z5 = r10.deserialize(e2), S7 = { address: _6, authenticator: z5 };
    return new s14(r16, t25, c10, S7);
  }
};
var A10 = class s15 extends n15 {
  constructor(e2) {
    super(), this.sender = e2;
  }
  serialize(e2) {
    e2.serializeU32AsUleb128(4), this.sender.serialize(e2);
  }
  static load(e2) {
    let r16 = r10.deserialize(e2);
    return new s15(r16);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DPFAQBMX.mjs
var n16 = class o16 extends B {
  constructor(t25, a19) {
    super(), this.raw_txn = t25, this.authenticator = a19;
  }
  serialize(t25) {
    this.raw_txn.serialize(t25), this.authenticator.serialize(t25);
  }
  static deserialize(t25) {
    let a19 = t22.deserialize(t25), s17 = n15.deserialize(t25);
    return new o16(a19, s17);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VDQYAGHU.mjs
var n17 = { mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql", testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql", devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql", randomnet: "https://indexer-randomnet.hasura.app/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
var o17 = { mainnet: "https://api.mainnet.aptoslabs.com/v1", testnet: "https://api.testnet.aptoslabs.com/v1", devnet: "https://api.devnet.aptoslabs.com/v1", randomnet: "https://fullnode.random.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
var a17 = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", randomnet: "https://faucet.random.aptoslabs.com", local: "http://127.0.0.1:8081" };
var e = ((t25) => (t25.MAINNET = "mainnet", t25.TESTNET = "testnet", t25.DEVNET = "devnet", t25.RANDOMNET = "randomnet", t25.LOCAL = "local", t25.CUSTOM = "custom", t25))(e || {});
var s16 = { mainnet: 1, testnet: 2, randomnet: 70 };
var r12 = { mainnet: "mainnet", testnet: "testnet", devnet: "devnet", randomnet: "randomnet", local: "local", custom: "custom" };

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FWSOYEN6.mjs
async function Fn(n24) {
  if ($3(n24))
    return cn(n24);
  let { moduleAddress: e2, moduleName: t25, functionName: r16 } = L2(n24.function), o19 = await m4(async () => P3(e2, t25, r16, n24.aptosConfig), `entry-function-${n24.aptosConfig.network}-${e2}-${t25}-${r16}`, 1e3 * 60 * 5)();
  return sn({ abi: o19, ...n24 });
}
function sn(n24) {
  let e2 = n24.abi, { moduleAddress: t25, moduleName: r16, functionName: o19 } = L2(n24.function), a19 = Z2(n24.typeArguments);
  if (a19.length !== e2.typeParameters.length)
    throw new Error(`Type argument count mismatch, expected ${e2.typeParameters.length}, received ${a19.length}`);
  let i34 = n24.functionArguments.map((s17, A13) => a14(n24.function, e2, s17, A13, a19));
  if (i34.length !== e2.parameters.length)
    throw new Error(`Too few arguments for '${t25}::${r16}::${o19}', expected ${e2.parameters.length} but got ${i34.length}`);
  let c10 = l8.build(`${t25}::${r16}`, o19, a19, i34);
  if ("multisigAddress" in n24) {
    let s17 = c.from(n24.multisigAddress);
    return new h7(new f10(s17, new b6(c10)));
  }
  return new z3(c10);
}
function cn(n24) {
  return new A9(new U7(i.fromHexInput(n24.bytecode).toUint8Array(), n24.typeArguments ?? [], n24.functionArguments));
}
async function un(n24) {
  let { aptosConfig: e2, sender: t25, payload: r16, options: o19, feePayerAddress: a19 } = n24, i34 = s16[e2.network] ? Promise.resolve({ chain_id: s16[e2.network] }) : l4({ aptosConfig: e2 }), c10 = (o19 == null ? void 0 : o19.gasUnitPrice) ? Promise.resolve({ gas_estimate: o19.gasUnitPrice }) : L({ aptosConfig: e2 }), [{ chain_id: s17 }, { gas_estimate: A13 }] = await Promise.all([i34, c10]), y12 = (o19 == null ? void 0 : o19.accountSequenceNumber) !== void 0 ? Promise.resolve({ sequence_number: o19.accountSequenceNumber }) : M2({ aptosConfig: e2, accountAddress: t25 }), m13;
  if (a19 && c.from(a19).equals(c.ZERO))
    try {
      let { sequence_number: l12 } = await y12;
      m13 = l12;
    } catch {
      m13 = "0";
    }
  else {
    let { sequence_number: l12 } = await y12;
    m13 = l12;
  }
  let { maxGasAmount: en, gasUnitPrice: an, expireTimestamp: rn } = { maxGasAmount: (o19 == null ? void 0 : o19.maxGasAmount) ? BigInt(o19.maxGasAmount) : BigInt(2e5), gasUnitPrice: BigInt(A13), expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + 20), ...o19 };
  return new t22(c.from(t25), BigInt(m13), r16, BigInt(en), BigInt(an), BigInt(rn), new r11(s17));
}
async function Nn(n24) {
  var _a;
  let { aptosConfig: e2, sender: t25, payload: r16, options: o19, feePayerAddress: a19 } = n24, i34 = await un({ aptosConfig: e2, sender: t25, payload: r16, options: o19, feePayerAddress: a19 });
  if ("secondarySignerAddresses" in n24) {
    let c10 = ((_a = n24.secondarySignerAddresses) == null ? void 0 : _a.map((s17) => c.from(s17))) ?? [];
    return { rawTransaction: i34, secondarySignerAddresses: c10, feePayerAddress: n24.feePayerAddress ? c.from(n24.feePayerAddress) : void 0 };
  }
  return { rawTransaction: i34, feePayerAddress: n24.feePayerAddress ? c.from(n24.feePayerAddress) : void 0 };
}
function Wn(n24) {
  let { signerPublicKey: e2, transaction: t25, secondarySignersPublicKeys: r16, feePayerPublicKey: o19 } = n24, a19 = h8(e2);
  if (t25.feePayerAddress) {
    let c10 = new p9(t25.rawTransaction, t25.secondarySignerAddresses ?? [], t25.feePayerAddress), s17 = [];
    r16 && (s17 = r16.map((m13) => h8(m13)));
    let A13 = h8(o19), y12 = new l9(a19, t25.secondarySignerAddresses ?? [], s17, { address: t25.feePayerAddress, authenticator: A13 });
    return new n16(c10.raw_txn, y12).bcsToBytes();
  }
  if (t25.secondarySignerAddresses) {
    let c10 = new u6(t25.rawTransaction, t25.secondarySignerAddresses), s17 = [];
    s17 = r16.map((y12) => h8(y12));
    let A13 = new u7(a19, t25.secondarySignerAddresses, s17);
    return new n16(c10.raw_txn, A13).bcsToBytes();
  }
  let i34;
  if (a19 instanceof n13)
    i34 = new o15(a19.public_key, a19.signature);
  else if (a19 instanceof u5)
    i34 = new A10(a19);
  else
    throw new Error("Invalid public key");
  return new n16(t25.rawTransaction, i34).bcsToBytes();
}
function h8(n24) {
  if (n24 instanceof b5) {
    if (n24.publicKey instanceof m8)
      return new u5(n24, new o11(new y5(new Uint8Array(64))));
    if (n24.publicKey instanceof u4)
      return new u5(n24, new o11(new y7(new Uint8Array(64))));
  }
  return new n13(new m8(n24.toUint8Array()), new y5(new Uint8Array(64)));
}
function Gn(n24) {
  let { signer: e2, transaction: t25 } = n24, r16 = An(t25);
  return e2.signWithAuthenticator(r16);
}
function Un(n24) {
  let { transaction: e2, senderAuthenticator: t25, feePayerAuthenticator: r16, additionalSignersAuthenticators: o19 } = n24, a19 = tn(e2);
  if ((r16 || o19) && (a19 instanceof u6 || a19 instanceof p9))
    return dn(a19, t25, r16, o19);
  if (t25 instanceof n13 && a19 instanceof t22) {
    let i34 = new o15(t25.public_key, t25.signature);
    return new n16(a19, i34).bcsToBytes();
  }
  if ((t25 instanceof u5 || t25 instanceof l6) && a19 instanceof t22) {
    let i34 = new A10(t25);
    return new n16(a19, i34).bcsToBytes();
  }
  throw new Error(`Cannot generate a signed transaction, ${t25} is not a supported account authentication scheme`);
}
function tn(n24) {
  return n24.feePayerAddress ? new p9(n24.rawTransaction, n24.secondarySignerAddresses ?? [], n24.feePayerAddress) : n24.secondarySignerAddresses ? new u6(n24.rawTransaction, n24.secondarySignerAddresses) : n24.rawTransaction;
}
function dn(n24, e2, t25, r16) {
  if (n24 instanceof p9) {
    if (!t25)
      throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    let o19 = new l9(e2, n24.secondary_signer_addresses, r16 ?? [], { address: n24.fee_payer_address, authenticator: t25 });
    return new n16(n24.raw_txn, o19).bcsToBytes();
  }
  if (n24 instanceof u6) {
    if (!r16)
      throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    let o19 = new u7(e2, n24.secondary_signer_addresses, r16 ?? []);
    return new n16(n24.raw_txn, o19).bcsToBytes();
  }
  throw new Error(`Cannot prepare multi signers transaction to submission, ${typeof n24} transaction is not supported`);
}
function An(n24) {
  let e2 = tn(n24), t25 = sha3_256.create();
  if (e2 instanceof t22)
    t25.update(T4);
  else if (e2 instanceof u6)
    t25.update(o4);
  else if (e2 instanceof p9)
    t25.update(o4);
  else
    throw new Error(`Unknown transaction type to sign on: ${e2}`);
  let r16 = t25.digest(), o19 = e2.bcsToBytes(), a19 = new Uint8Array(r16.length + o19.length);
  return a19.set(r16), a19.set(o19, r16.length), a19;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-53UNV6UP.mjs
var c6 = class extends B {
  constructor(e2) {
    super();
    this.accountAddress = c.ONE;
    this.moduleName = new a3("account");
    this.structName = new a3("RotationProofChallenge");
    this.sequenceNumber = new y3(e2.sequenceNumber), this.originator = e2.originator, this.currentAuthKey = e2.currentAuthKey, this.newPublicKey = t7.U8(e2.newPublicKey.toUint8Array());
  }
  serialize(e2) {
    e2.serialize(this.accountAddress), e2.serialize(this.moduleName), e2.serialize(this.structName), e2.serialize(this.sequenceNumber), e2.serialize(this.originator), e2.serialize(this.currentAuthKey), e2.serialize(this.newPublicKey);
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XC72DIJB.mjs
async function h9(t25) {
  let a19 = await D5(t25);
  return G5(t25, a19);
}
async function D5(t25) {
  let { aptosConfig: a19, data: n24 } = t25, e2, o19;
  return "bytecode" in n24 ? o19 = await Fn(n24) : "multisigAddress" in n24 ? n24.abi ? o19 = sn({ abi: n24.abi, ...n24 }) : (e2 = { aptosConfig: a19, multisigAddress: n24.multisigAddress, function: n24.function, functionArguments: n24.functionArguments, typeArguments: n24.typeArguments }, o19 = await Fn(e2)) : n24.abi ? o19 = sn({ abi: n24.abi, ...n24 }) : (e2 = { aptosConfig: a19, function: n24.function, functionArguments: n24.functionArguments, typeArguments: n24.typeArguments }, o19 = await Fn(e2)), o19;
}
async function G5(t25, a19) {
  let { aptosConfig: n24, sender: e2, options: o19 } = t25, i34;
  if (U8(t25) && (i34 = c.ZERO.toString()), _3(t25)) {
    let { secondarySignerAddresses: c10 } = t25;
    return Nn({ aptosConfig: n24, sender: e2, payload: a19, options: o19, secondarySignerAddresses: c10, feePayerAddress: i34 });
  }
  return Nn({ aptosConfig: n24, sender: e2, payload: a19, options: o19, feePayerAddress: i34 });
}
function U8(t25) {
  return t25.withFeePayer === true;
}
function _3(t25) {
  return "secondarySignerAddresses" in t25;
}
function Y(t25) {
  let { transaction: a19 } = t25;
  return An(a19);
}
function K2(t25) {
  return Gn({ ...t25 });
}
async function $4(t25) {
  var _a, _b, _c;
  let { aptosConfig: a19, transaction: n24, signerPublicKey: e2, secondarySignersPublicKeys: o19, feePayerPublicKey: i34, options: c10 } = t25, u11 = Wn({ transaction: n24, signerPublicKey: e2, secondarySignersPublicKeys: o19, feePayerPublicKey: i34, options: c10 }), { data: A13 } = await A3({ aptosConfig: a19, body: u11, path: "transactions/simulate", params: { estimate_gas_unit_price: ((_a = t25.options) == null ? void 0 : _a.estimateGasUnitPrice) ?? false, estimate_max_gas_amount: ((_b = t25.options) == null ? void 0 : _b.estimateMaxGasAmount) ?? false, estimate_prioritized_gas_unit_price: ((_c = t25.options) == null ? void 0 : _c.estimatePrioritizedGasUnitPrice) ?? false }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return A13;
}
async function B4(t25) {
  let { aptosConfig: a19 } = t25, n24 = Un({ ...t25 }), { data: e2 } = await A3({ aptosConfig: a19, body: n24, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return e2;
}
async function M3(t25) {
  let { aptosConfig: a19, signer: n24, transaction: e2 } = t25, o19 = K2({ signer: n24, transaction: e2 });
  return B4({ aptosConfig: a19, transaction: e2, senderAuthenticator: o19 });
}
var v3 = { typeParameters: [], parameters: [y2.u8(), new y2(y2.u8())] };
async function nn(t25) {
  let { aptosConfig: a19, account: n24, metadataBytes: e2, moduleBytecode: o19, options: i34 } = t25, c10 = o19.map((u11) => t7.U8(u11));
  return h9({ aptosConfig: a19, sender: c.from(n24), data: { function: "0x1::code::publish_package_txn", functionArguments: [t7.U8(e2), new t7(c10)], abi: v3 }, options: i34 });
}
var N5 = { typeParameters: [], parameters: [new u3(), y2.u8(), new u3(), y2.u8(), y2.u8(), y2.u8()] };
async function tn2(t25) {
  let { aptosConfig: a19, fromAccount: n24, toNewPrivateKey: e2 } = t25, o19 = await M2({ aptosConfig: a19, accountAddress: n24.accountAddress }), i34 = o12.fromPrivateKey({ privateKey: e2, legacy: true }), u11 = new c6({ sequenceNumber: BigInt(o19.sequence_number), originator: n24.accountAddress, currentAuthKey: c.from(o19.authentication_key), newPublicKey: i34.publicKey }).bcsToBytes(), A13 = n24.sign(u11), R6 = i34.sign(u11), x9 = await h9({ aptosConfig: a19, sender: n24.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new U3(n24.signingScheme.valueOf()), t7.U8(n24.publicKey.toUint8Array()), new U3(i34.signingScheme.valueOf()), t7.U8(i34.publicKey.toUint8Array()), t7.U8(A13.toUint8Array()), t7.U8(R6.toUint8Array())], abi: N5 } });
  return M3({ aptosConfig: a19, signer: n24, transaction: x9 });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-55ZTOGLK.mjs
var i30 = class {
  constructor(n24) {
    this.config = n24;
  }
  async simple(n24) {
    return $4({ aptosConfig: this.config, ...n24 });
  }
  async multiAgent(n24) {
    return $4({ aptosConfig: this.config, ...n24 });
  }
};
j([u2], i30.prototype, "simple", 1), j([u2], i30.prototype, "multiAgent", 1);

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5ZWPTGVN.mjs
var n18 = class {
  constructor(t25) {
    this.config = t25;
  }
  async simple(t25) {
    return B4({ aptosConfig: this.config, ...t25 });
  }
  async multiAgent(t25) {
    return B4({ aptosConfig: this.config, ...t25 });
  }
};
j([o5], n18.prototype, "simple", 1), j([o5], n18.prototype, "multiAgent", 1);

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6QYEWG7L.mjs
var o18 = class {
  constructor(n24) {
    this.config = n24;
  }
  async simple(n24) {
    return h9({ aptosConfig: this.config, ...n24 });
  }
  async multiAgent(n24) {
    return h9({ aptosConfig: this.config, ...n24 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DO7NVHJS.mjs
var n19 = () => Math.floor(Date.now() / 1e3);
var r13 = class {
  constructor(t25, i34, o19, a19, c10) {
    this.lastUncommintedNumber = null;
    this.currentNumber = null;
    this.lock = false;
    this.aptosConfig = t25, this.account = i34, this.maxWaitTime = o19, this.maximumInFlight = a19, this.sleepTime = c10;
  }
  async nextSequenceNumber() {
    for (; this.lock; )
      await r3(this.sleepTime);
    this.lock = true;
    let t25 = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let i34 = n19();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; )
          await r3(this.sleepTime), n19() - i34 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      t25 = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (i34) {
      console.error("error in getting next sequence number for this account", i34);
    } finally {
      this.lock = false;
    }
    return t25;
  }
  async initialize() {
    let { sequence_number: t25 } = await M2({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(t25), this.lastUncommintedNumber = BigInt(t25);
  }
  async update() {
    let { sequence_number: t25 } = await M2({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(t25), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; )
        await r3(this.sleepTime);
      this.lock = true;
      try {
        await this.update();
        let t25 = n19();
        for (; this.lastUncommintedNumber !== this.currentNumber; )
          n19() - t25 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await r3(this.sleepTime), await this.update());
      } catch (t25) {
        console.error("error in synchronizing this account sequence number with the one on chain", t25);
      } finally {
        this.lock = false;
      }
    }
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-U6Z4FNB7.mjs
var i31 = class {
  constructor() {
    this.queue = [];
    this.pendingDequeue = [];
    this.cancelled = false;
  }
  enqueue(e2) {
    var _a;
    if (this.cancelled = false, this.pendingDequeue.length > 0) {
      (_a = this.pendingDequeue.shift()) == null ? void 0 : _a.resolve(e2);
      return;
    }
    this.queue.push(e2);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e2, u11) => {
      this.pendingDequeue.push({ resolve: e2, reject: u11 });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e2 }) => {
      e2(new n20("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
};
var n20 = class extends Error {
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4YQVJTW7.mjs
var p10 = "fulfilled";
var T8 = ((n24) => (n24.TransactionSent = "transactionSent", n24.TransactionSendFailed = "transactionSendFailed", n24.TransactionExecuted = "transactionExecuted", n24.TransactionExecutionFailed = "transactionExecutionFailed", n24.ExecutionFinish = "executionFinish", n24))(T8 || {});
var m10 = class extends eventemitter3_default {
  constructor(t25, e2, a19 = 30, n24 = 100, i34 = 10) {
    super();
    this.taskQueue = new i31();
    this.transactionsQueue = new i31();
    this.outstandingTransactions = new i31();
    this.sentTransactions = [];
    this.executedTransactions = [];
    this.aptosConfig = t25, this.account = e2, this.started = false, this.accountSequnceNumber = new r13(t25, e2, a19, n24, i34);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let t25 = await this.accountSequnceNumber.nextSequenceNumber();
        if (t25 === null)
          return;
        let e2 = await this.generateNextTransaction(this.account, t25);
        if (!e2)
          return;
        let a19 = M3({ aptosConfig: this.aptosConfig, transaction: e2, signer: this.account });
        await this.outstandingTransactions.enqueue([a19, t25]);
      }
    } catch (t25) {
      if (t25 instanceof n20)
        return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t25}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let t25 = [], e2 = [], [a19, n24] = await this.outstandingTransactions.dequeue();
        for (t25.push(a19), e2.push(n24); !this.outstandingTransactions.isEmpty(); )
          [a19, n24] = await this.outstandingTransactions.dequeue(), t25.push(a19), e2.push(n24);
        let i34 = await Promise.allSettled(t25);
        for (let s17 = 0; s17 < i34.length && s17 < e2.length; s17 += 1) {
          let r16 = i34[s17];
          n24 = e2[s17], r16.status === p10 ? (this.sentTransactions.push([r16.value.hash, n24, null]), this.emit("transactionSent", { message: `transaction hash ${r16.value.hash} has been committed to chain`, transactionHash: r16.value.hash }), await this.checkTransaction(r16, n24)) : (this.sentTransactions.push([r16.status, n24, r16.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${r16.reason}`, error: r16.reason }));
        }
        this.emit("executionFinish", { message: `execute ${i34.length} transactions finished` });
      }
    } catch (t25) {
      if (t25 instanceof n20)
        return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t25}`);
    }
  }
  async checkTransaction(t25, e2) {
    try {
      let a19 = [];
      a19.push(G2({ aptosConfig: this.aptosConfig, transactionHash: t25.value.hash }));
      let n24 = await Promise.allSettled(a19);
      for (let i34 = 0; i34 < n24.length; i34 += 1) {
        let s17 = n24[i34];
        s17.status === p10 ? (this.executedTransactions.push([s17.value.hash, e2, null]), this.emit("transactionExecuted", { message: `transaction hash ${s17.value.hash} has been executed on chain`, transactionHash: t25.value.hash })) : (this.executedTransactions.push([s17.status, e2, s17.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${s17.reason}`, error: s17.reason }));
      }
    } catch (a19) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${a19}`);
    }
  }
  async push(t25, e2) {
    this.transactionsQueue.enqueue([t25, e2]);
  }
  async generateNextTransaction(t25, e2) {
    if (this.transactionsQueue.isEmpty())
      return;
    let [a19, n24] = await this.transactionsQueue.dequeue();
    return h9({ aptosConfig: this.aptosConfig, sender: t25.accountAddress, data: a19, options: { ...n24, accountSequenceNumber: e2 } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); )
        await (await this.taskQueue.dequeue())();
    } catch (t25) {
      throw new Error(`Unable to start transaction batching: ${t25}`);
    }
  }
  start() {
    if (this.started)
      throw new Error("worker has already started");
    this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled())
      throw new Error("worker has already stopped");
    this.started = false, this.taskQueue.cancel();
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6T3V5NIN.mjs
var i32 = class extends eventemitter3_default {
  constructor(t25) {
    super(), this.config = t25;
  }
  start(t25) {
    let { sender: n24 } = t25;
    this.account = n24, this.transactionWorker = new m10(this.config, n24), this.transactionWorker.start(), this.registerToEvents();
  }
  push(t25) {
    let { data: n24, options: o19 } = t25;
    for (let r16 of n24)
      this.transactionWorker.push(r16, o19);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (t25) => {
      this.emit("transactionSent", t25);
    }), this.transactionWorker.on("transactionSendFailed", async (t25) => {
      this.emit("transactionSendFailed", t25);
    }), this.transactionWorker.on("transactionExecuted", async (t25) => {
      this.emit("transactionExecuted", t25);
    }), this.transactionWorker.on("transactionExecutionFailed", async (t25) => {
      this.emit("transactionExecutionFailed", t25);
    }), this.transactionWorker.on("executionFinish", async (t25) => {
      this.emit("executionFinish", t25);
    });
  }
  forSingleAccount(t25) {
    try {
      let { sender: n24, data: o19, options: r16 } = t25;
      this.start({ sender: n24 }), this.push({ data: o19, options: r16 });
    } catch (n24) {
      throw new Error(`failed to submit transactions with error: ${n24}`);
    }
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-X5P4X7YY.mjs
var h10 = class {
  constructor(n24) {
    this.config = n24, this.build = new o18(this.config), this.simulate = new i30(this.config), this.submit = new n18(this.config), this.batch = new i32(this.config);
  }
  async getTransactions(n24) {
    return F({ aptosConfig: this.config, ...n24 });
  }
  async getTransactionByVersion(n24) {
    return v2({ aptosConfig: this.config, ...n24 });
  }
  async getTransactionByHash(n24) {
    return x2({ aptosConfig: this.config, ...n24 });
  }
  async isPendingTransaction(n24) {
    return N2({ aptosConfig: this.config, ...n24 });
  }
  async waitForTransaction(n24) {
    return G2({ aptosConfig: this.config, ...n24 });
  }
  async getGasPriceEstimation() {
    return L({ aptosConfig: this.config });
  }
  getSigningMessage(n24) {
    return Y(n24);
  }
  async publishPackageTransaction(n24) {
    return nn({ aptosConfig: this.config, ...n24 });
  }
  async rotateAuthKey(n24) {
    return tn2({ aptosConfig: this.config, ...n24 });
  }
  sign(n24) {
    return K2({ ...n24 });
  }
  signAsFeePayer(n24) {
    let { signer: t25, transaction: a19 } = n24;
    if (!a19.feePayerAddress)
      throw new Error(`Transaction ${a19} is not a Fee Payer transaction`);
    return a19.feePayerAddress = t25.accountAddress, K2({ signer: t25, transaction: a19 });
  }
  async batchTransactionsForSingleAccount(n24) {
    try {
      let { sender: t25, data: a19, options: P6 } = n24;
      this.batch.forSingleAccount({ sender: t25, data: a19, options: P6 });
    } catch (t25) {
      throw new Error(`failed to submit transactions with error: ${t25}`);
    }
  }
  async signAndSubmitTransaction(n24) {
    let { signer: t25, transaction: a19 } = n24;
    return M3({ aptosConfig: this.config, signer: t25, transaction: a19 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/bind.js
function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i34;
  let l12;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i34 = 0, l12 = obj.length; i34 < l12; i34++) {
      fn.call(null, obj[i34], i34, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i34 = 0; i34 < len; i34++) {
      key = keys[i34];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i34 = keys.length;
  let _key;
  while (i34-- > 0) {
    _key = keys[i34];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i34 = 0, l12 = arguments.length; i34 < l12; i34++) {
    arguments[i34] && forEach(arguments[i34], assignValue);
  }
  return result;
}
var extend = (a19, b10, thisArg, { allOwnKeys } = {}) => {
  forEach(b10, (val, key) => {
    if (thisArg && isFunction(val)) {
      a19[key] = bind(val, thisArg);
    } else {
      a19[key] = val;
    }
  }, { allOwnKeys });
  return a19;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i34;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i34 = props.length;
    while (i34-- > 0) {
      prop = props[i34];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i34 = thing.length;
  if (!isNumber(i34))
    return null;
  const arr = new Array(i34);
  while (i34-- > 0) {
    arr[i34] = thing[i34];
  }
  return arr;
};
var isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m13, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i34) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i34] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i34 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i34] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/null.js
var null_default = null;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i34) {
    token = removeBrackets(token);
    return !dots && i34 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils_default.forEach(this.handlers, function forEachHandler(h14) {
      if (h14 !== null) {
        fn(h14);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/common/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports2,
  ...browser_default
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i34;
  const len = keys.length;
  let key;
  for (i34 = 0; i34 < len; i34++) {
    key = keys[i34];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i34;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i34 = line.indexOf(":");
    key = line.substring(0, i34).trim().toLowerCase();
    val = line.substring(i34 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value))
    return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w5, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i34 = keys.length;
    let deleted = false;
    while (i34--) {
      const key = keys[i34];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes3 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes3[head] = chunkLength;
    timestamps[head] = now;
    let i34 = tail;
    let bytesCount = 0;
    while (i34 !== head) {
      bytesCount += bytes3[i34++];
      i34 = i34 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/adapters/xhr.js
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders_default.from(config.headers).normalize();
    let { responseType, withXSRFToken } = config;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils_default.isFormData(requestData)) {
      if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitional_default;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform_default.hasStandardBrowserEnv) {
      withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
      if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(fullPath)) {
        const xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies_default.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default
};
utils_default.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i34 = 0; i34 < length; i34++) {
      nameOrAdapter = adapters[i34];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i34] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s17 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s17,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a19, b10, caseless) {
    if (!utils_default.isUndefined(b10)) {
      return getMergedValue(a19, b10, caseless);
    } else if (!utils_default.isUndefined(a19)) {
      return getMergedValue(void 0, a19, caseless);
    }
  }
  function valueFromConfig2(a19, b10) {
    if (!utils_default.isUndefined(b10)) {
      return getMergedValue(void 0, b10);
    }
  }
  function defaultToConfig2(a19, b10) {
    if (!utils_default.isUndefined(b10)) {
      return getMergedValue(void 0, b10);
    } else if (!utils_default.isUndefined(a19)) {
      return getMergedValue(void 0, a19);
    }
  }
  function mergeDirectKeys(a19, b10, prop) {
    if (prop in config2) {
      return getMergedValue(a19, b10);
    } else if (prop in config1) {
      return getMergedValue(void 0, a19);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a19, b10) => mergeDeepProperties(headersToObject(a19), headersToObject(b10), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/env/data.js
var VERSION = "1.6.2";

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i34) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i34 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i34 = keys.length;
  while (i34-- > 0) {
    const opt = keys[i34];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i34 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i34 < len) {
        promise = promise.then(chain2[i34++], chain2[i34++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i34 = 0;
    while (i34 < len) {
      const onFulfilled = requestInterceptorChain[i34++];
      const onRejected = requestInterceptorChain[i34++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i34 = 0;
    len = responseInterceptorChain.length;
    while (i34 < len) {
      promise = promise.then(responseInterceptorChain[i34++], responseInterceptorChain[i34++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i34 = token._listeners.length;
      while (i34-- > 0) {
        token._listeners[i34](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c10) {
      cancel = c10;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// E:/Proj/HXProjs/lucky-pocket/node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/aptos-client/dist/browser/index.browser.mjs
async function aptosClient(options) {
  var _a;
  const { params, method, url, headers, body, overrides } = options;
  const requestConfig = {
    headers,
    method,
    url,
    params,
    data: body,
    withCredentials: (_a = overrides == null ? void 0 : overrides.WITH_CREDENTIALS) != null ? _a : true
  };
  try {
    const response = await axios_default(requestConfig);
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers,
      config: response.config
    };
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HLNZVTCO.mjs
var n21 = class {
  constructor(e2) {
    this.network = (e2 == null ? void 0 : e2.network) ?? "devnet", this.fullnode = e2 == null ? void 0 : e2.fullnode, this.faucet = e2 == null ? void 0 : e2.faucet, this.indexer = e2 == null ? void 0 : e2.indexer, this.client = (e2 == null ? void 0 : e2.client) ?? { provider: aptosClient }, this.clientConfig = (e2 == null ? void 0 : e2.clientConfig) ?? {};
  }
  getRequestUrl(e2) {
    switch (e2) {
      case 0:
        if (this.fullnode !== void 0)
          return this.fullnode;
        if (this.network === "custom")
          throw new Error("Please provide a custom full node url");
        return o17[this.network];
      case 2:
        if (this.faucet !== void 0)
          return this.faucet;
        if (this.network === "custom")
          throw new Error("Please provide a custom faucet url");
        return a17[this.network];
      case 1:
        if (this.indexer !== void 0)
          return this.indexer;
        if (this.network === "custom")
          throw new Error("Please provide a custom indexer url");
        return n17[this.network];
      default:
        throw Error(`apiType ${e2} is not supported`);
    }
  }
  isIndexerRequest(e2) {
    return n17[this.network] === e2;
  }
  isFullnodeRequest(e2) {
    return o17[this.network] === e2;
  }
  isFaucetRequest(e2) {
    return a17[this.network] === e2;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6UXBIUZJ.mjs
var u8 = { typeParameters: [{ constraints: [] }], parameters: [new S(), new p5()] };
async function y8(e2) {
  let { aptosConfig: i34, sender: s17, recipient: c10, amount: a19, coinType: p11, options: m13 } = e2;
  return h9({ aptosConfig: i34, sender: s17, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [p11 ?? N], functionArguments: [c10, a19], abi: u8 }, options: m13 });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LD47JFHP.mjs
var t23 = class {
  constructor(n24) {
    this.config = n24;
  }
  async transferCoinTransaction(n24) {
    return y8({ aptosConfig: this.config, ...n24 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DKCBAKHS.mjs
var C3 = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
var m11 = "0x4::token::Token";
async function _t(t25) {
  let { aptosConfig: o19, digitalAssetAddress: n24 } = t25, e2 = { token_data_id: { _eq: c.from(n24).toStringLong() } };
  return (await p3({ aptosConfig: o19, query: { query: Q, variables: { where_condition: e2 } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function Pt(t25) {
  let { aptosConfig: o19, digitalAssetAddress: n24 } = t25, e2 = { token_data_id: { _eq: c.from(n24).toStringLong() }, amount: { _gt: 0 } };
  return (await p3({ aptosConfig: o19, query: { query: q, variables: { where_condition: e2 } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function kt(t25) {
  let { aptosConfig: o19, ownerAddress: n24, options: e2 } = t25, r16 = { owner_address: { _eq: c.from(n24).toStringLong() }, amount: { _gt: 0 } }, i34 = { query: q, variables: { where_condition: r16, offset: e2 == null ? void 0 : e2.offset, limit: e2 == null ? void 0 : e2.limit, order_by: e2 == null ? void 0 : e2.orderBy } };
  return (await p3({ aptosConfig: o19, query: i34, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function Dt(t25) {
  let { aptosConfig: o19, digitalAssetAddress: n24, options: e2 } = t25, r16 = { token_data_id: { _eq: c.from(n24).toStringLong() } }, i34 = { query: C, variables: { where_condition: r16, offset: e2 == null ? void 0 : e2.offset, limit: e2 == null ? void 0 : e2.limit, order_by: e2 == null ? void 0 : e2.orderBy } };
  return (await p3({ aptosConfig: o19, query: i34, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var Q3 = { typeParameters: [], parameters: [new b2(E2()), new p5(), new b2(E2()), new b2(E2()), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new c4(), new p5(), new p5()] };
async function St(t25) {
  let { aptosConfig: o19, options: n24, creator: e2 } = t25;
  return h9({ aptosConfig: o19, sender: e2.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a3(t25.description), new y3(t25.maxSupply ?? _), new a3(t25.name), new a3(t25.uri), new d3(t25.mutableDescription ?? true), new d3(t25.mutableRoyalty ?? true), new d3(t25.mutableURI ?? true), new d3(t25.mutableTokenDescription ?? true), new d3(t25.mutableTokenName ?? true), new d3(t25.mutableTokenProperties ?? true), new d3(t25.mutableTokenURI ?? true), new d3(t25.tokensBurnableByCreator ?? true), new d3(t25.tokensFreezableByCreator ?? true), new y3(t25.royaltyNumerator ?? 0), new y3(t25.royaltyDenominator ?? 1)], abi: Q3 }, options: n24 });
}
async function U9(t25) {
  let { aptosConfig: o19, creatorAddress: n24, collectionName: e2, options: r16 } = t25, i34 = c.from(n24), a19 = { collection_name: { _eq: e2 }, creator_address: { _eq: i34.toStringLong() } };
  return (r16 == null ? void 0 : r16.tokenStandard) && (a19.token_standard = { _eq: (r16 == null ? void 0 : r16.tokenStandard) ?? "v2" }), (await p3({ aptosConfig: o19, query: { query: T, variables: { where_condition: a19 } }, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function vt(t25) {
  let { aptosConfig: o19, collectionId: n24 } = t25, r16 = { collection_id: { _eq: c.from(n24).toStringLong() } };
  return (await p3({ aptosConfig: o19, query: { query: T, variables: { where_condition: r16 } }, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function ht(t25) {
  return (await U9(t25)).collection_id;
}
var F3 = { typeParameters: [], parameters: [new b2(E2()), new b2(E2()), new b2(E2()), new b2(E2()), new y2(new b2(E2())), new y2(new b2(E2())), new y2(y2.u8())] };
async function xt(t25) {
  let { aptosConfig: o19, options: n24, creator: e2, collection: r16, description: i34, name: a19, uri: l12, propertyKeys: y12, propertyTypes: P6, propertyValues: _6 } = t25, k3 = P6 == null ? void 0 : P6.map((D7) => C3[D7]);
  return h9({ aptosConfig: o19, sender: e2.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a3(r16), new a3(i34), new a3(a19), new a3(l12), t7.MoveString(y12 ?? []), t7.MoveString(k3 ?? []), R4(_6 ?? [], k3 ?? [])], abi: F3 }, options: n24 });
}
var N6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new S()] };
async function Gt(t25) {
  let { aptosConfig: o19, sender: n24, digitalAssetAddress: e2, recipient: r16, digitalAssetType: i34, options: a19 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [i34 ?? m11], functionArguments: [c.from(e2), c.from(r16)], abi: N6 }, options: a19 });
}
var Y2 = { typeParameters: [], parameters: [new b2(E2()), new b2(E2()), new b2(E2()), new b2(E2()), new y2(new b2(E2())), new y2(new b2(E2())), new y2(y2.u8()), new S()] };
async function Bt(t25) {
  let { aptosConfig: o19, account: n24, collection: e2, description: r16, name: i34, uri: a19, recipient: l12, propertyKeys: y12, propertyTypes: P6, propertyValues: _6, options: k3 } = t25;
  if ((y12 == null ? void 0 : y12.length) !== (_6 == null ? void 0 : _6.length))
    throw new Error("Property keys and property values counts do not match");
  if ((P6 == null ? void 0 : P6.length) !== (_6 == null ? void 0 : _6.length))
    throw new Error("Property types and property values counts do not match");
  let D7 = P6 == null ? void 0 : P6.map((K4) => C3[K4]);
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [e2, r16, i34, a19, t7.MoveString(y12 ?? []), t7.MoveString(D7 ?? []), R4(_6 ?? [], D7 ?? []), l12], abi: Y2 }, options: k3 });
}
var z4 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0)))] };
async function Ot(t25) {
  let { aptosConfig: o19, creator: n24, digitalAssetAddress: e2, digitalAssetType: r16, options: i34 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [r16 ?? m11], functionArguments: [c.from(e2)], abi: z4 }, options: i34 });
}
var L3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0)))] };
async function Et(t25) {
  let { aptosConfig: o19, creator: n24, digitalAssetAddress: e2, digitalAssetType: r16, options: i34 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [r16 ?? m11], functionArguments: [e2], abi: L3 }, options: i34 });
}
var j3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0)))] };
async function qt(t25) {
  let { aptosConfig: o19, creator: n24, digitalAssetAddress: e2, digitalAssetType: r16, options: i34 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [r16 ?? m11], functionArguments: [e2], abi: j3 }, options: i34 });
}
var X2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2())] };
async function Vt(t25) {
  let { aptosConfig: o19, creator: n24, description: e2, digitalAssetAddress: r16, digitalAssetType: i34, options: a19 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [i34 ?? m11], functionArguments: [c.from(r16), new a3(e2)], abi: X2 }, options: a19 });
}
var H = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2())] };
async function Mt(t25) {
  let { aptosConfig: o19, creator: n24, name: e2, digitalAssetAddress: r16, digitalAssetType: i34, options: a19 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [i34 ?? m11], functionArguments: [c.from(r16), new a3(e2)], abi: H }, options: a19 });
}
var J = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2())] };
async function Rt(t25) {
  let { aptosConfig: o19, creator: n24, uri: e2, digitalAssetAddress: r16, digitalAssetType: i34, options: a19 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [i34 ?? m11], functionArguments: [c.from(r16), new a3(e2)], abi: J }, options: a19 });
}
var W2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2()), new b2(E2()), y2.u8()] };
async function Kt(t25) {
  let { aptosConfig: o19, creator: n24, propertyKey: e2, propertyType: r16, propertyValue: i34, digitalAssetAddress: a19, digitalAssetType: l12, options: y12 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [l12 ?? m11], functionArguments: [c.from(a19), new a3(e2), new a3(C3[r16]), t7.U8(B5(i34, C3[r16]))], abi: W2 }, options: y12 });
}
var Z3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2())] };
async function Qt(t25) {
  let { aptosConfig: o19, creator: n24, propertyKey: e2, digitalAssetAddress: r16, digitalAssetType: i34, options: a19 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [i34 ?? m11], functionArguments: [c.from(r16), new a3(e2)], abi: Z3 }, options: a19 });
}
var $5 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b2(j2(new h5(0))), new b2(E2()), new b2(E2()), y2.u8()] };
async function Ut(t25) {
  let { aptosConfig: o19, creator: n24, propertyKey: e2, propertyType: r16, propertyValue: i34, digitalAssetAddress: a19, digitalAssetType: l12, options: y12 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [l12 ?? m11], functionArguments: [c.from(a19), new a3(e2), new a3(C3[r16]), B5(i34, C3[r16])], abi: $5 }, options: y12 });
}
var tt = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b2(j2(new h5(0))), new b2(E2()), new h5(1)] };
async function Ft(t25) {
  let { aptosConfig: o19, creator: n24, propertyKey: e2, propertyType: r16, propertyValue: i34, digitalAssetAddress: a19, digitalAssetType: l12, options: y12 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [l12 ?? m11, C3[r16]], functionArguments: [c.from(a19), new a3(e2), i34], abi: tt }, options: y12 });
}
var et = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b2(j2(new h5(0))), new b2(E2()), new h5(1)] };
async function Nt(t25) {
  let { aptosConfig: o19, creator: n24, propertyKey: e2, propertyType: r16, propertyValue: i34, digitalAssetAddress: a19, digitalAssetType: l12, options: y12 } = t25;
  return h9({ aptosConfig: o19, sender: n24.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [l12 ?? m11, C3[r16]], functionArguments: [c.from(a19), new a3(e2), i34], abi: et }, options: y12 });
}
function R4(t25, o19) {
  let n24 = new Array();
  return o19.forEach((e2, r16) => {
    n24.push(B5(t25[r16], e2));
  }), n24;
}
function B5(t25, o19) {
  let n24 = Z(o19);
  return U6(t25, n24, 0, []).bcsToBytes();
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UNVGVVGS.mjs
var V3 = class {
  constructor(t25) {
    this.config = t25;
  }
  async getCollectionData(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), U9({ aptosConfig: this.config, ...t25 });
  }
  async getCollectionDataByCollectionId(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), vt({ aptosConfig: this.config, ...t25 });
  }
  async getCollectionId(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), ht({ aptosConfig: this.config, ...t25 });
  }
  async getDigitalAssetData(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), _t({ aptosConfig: this.config, ...t25 });
  }
  async getCurrentDigitalAssetOwnership(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), Pt({ aptosConfig: this.config, ...t25 });
  }
  async getOwnedDigitalAssets(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), kt({ aptosConfig: this.config, ...t25 });
  }
  async getDigitalAssetActivity(t25) {
    return await i5({ config: this.config, minimumLedgerVersion: t25.minimumLedgerVersion, processorType: "token_v2_processor" }), Dt({ aptosConfig: this.config, ...t25 });
  }
  async createCollectionTransaction(t25) {
    return St({ aptosConfig: this.config, ...t25 });
  }
  async mintDigitalAssetTransaction(t25) {
    return xt({ aptosConfig: this.config, ...t25 });
  }
  async transferDigitalAssetTransaction(t25) {
    return Gt({ aptosConfig: this.config, ...t25 });
  }
  async mintSoulBoundTransaction(t25) {
    return Bt({ aptosConfig: this.config, ...t25 });
  }
  async burnDigitalAssetTransaction(t25) {
    return Ot({ aptosConfig: this.config, ...t25 });
  }
  async freezeDigitalAssetTransaferTransaction(t25) {
    return Et({ aptosConfig: this.config, ...t25 });
  }
  async unfreezeDigitalAssetTransaferTransaction(t25) {
    return qt({ aptosConfig: this.config, ...t25 });
  }
  async setDigitalAssetDescriptionTransaction(t25) {
    return Vt({ aptosConfig: this.config, ...t25 });
  }
  async setDigitalAssetNameTransaction(t25) {
    return Mt({ aptosConfig: this.config, ...t25 });
  }
  async setDigitalAssetURITransaction(t25) {
    return Rt({ aptosConfig: this.config, ...t25 });
  }
  async addDigitalAssetPropertyTransaction(t25) {
    return Kt({ aptosConfig: this.config, ...t25 });
  }
  async removeDigitalAssetPropertyTransaction(t25) {
    return Qt({ aptosConfig: this.config, ...t25 });
  }
  async updateDigitalAssetPropertyTransaction(t25) {
    return Ut({ aptosConfig: this.config, ...t25 });
  }
  async addDigitalAssetTypedPropertyTransaction(t25) {
    return Ft({ aptosConfig: this.config, ...t25 });
  }
  async updateDigitalAssetTypedPropertyTransaction(t25) {
    return Nt({ aptosConfig: this.config, ...t25 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VZRPR2YE.mjs
var g6 = 300;
var y9 = (o19) => {
  if (o19 && o19.length > g6)
    throw new Error(`Event type length exceeds the maximum length of ${g6}`);
};
async function f11(o19) {
  let { aptosConfig: n24, eventType: e2, options: t25 } = o19, r16 = { where: { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, creation_number: { _eq: "0" }, sequence_number: { _eq: "0" }, indexed_type: { _eq: e2 } }, pagination: t25, orderBy: t25 == null ? void 0 : t25.orderBy };
  return c7({ aptosConfig: n24, options: r16 });
}
async function h11(o19) {
  let { accountAddress: n24, aptosConfig: e2, creationNumber: t25, options: s17 } = o19, i34 = { where: { account_address: { _eq: c.from(n24).toStringLong() }, creation_number: { _eq: t25 } }, pagination: s17, orderBy: s17 == null ? void 0 : s17.orderBy };
  return c7({ aptosConfig: e2, options: i34 });
}
async function _4(o19) {
  let { accountAddress: n24, aptosConfig: e2, eventType: t25, options: s17 } = o19, i34 = { where: { account_address: { _eq: c.from(n24).toStringLong() }, indexed_type: { _eq: t25 } }, pagination: s17, orderBy: s17 == null ? void 0 : s17.orderBy };
  return c7({ aptosConfig: e2, options: i34 });
}
async function c7(o19) {
  var _a, _b;
  let { aptosConfig: n24, options: e2 } = o19;
  y9((_b = (_a = e2 == null ? void 0 : e2.where) == null ? void 0 : _a.indexed_type) == null ? void 0 : _b._eq);
  let t25 = { query: f, variables: { where_condition: e2 == null ? void 0 : e2.where, offset: e2 == null ? void 0 : e2.offset, limit: e2 == null ? void 0 : e2.limit, order_by: e2 == null ? void 0 : e2.orderBy } };
  return (await p3({ aptosConfig: n24, query: t25, originMethod: "getEvents" })).events;
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-U2HNE4PC.mjs
var i33 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getModuleEventsByEventType(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "events_processor" }), f11({ aptosConfig: this.config, ...e2 });
  }
  async getAccountEventsByCreationNumber(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "events_processor" }), h11({ aptosConfig: this.config, ...e2 });
  }
  async getAccountEventsByEventType(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "events_processor" }), _4({ aptosConfig: this.config, ...e2 });
  }
  async getEvents(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "events_processor" }), c7({ aptosConfig: this.config, ...e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-M77RV2XT.mjs
async function x6(a19) {
  let { aptosConfig: t25, accountAddress: i34, amount: p11, options: n24 } = a19, u11 = (n24 == null ? void 0 : n24.timeoutSecs) || 20, { data: d10 } = await x({ aptosConfig: t25, path: "fund", body: { address: c.from(i34).toString(), amount: p11 }, originMethod: "fundAccount" }), m13 = d10.txn_hashes[0], o19 = await G2({ aptosConfig: t25, transactionHash: m13, options: { timeoutSecs: u11, checkSuccess: n24 == null ? void 0 : n24.checkSuccess } });
  if (o19.type === "user_transaction")
    return o19;
  throw new Error(`Unexpected transaction received for fund account: ${o19.type}`);
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Y62RU5NY.mjs
var r14 = class {
  constructor(o19) {
    this.config = o19;
  }
  async fundAccount(o19) {
    var _a;
    let n24 = await x6({ aptosConfig: this.config, ...o19 });
    return ((_a = o19.options) == null ? void 0 : _a.waitForIndexer) !== false && await D({ aptosConfig: this.config, minimumLedgerVersion: BigInt(n24.version) }), n24;
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5JELAPRW.mjs
async function h12(t25) {
  let { aptosConfig: s17, options: e2 } = t25, n24 = { query: h3, variables: { where_condition: e2 == null ? void 0 : e2.where, limit: e2 == null ? void 0 : e2.limit, offset: e2 == null ? void 0 : e2.offset } };
  return (await p3({ aptosConfig: s17, query: n24, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function M4(t25) {
  let { aptosConfig: s17, options: e2 } = t25, n24 = { query: v, variables: { where_condition: e2 == null ? void 0 : e2.where, limit: e2 == null ? void 0 : e2.limit, offset: e2 == null ? void 0 : e2.offset } };
  return (await p3({ aptosConfig: s17, query: n24, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function x7(t25) {
  let { aptosConfig: s17, options: e2 } = t25, n24 = { query: k, variables: { where_condition: e2 == null ? void 0 : e2.where, limit: e2 == null ? void 0 : e2.limit, offset: e2 == null ? void 0 : e2.offset } };
  return (await p3({ aptosConfig: s17, query: n24, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var b7 = { typeParameters: [], parameters: [Z("0x1::object::Object"), new S(), new p5()] };
async function v4(t25) {
  let { aptosConfig: s17, sender: e2, fungibleAssetMetadataAddress: n24, recipient: i34, amount: p11, options: f13 } = t25;
  return h9({ aptosConfig: s17, sender: e2.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [n24, i34, p11], abi: b7 }, options: f13 });
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5O66QE4O.mjs
var r15 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getFungibleAssetMetadata(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), h12({ aptosConfig: this.config, ...e2 });
  }
  async getFungibleAssetMetadataByAssetType(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await h12({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e2.assetType } } } }))[0];
  }
  async getFungibleAssetActivities(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), M4({ aptosConfig: this.config, ...e2 });
  }
  async getCurrentFungibleAssetBalances(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2 == null ? void 0 : e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), x7({ aptosConfig: this.config, ...e2 });
  }
  async transferFungibleAsset(e2) {
    return v4({ aptosConfig: this.config, ...e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZUJAMDAE.mjs
var u9 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getLedgerInfo() {
    return l4({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(e2) {
    return h4({ aptosConfig: this.config, ...e2 });
  }
  async getBlockByHeight(e2) {
    return m2({ aptosConfig: this.config, ...e2 });
  }
  async getTableItem(e2) {
    return C2({ aptosConfig: this.config, ...e2 });
  }
  async view(e2) {
    return T3({ aptosConfig: this.config, ...e2 });
  }
  async getChainTopUserTransactions(e2) {
    return q2({ aptosConfig: this.config, ...e2 });
  }
  async queryIndexer(e2) {
    return p3({ aptosConfig: this.config, ...e2 });
  }
  async getIndexerLastSuccessVersion() {
    return w3({ aptosConfig: this.config });
  }
  async getProcessorStatus(e2) {
    return A4({ aptosConfig: this.config, processorType: e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A3ILBBGZ.mjs
var l10 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getAccountInfo(e2) {
    return M2({ aptosConfig: this.config, ...e2 });
  }
  async getAccountModules(e2) {
    return go({ aptosConfig: this.config, ...e2 });
  }
  async getAccountModule(e2) {
    return Ao({ aptosConfig: this.config, ...e2 });
  }
  async getAccountTransactions(e2) {
    return po({ aptosConfig: this.config, ...e2 });
  }
  async getAccountResources(e2) {
    return fo({ aptosConfig: this.config, ...e2 });
  }
  async getAccountResource(e2) {
    return K({ aptosConfig: this.config, ...e2 });
  }
  async lookupOriginalAccountAddress(e2) {
    return Q2({ aptosConfig: this.config, ...e2 });
  }
  async getAccountTokensCount(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "account_transactions_processor" }), lo({ aptosConfig: this.config, ...e2 });
  }
  async getAccountOwnedTokens(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "token_v2_processor" }), yo({ aptosConfig: this.config, ...e2 });
  }
  async getAccountOwnedTokensFromCollectionAddress(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "token_v2_processor" }), mo({ aptosConfig: this.config, ...e2 });
  }
  async getAccountCollectionsWithOwnedTokens(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "token_v2_processor" }), _o({ aptosConfig: this.config, ...e2 });
  }
  async getAccountTransactionsCount(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "account_transactions_processor" }), Co({ aptosConfig: this.config, ...e2 });
  }
  async getAccountCoinsData(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), I2({ aptosConfig: this.config, ...e2 });
  }
  async getAccountCoinsCount(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), wo({ aptosConfig: this.config, ...e2 });
  }
  async getAccountAPTAmount(e2) {
    return this.getAccountCoinAmount({ coinType: N, ...e2 });
  }
  async getAccountCoinAmount(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ho({ aptosConfig: this.config, ...e2 });
  }
  async getAccountOwnedObjects(e2) {
    return await i5({ config: this.config, minimumLedgerVersion: e2.minimumLedgerVersion, processorType: "default_processor" }), ko({ aptosConfig: this.config, ...e2 });
  }
  async deriveAccountFromPrivateKey(e2) {
    return To({ aptosConfig: this.config, ...e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AWYUVMW7.mjs
var E5 = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function D6(e2) {
  return !(!e2 || e2.length < 3 || e2.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(e2));
}
function c8(e2) {
  let [n24, t25, ...o19] = e2.replace(/\.apt$/, "").split(".");
  if (o19.length > 0)
    throw new Error(`${e2} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!D6(n24))
    throw new Error(`${n24} is not valid. ${E5}`);
  if (t25 && !D6(t25))
    throw new Error(`${t25} is not valid. ${E5}`);
  return { domainName: t25 || n24, subdomainName: t25 ? n24 : void 0 };
}
var G6 = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
var O3 = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: G6, custom: null, devnet: null, randomnet: null };
function d8(e2) {
  let n24 = O3[e2.network];
  if (!n24)
    throw new Error(`The ANS contract is not deployed to ${e2.network}`);
  return n24;
}
var P4 = (e2) => ({ vec: [e2] });
var I3 = () => ({ vec: [] });
var S5 = (e2) => e2 != null ? P4(e2) : I3();
var b8 = (e2) => {
  if (e2 && typeof e2 == "object" && "vec" in e2 && Array.isArray(e2.vec))
    return e2.vec[0];
};
async function K3(e2) {
  let { aptosConfig: n24, name: t25 } = e2, o19 = d8(n24), { domainName: r16, subdomainName: s17 } = c8(t25), i34 = await T3({ aptosConfig: n24, payload: { function: `${o19}::router::get_owner_addr`, functionArguments: [r16, S5(s17)] } }), a19 = b8(i34[0]);
  return a19 ? c.from(a19).toString() : void 0;
}
async function W3(e2) {
  let { aptosConfig: n24, expiration: t25, name: o19, sender: r16, targetAddress: s17, toAddress: i34, options: a19, transferable: m13 } = e2, p11 = d8(n24), { domainName: l12, subdomainName: N7 } = c8(o19), x9 = t25.policy === "subdomain:independent" || t25.policy === "subdomain:follow-domain";
  if (N7 && !x9)
    throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (x9 && !N7)
    throw new Error(`Policy is set to ${t25.policy} but no subdomain was provided`);
  if (t25.policy === "domain") {
    let T10 = t25.years ?? 1;
    if (T10 !== 1)
      throw new Error("For now, names can only be registered for 1 year at a time");
    let v6 = T10 * 31536e3;
    return await h9({ aptosConfig: n24, sender: r16.accountAddress.toString(), data: { function: `${p11}::router::register_domain`, functionArguments: [l12, v6, s17, i34] }, options: a19 });
  }
  if (!N7)
    throw new Error(`${t25.policy} requires a subdomain to be provided.`);
  let _6 = await q3({ aptosConfig: n24, name: l12 });
  if (!_6)
    throw new Error("The domain does not exist");
  let h14 = t25.policy === "subdomain:independent" ? t25.expirationDate : _6;
  if (h14 > _6)
    throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await h9({ aptosConfig: n24, sender: r16.accountAddress.toString(), data: { function: `${p11}::router::register_subdomain`, functionArguments: [l12, N7, Math.round(h14 / 1e3), t25.policy === "subdomain:follow-domain" ? 1 : 0, !!m13, s17, i34] }, options: a19 });
}
async function q3(e2) {
  let { aptosConfig: n24, name: t25 } = e2, o19 = d8(n24), { domainName: r16, subdomainName: s17 } = c8(t25);
  try {
    let i34 = await T3({ aptosConfig: n24, payload: { function: `${o19}::router::get_expiration`, functionArguments: [r16, S5(s17)] } });
    return Number(i34[0]) * 1e3;
  } catch {
    return;
  }
}
async function F4(e2) {
  let { aptosConfig: n24, address: t25 } = e2, o19 = d8(n24), r16 = await T3({ aptosConfig: n24, payload: { function: `${o19}::router::get_primary_name`, functionArguments: [c.from(t25).toString()] } }), s17 = b8(r16[1]), i34 = b8(r16[0]);
  if (s17)
    return [i34, s17].filter(Boolean).join(".");
}
async function H2(e2) {
  let { aptosConfig: n24, sender: t25, name: o19, options: r16 } = e2, s17 = d8(n24);
  if (!o19)
    return await h9({ aptosConfig: n24, sender: t25.accountAddress.toString(), data: { function: `${s17}::router::clear_primary_name`, functionArguments: [] }, options: r16 });
  let { domainName: i34, subdomainName: a19 } = c8(o19);
  return await h9({ aptosConfig: n24, sender: t25.accountAddress.toString(), data: { function: `${s17}::router::set_primary_name`, functionArguments: [i34, a19] }, options: r16 });
}
async function J2(e2) {
  let { aptosConfig: n24, name: t25 } = e2, o19 = d8(n24), { domainName: r16, subdomainName: s17 } = c8(t25), i34 = await T3({ aptosConfig: n24, payload: { function: `${o19}::router::get_target_addr`, functionArguments: [r16, S5(s17)] } }), a19 = b8(i34[0]);
  return a19 ? c.from(a19).toString() : void 0;
}
async function X3(e2) {
  let { aptosConfig: n24, sender: t25, name: o19, address: r16, options: s17 } = e2, i34 = d8(n24), { domainName: a19, subdomainName: m13 } = c8(o19);
  return await h9({ aptosConfig: n24, sender: t25.accountAddress.toString(), data: { function: `${i34}::router::set_target_addr`, functionArguments: [a19, m13, r16] }, options: s17 });
}
async function Z4(e2) {
  let { aptosConfig: n24, name: t25 } = e2, { domainName: o19, subdomainName: r16 = "" } = c8(t25), a19 = (await p3({ aptosConfig: n24, query: { query: A2, variables: { where_condition: { domain: { _eq: o19 }, subdomain: { _eq: r16 } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return a19 && (a19 = y10(a19)), a19;
}
async function ee(e2) {
  var _a;
  let { aptosConfig: n24, options: t25, accountAddress: o19 } = e2, r16 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountNames", query: { query: A2, variables: { limit: t25 == null ? void 0 : t25.limit, offset: t25 == null ? void 0 : t25.offset, order_by: t25 == null ? void 0 : t25.orderBy, where_condition: { ...((_a = e2.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o19.toString() }, expiration_timestamp: { _gte: r16 } } } } })).current_aptos_names.map(y10);
}
async function ne(e2) {
  var _a;
  let { aptosConfig: n24, options: t25, accountAddress: o19 } = e2, r16 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountDomains", query: { query: A2, variables: { limit: t25 == null ? void 0 : t25.limit, offset: t25 == null ? void 0 : t25.offset, order_by: t25 == null ? void 0 : t25.orderBy, where_condition: { ...((_a = e2.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o19.toString() }, expiration_timestamp: { _gte: r16 }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(y10);
}
async function te(e2) {
  var _a;
  let { aptosConfig: n24, options: t25, accountAddress: o19 } = e2, r16 = await C4({ aptosConfig: n24 });
  return (await p3({ aptosConfig: n24, originMethod: "getAccountSubdomains", query: { query: A2, variables: { limit: t25 == null ? void 0 : t25.limit, offset: t25 == null ? void 0 : t25.offset, order_by: t25 == null ? void 0 : t25.orderBy, where_condition: { ...((_a = e2.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o19.toString() }, expiration_timestamp: { _gte: r16 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y10);
}
async function oe(e2) {
  var _a;
  let { aptosConfig: n24, options: t25, domain: o19 } = e2;
  return (await p3({ aptosConfig: n24, originMethod: "getDomainSubdomains", query: { query: A2, variables: { limit: t25 == null ? void 0 : t25.limit, offset: t25 == null ? void 0 : t25.offset, order_by: t25 == null ? void 0 : t25.orderBy, where_condition: { ...((_a = e2.options) == null ? void 0 : _a.where) ?? {}, domain: { _eq: o19 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(y10);
}
async function C4(e2) {
  let { aptosConfig: n24 } = e2, t25 = d8(n24), [o19] = await T3({ aptosConfig: n24, payload: { function: `${t25}::config::reregistration_grace_sec`, functionArguments: [] } }), r16 = o19 / 60 / 60 / 24, s17 = () => /* @__PURE__ */ new Date();
  return new Date(s17().setDate(s17().getDate() - r16)).toISOString();
}
async function re(e2) {
  let { aptosConfig: n24, sender: t25, name: o19, years: r16 = 1, options: s17 } = e2, i34 = d8(n24), a19 = r16 * 31536e3, { domainName: m13, subdomainName: p11 } = c8(o19);
  if (p11)
    throw new Error("Subdomains cannot be renewed");
  if (r16 !== 1)
    throw new Error("Currently, only 1 year renewals are supported");
  return await h9({ aptosConfig: n24, sender: t25.accountAddress.toString(), data: { function: `${i34}::router::renew_domain`, functionArguments: [m13, a19] }, options: s17 });
}
function y10(e2) {
  return { ...e2, expiration_timestamp: new Date(e2.expiration_timestamp).valueOf() };
}

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A6VQIWVY.mjs
var A11 = class {
  constructor(e2) {
    this.config = e2;
  }
  async getOwnerAddress(e2) {
    return K3({ aptosConfig: this.config, ...e2 });
  }
  async getExpiration(e2) {
    return q3({ aptosConfig: this.config, ...e2 });
  }
  async getTargetAddress(e2) {
    return J2({ aptosConfig: this.config, ...e2 });
  }
  async setTargetAddress(e2) {
    return X3({ aptosConfig: this.config, ...e2 });
  }
  async getPrimaryName(e2) {
    return F4({ aptosConfig: this.config, ...e2 });
  }
  async setPrimaryName(e2) {
    return H2({ aptosConfig: this.config, ...e2 });
  }
  async registerName(e2) {
    return W3({ aptosConfig: this.config, ...e2 });
  }
  async renewDomain(e2) {
    return re({ aptosConfig: this.config, ...e2 });
  }
  async getName(e2) {
    return Z4({ aptosConfig: this.config, ...e2 });
  }
  async getAccountNames(e2) {
    return ee({ aptosConfig: this.config, ...e2 });
  }
  async getAccountDomains(e2) {
    return ne({ aptosConfig: this.config, ...e2 });
  }
  async getAccountSubdomains(e2) {
    return te({ aptosConfig: this.config, ...e2 });
  }
  async getDomainSubdomains(e2) {
    return oe({ aptosConfig: this.config, ...e2 });
  }
};

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5M4G6WNG.mjs
var t24 = class {
  constructor(i34) {
    this.config = new n21(i34), this.account = new l10(this.config), this.ans = new A11(this.config), this.coin = new t23(this.config), this.digitalAsset = new V3(this.config), this.event = new i33(this.config), this.faucet = new r14(this.config), this.fungibleAsset = new r15(this.config), this.general = new u9(this.config), this.staking = new t3(this.config), this.transaction = new h10(this.config);
  }
};
function n22(m13, i34, A13) {
  Object.getOwnPropertyNames(i34.prototype).forEach((e2) => {
    let o19 = Object.getOwnPropertyDescriptor(i34.prototype, e2);
    o19 && (o19.value = function(...d10) {
      return this[A13][e2](...d10);
    }, Object.defineProperty(m13.prototype, e2, o19));
  });
}
n22(t24, l10, "account");
n22(t24, A11, "ans");
n22(t24, t23, "coin");
n22(t24, V3, "digitalAsset");
n22(t24, i33, "event");
n22(t24, r14, "faucet");
n22(t24, r15, "fungibleAsset");
n22(t24, u9, "general");
n22(t24, t3, "staking");
n22(t24, h10, "transaction");

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NMNR3QST.mjs
var a18 = ((i34) => (i34.JSON = "application/json", i34.BCS = "application/x-bcs", i34.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", i34))(a18 || {});
var g7 = ((e2) => (e2[e2.Bool = 0] = "Bool", e2[e2.U8 = 1] = "U8", e2[e2.U64 = 2] = "U64", e2[e2.U128 = 3] = "U128", e2[e2.Address = 4] = "Address", e2[e2.Signer = 5] = "Signer", e2[e2.Vector = 6] = "Vector", e2[e2.Struct = 7] = "Struct", e2[e2.U16 = 8] = "U16", e2[e2.U32 = 9] = "U32", e2[e2.U256 = 10] = "U256", e2[e2.Reference = 254] = "Reference", e2[e2.Generic = 255] = "Generic", e2))(g7 || {});
var y11 = ((o19) => (o19[o19.U8 = 0] = "U8", o19[o19.U64 = 1] = "U64", o19[o19.U128 = 2] = "U128", o19[o19.Address = 3] = "Address", o19[o19.U8Vector = 4] = "U8Vector", o19[o19.Bool = 5] = "Bool", o19[o19.U16 = 6] = "U16", o19[o19.U32 = 7] = "U32", o19[o19.U256 = 8] = "U256", o19))(y11 || {});
var u10 = ((i34) => (i34[i34.Script = 0] = "Script", i34[i34.EntryFunction = 2] = "EntryFunction", i34[i34.Multisig = 3] = "Multisig", i34))(u10 || {});
var d9 = ((r16) => (r16[r16.MultiAgentTransaction = 0] = "MultiAgentTransaction", r16[r16.FeePayerTransaction = 1] = "FeePayerTransaction", r16))(d9 || {});
var c9 = ((s17) => (s17[s17.Ed25519 = 0] = "Ed25519", s17[s17.MultiEd25519 = 1] = "MultiEd25519", s17[s17.MultiAgent = 2] = "MultiAgent", s17[s17.FeePayer = 3] = "FeePayer", s17[s17.SingleSender = 4] = "SingleSender", s17))(c9 || {});
var l11 = ((n24) => (n24[n24.Ed25519 = 0] = "Ed25519", n24[n24.MultiEd25519 = 1] = "MultiEd25519", n24[n24.SingleKey = 2] = "SingleKey", n24[n24.MultiKey = 3] = "MultiKey", n24))(l11 || {});
var _5 = ((r16) => (r16[r16.Ed25519 = 0] = "Ed25519", r16[r16.Secp256k1 = 1] = "Secp256k1", r16))(_5 || {});
var x8 = ((r16) => (r16[r16.Ed25519 = 0] = "Ed25519", r16[r16.Secp256k1 = 1] = "Secp256k1", r16))(x8 || {});
var v5 = ((p11) => (p11.Pending = "pending_transaction", p11.User = "user_transaction", p11.Genesis = "genesis_transaction", p11.BlockMetadata = "block_metadata_transaction", p11.StateCheckpoint = "state_checkpoint_transaction", p11.Validator = "validator_transaction", p11))(v5 || {});
function k2(t25) {
  return t25.type === "pending_transaction";
}
function f12(t25) {
  return t25.type === "user_transaction";
}
function T9(t25) {
  return t25.type === "genesis_transaction";
}
function E6(t25) {
  return t25.type === "block_metadata_transaction";
}
function C5(t25) {
  return t25.type === "state_checkpoint_transaction";
}
function U10(t25) {
  return t25.type === "validator_transaction";
}
function A12(t25) {
  return "signature" in t25 && t25.signature === "ed25519_signature";
}
function W4(t25) {
  return "signature" in t25 && t25.signature === "secp256k1_ecdsa_signature";
}
function P5(t25) {
  return t25.type === "multi_agent_signature";
}
function F5(t25) {
  return t25.type === "fee_payer_signature";
}
function I4(t25) {
  return t25.type === "multi_ed25519_signature";
}
var h13 = ((i34) => (i34.PRIVATE = "private", i34.PUBLIC = "public", i34.FRIEND = "friend", i34))(h13 || {});
var M5 = ((n24) => (n24.STORE = "store", n24.DROP = "drop", n24.KEY = "key", n24.COPY = "copy", n24))(M5 || {});
var m12 = ((r16) => (r16.VALIDATOR = "validator", r16.FULL_NODE = "full_node", r16))(m12 || {});
var R5 = ((n24) => (n24[n24.Ed25519 = 0] = "Ed25519", n24[n24.MultiEd25519 = 1] = "MultiEd25519", n24[n24.SingleKey = 2] = "SingleKey", n24[n24.MultiKey = 3] = "MultiKey", n24))(R5 || {});
var S6 = ((r16) => (r16[r16.Ed25519 = 0] = "Ed25519", r16[r16.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", r16))(S6 || {});
var b9 = ((s17) => (s17[s17.DeriveAuid = 251] = "DeriveAuid", s17[s17.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", s17[s17.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", s17[s17.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", s17[s17.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", s17))(b9 || {});

// E:/Proj/HXProjs/lucky-pocket/node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6IFMQ5AS.mjs
var n23 = class {
  constructor(e2) {
    this.buffer = new ArrayBuffer(e2.length), new Uint8Array(this.buffer).set(e2, 0), this.offset = 0;
  }
  read(e2) {
    if (this.offset + e2 > this.buffer.byteLength)
      throw new Error("Reached to the end of buffer");
    let i34 = this.buffer.slice(this.offset, this.offset + e2);
    return this.offset += e2, i34;
  }
  deserializeStr() {
    let e2 = this.deserializeBytes();
    return new TextDecoder().decode(e2);
  }
  deserializeBytes() {
    let e2 = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(e2));
  }
  deserializeFixedBytes(e2) {
    return new Uint8Array(this.read(e2));
  }
  deserializeBool() {
    let e2 = new Uint8Array(this.read(1))[0];
    if (e2 !== 1 && e2 !== 0)
      throw new Error("Invalid boolean value");
    return e2 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    let e2 = this.deserializeU32(), i34 = this.deserializeU32();
    return BigInt(BigInt(i34) << BigInt(32) | BigInt(e2));
  }
  deserializeU128() {
    let e2 = this.deserializeU64(), i34 = this.deserializeU64();
    return BigInt(i34 << BigInt(64) | e2);
  }
  deserializeU256() {
    let e2 = this.deserializeU128(), i34 = this.deserializeU128();
    return BigInt(i34 << BigInt(128) | e2);
  }
  deserializeUleb128AsU32() {
    let e2 = BigInt(0), i34 = 0;
    for (; e2 < U; ) {
      let r16 = this.deserializeU8();
      if (e2 |= BigInt(r16 & 127) << BigInt(i34), !(r16 & 128))
        break;
      i34 += 7;
    }
    if (e2 > U)
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(e2);
  }
  deserialize(e2) {
    return e2.deserialize(this);
  }
  deserializeVector(e2) {
    let i34 = this.deserializeUleb128AsU32(), r16 = new Array();
    for (let s17 = 0; s17 < i34; s17 += 1)
      r16.push(this.deserialize(e2));
    return r16;
  }
};

export {
  require_nacl_fast,
  aptosClient,
  s,
  l,
  i,
  B,
  n3 as n,
  A,
  g,
  w,
  h2 as h,
  c,
  s3 as s2,
  c3 as c2,
  T2 as T,
  s4 as s3,
  A3 as A2,
  f2 as f,
  x,
  p2 as p,
  g3 as g2,
  f3 as f2,
  O,
  t2 as t,
  R,
  n5 as n2,
  N,
  T4 as T2,
  o4 as o,
  E,
  r4 as r,
  t5 as t2,
  c4 as c3,
  u3 as u,
  d2 as d,
  g4 as g3,
  p5 as p2,
  z,
  T6 as T3,
  S,
  U2 as U,
  x3 as x2,
  h5 as h2,
  y2 as y,
  b2 as b,
  o6 as o2,
  O2,
  E2,
  V,
  j2 as j,
  S2,
  r5 as r2,
  Z,
  t6 as t3,
  d3 as d2,
  U3 as U2,
  p6 as p3,
  b3 as b2,
  y3 as y2,
  m6 as m,
  B2,
  t7 as t4,
  a3 as a,
  z2,
  M,
  D2 as D,
  N4 as N2,
  P,
  w4 as w2,
  G3 as G,
  A6 as A3,
  T7 as T4,
  E3,
  d4 as d3,
  x4 as x3,
  S3,
  B3,
  U4 as U3,
  I,
  b4 as b3,
  $3 as $,
  R2,
  W,
  L2 as L,
  t8 as t5,
  a4 as a2,
  o7 as o3,
  d5 as d4,
  m7 as m2,
  y4 as y3,
  g5 as g4,
  D3 as D2,
  E4,
  A7 as A4,
  f6 as f3,
  U5 as U4,
  h6 as h3,
  c5 as c4,
  m8 as m3,
  S4,
  y5 as y4,
  d6 as d5,
  y6 as y5,
  u4 as u2,
  f8 as f4,
  y7 as y6,
  b5 as b4,
  o11 as o4,
  f9 as f5,
  A8 as A5,
  r10 as r3,
  n13 as n3,
  a11 as a3,
  u5 as u3,
  l6 as l2,
  a12 as a4,
  p8 as p4,
  o12 as o5,
  Z2,
  P3 as P2,
  a14 as a5,
  U6 as U5,
  o13 as o6,
  t14 as t6,
  D4 as D3,
  a15 as a6,
  A9 as A6,
  z3,
  h7 as h4,
  l8 as l3,
  U7 as U6,
  f10 as f6,
  b6 as b5,
  r11 as r4,
  t22 as t7,
  o14 as o7,
  u6 as u4,
  p9 as p5,
  n15 as n4,
  o15 as o8,
  d7 as d6,
  u7 as u5,
  l9 as l4,
  A10 as A7,
  n16 as n5,
  n17 as n6,
  o17 as o9,
  a17 as a7,
  e,
  s16 as s4,
  r12 as r5,
  Fn,
  sn,
  un,
  Nn,
  Wn,
  h8 as h5,
  Gn,
  Un,
  tn,
  dn,
  An,
  c6 as c5,
  r13 as r6,
  p10 as p6,
  T8 as T5,
  m10 as m4,
  n21 as n7,
  t24 as t8,
  a18 as a8,
  g7 as g5,
  y11 as y7,
  u10 as u6,
  d9 as d7,
  c9 as c6,
  l11 as l5,
  _5 as _,
  x8 as x4,
  v5 as v,
  k2 as k,
  f12 as f7,
  T9 as T6,
  E6 as E5,
  C5 as C,
  U10 as U7,
  A12 as A8,
  W4 as W2,
  P5 as P3,
  F5 as F,
  I4 as I2,
  h13 as h6,
  M5 as M2,
  m12 as m5,
  R5 as R3,
  S6 as S5,
  b9 as b6,
  n23 as n8
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-2L6H2TFA.js.map
