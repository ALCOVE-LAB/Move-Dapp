// src/index.ts
import { AccountAddress, AccountAuthenticator } from "@aptos-labs/ts-sdk";
import {
  areBCSArguments
} from "@aptos-labs/wallet-adapter-core";
import { TxnBuilderTypes as TxnBuilderTypes2 } from "aptos";

// src/conversion.ts
import {
  AptosConfig,
  Network,
  TypeTag,
  Deserializer,
  generateTransactionPayload
} from "@aptos-labs/ts-sdk";
import { BCS, TxnBuilderTypes } from "aptos";
function convertV1toV2(src, dst) {
  const serializedBytes = BCS.bcsToBytes(src);
  const deserializerV2 = new Deserializer(serializedBytes);
  return dst.deserialize(deserializerV2);
}
function convertV2toV1(src, dst) {
  const serializedBytes = src.bcsToBytes();
  const deserializerV1 = new BCS.Deserializer(serializedBytes);
  return dst.deserialize(deserializerV1);
}
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name.toLowerCase()) {
    case "mainnet":
      return Network.MAINNET;
    case "testnet":
      return Network.TESTNET;
    case "devnet":
      return Network.DEVNET;
    default:
      throw new Error("Invalid network name");
  }
}
function convertV2JsonPayloadToV1(payload) {
  var _a;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  }
  const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
    (typeTag) => {
      if (typeTag instanceof TypeTag) {
        return typeTag.toString();
      }
      return typeTag;
    }
  );
  return {
    type: "entry_function_payload",
    function: payload.function,
    type_arguments: stringTypeTags || [],
    arguments: payload.functionArguments
  };
}
async function generateV1TransactionPayload(payloadData, network) {
  const aptosConfig = new AptosConfig({
    network: convertNetwork(network)
  });
  const newPayload = await generateTransactionPayload({
    ...payloadData,
    aptosConfig
  });
  return convertV2toV1(newPayload, TxnBuilderTypes.TransactionPayload);
}

// src/errors.ts
var PetraApiError = class extends Error {
  constructor(code, status, message) {
    super(message);
    this.code = code;
    this.status = status;
    this.status = status;
    this.code = code;
    Object.setPrototypeOf(this, PetraApiError.prototype);
  }
};
var PetraApiErrors = Object.freeze({
  INTERNAL_ERROR: new PetraApiError(-30001, "Internal Error", "Internal Error"),
  NO_ACCOUNTS: new PetraApiError(4e3, "No Accounts", "No accounts found"),
  TIME_OUT: new PetraApiError(
    4002,
    "Time Out",
    "The prompt timed out without a response. This could be because the user did not respond or because a new request was opened."
  ),
  UNAUTHORIZED: new PetraApiError(
    4100,
    "Unauthorized",
    "The requested method and/or account has not been authorized by the user."
  ),
  UNSUPPORTED: new PetraApiError(
    4200,
    "Unsupported",
    "The provider does not support the requested method."
  ),
  USER_REJECTION: new PetraApiError(
    4001,
    "Rejected",
    "The user rejected the request"
  )
});
function codeToError(code) {
  return Object.values(PetraApiErrors).find((error) => error.code === code) ?? PetraApiErrors.INTERNAL_ERROR;
}

// src/index.ts
function isObjectPropsUnsupportedError(err) {
  return err instanceof Error && err.message === "Cannot read properties of undefined (reading 'map')";
}
function areOptionsEmpty(options) {
  return options === void 0 || Object.keys(options).length === 0 || Object.values(options).every((v) => v === void 0);
}
function remapPetraError(error) {
  if ("code" in error) {
    throw codeToError(error.code);
  }
  throw error;
}
function remapTransactionOptions(options) {
  return {
    maxGasAmount: (options == null ? void 0 : options.max_gas_amount) ? Number(options == null ? void 0 : options.max_gas_amount) : void 0,
    gasUnitPrice: (options == null ? void 0 : options.gas_unit_price) ? Number(options == null ? void 0 : options.gas_unit_price) : void 0,
    ...options
  };
}
var PetraWalletName = "Petra";
var PetraWallet = class {
  constructor() {
    this.name = PetraWalletName;
    this.version = "v2";
    this.url = "https://chrome.google.com/webstore/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci";
    this.icon = "data:image/png;base64,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";
    this.provider = typeof window !== "undefined" ? window.petra : void 0;
  }
  deeplinkProvider(data) {
    return `https://petra.app/explore?link=${data.url}`;
  }
  async connect() {
    const addressInfo = await this.provider.connect().catch(remapPetraError);
    if (!addressInfo)
      throw `${PetraWalletName} Address Info Error`;
    return addressInfo;
  }
  async account() {
    const response = await this.provider.account().catch(remapPetraError);
    if (!response)
      throw `${PetraWalletName} Account Error`;
    return response;
  }
  async disconnect() {
    return this.provider.disconnect().catch(remapPetraError);
  }
  async signAndSubmitTransaction(payloadV1OrGenerateTxnInput, optionsV1) {
    var _a;
    if ("data" in payloadV1OrGenerateTxnInput) {
      const generateTxnInput = payloadV1OrGenerateTxnInput;
      const options = {
        expirationTimestamp: (_a = generateTxnInput.options) == null ? void 0 : _a.expireTimestamp,
        sender: generateTxnInput.sender ? AccountAddress.from(generateTxnInput.sender).toString() : void 0,
        ...generateTxnInput.options
      };
      if (areBCSArguments(generateTxnInput.data.functionArguments)) {
        const network = await this.network();
        const payload2 = await generateV1TransactionPayload(generateTxnInput.data, network);
        return await this.signAndSubmitBCSTransaction(payload2, options);
      }
      const payload = await convertV2JsonPayloadToV1(generateTxnInput.data);
      return await this.signAndSubmitTransaction(payload, options);
    }
    const payloadV1 = payloadV1OrGenerateTxnInput;
    const response = await this.provider.signAndSubmitTransaction(
      payloadV1,
      optionsV1 ? remapTransactionOptions(optionsV1) : void 0
    ).catch(remapPetraError);
    return response;
  }
  async signAndSubmitBCSTransaction(payload, options) {
    if (!areOptionsEmpty(options)) {
      try {
        const response2 = await this.provider.signAndSubmitTransaction(
          {
            payload,
            options: remapTransactionOptions(options)
          }
        ).catch(remapPetraError);
        return response2;
      } catch (err) {
        if (!isObjectPropsUnsupportedError(err)) {
          throw err;
        }
        console.warn("Options are not supported by your current version of Petra and they will be ignored. Please update to Petra >= 1.2.27.\nIgnored options: ", options);
      }
    }
    const response = await this.provider.signAndSubmitTransaction(
      payload
    ).catch(remapPetraError);
    return response;
  }
  async signMessage(message) {
    if (typeof message !== "object" || !message.nonce) {
      throw `${PetraWalletName} Invalid signMessage Payload`;
    }
    return this.provider.signMessage(message).catch(remapPetraError);
  }
  async signTransaction(transactionOrPayload, optionsOrAsFeePayer) {
    var _a;
    if ("rawTransaction" in transactionOrPayload) {
      const transaction = transactionOrPayload;
      const asFeePayer = optionsOrAsFeePayer ?? false;
      const rawTxnV1 = convertV2toV1(transaction.rawTransaction, TxnBuilderTypes2.RawTransaction);
      const secondarySignersAddressesV1 = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map(
        (address) => convertV2toV1(address, TxnBuilderTypes2.AccountAddress)
      );
      let rawTxn;
      if (asFeePayer) {
        const activeAccount = await this.account();
        const feePayerAddressV1 = TxnBuilderTypes2.AccountAddress.fromHex(activeAccount.address);
        rawTxn = new TxnBuilderTypes2.FeePayerRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1 ?? [],
          feePayerAddressV1
        );
      } else if (transaction.feePayerAddress) {
        const feePayerAddressV1 = convertV2toV1(transaction.feePayerAddress, TxnBuilderTypes2.AccountAddress);
        rawTxn = new TxnBuilderTypes2.FeePayerRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1 ?? [],
          feePayerAddressV1
        );
      } else if (secondarySignersAddressesV1) {
        rawTxn = new TxnBuilderTypes2.MultiAgentRawTransaction(
          rawTxnV1,
          secondarySignersAddressesV1
        );
      } else {
        rawTxn = rawTxnV1;
      }
      try {
        const { accountAuthenticator } = await this.provider.signTransaction(
          { rawTxn }
        ).catch(remapPetraError);
        return convertV1toV2(accountAuthenticator, AccountAuthenticator);
      } catch (err) {
        if (isObjectPropsUnsupportedError(err)) {
          throw new Error("Signing an arbitrary raw transaction is not supported by your current version of Petra. Please update to Petra >= 1.2.27.");
        }
        throw err;
      }
    }
    const payload = transactionOrPayload;
    const options = optionsOrAsFeePayer;
    return await this.provider.signTransaction(
      payload,
      options ? remapTransactionOptions(options) : void 0
    ).catch(remapPetraError);
  }
  async onNetworkChange(callback) {
    var _a;
    (_a = this.provider) == null ? void 0 : _a.onNetworkChange(callback);
  }
  async onAccountChange(callback) {
    var _a;
    (_a = this.provider) == null ? void 0 : _a.onAccountChange(callback);
  }
  async network() {
    const response = await window.petra.getNetwork().catch(remapPetraError);
    return {
      name: response.name,
      chainId: response.chainId,
      url: response.url
    };
  }
};
export {
  PetraWallet,
  PetraWalletName
};
